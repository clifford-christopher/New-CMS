# Story 5.2: Configuration Publishing with isActive Flag

## Status

Draft

## Version

2.0

## Story

**As a** content manager,
**I want** to review and publish configuration with isActive=true,
**so that** the new workflow is activated for production news generation.

## Acceptance Criteria

1. After validation, "Confirm Publish" button opens confirmation modal showing complete configuration
2. Confirmation modal displays:
   - Trigger name and stockid
   - Data mode: OLD | NEW | OLD_NEW
   - Selected sections and order (if NEW/OLD_NEW)
   - Selected model and settings (provider, model, temperature, max_tokens)
   - All 3 prompt types with truncated previews and character counts:
     - üí∞ Paid prompt (truncated, expandable)
     - üÜì Unpaid prompt (truncated, expandable)
     - üï∑Ô∏è Crawler prompt (truncated, expandable)
3. Diff view if updating existing configuration (shows what changed per prompt type)
4. "Publish to Production" button triggers backend `POST /api/triggers/{trigger_name}/publish`
5. Backend atomically updates `trigger_prompts` collection:
   - Sets `isActive: true` (enables new generation method)
   - Increments version number
   - Updates `model_config`, `data_config`, `prompts` (all 3 types)
   - Sets `published_at` timestamp and `published_by` user
6. Only one active config per trigger_name (deactivate previous if exists)
7. Save snapshot to `prompt_versions` collection for rollback capability
8. Success notification: "Published configuration v{version} for {trigger_name} (isActive=true)"
9. Published configuration immediately available: `isActive=true` triggers new method in Story 4.3
10. "View Published Configuration" link navigates to read-only view with all 3 prompts
11. At least one successful preview generation must exist before publish (validation check)
12. Meets FR25, FR27, FR28: publish with confirmation, versioning, and isActive activation

## Tasks / Subtasks

- [ ] Task 1: Create PublishConfirmationModal component (AC: 2, 4, 9, 11)
  - [ ] Create frontend/src/components/config/PublishConfirmationModal.tsx
  - [ ] Display trigger name and shared config (APIs, sections, models)
  - [ ] Display all 3 prompt previews with character counts
  - [ ] Add expandable sections for full prompt view
  - [ ] Show diff if updating existing configuration
  - [ ] Display version number and timestamp
  - [ ] Add "Publish to Production" button
- [ ] Task 2: Create publish endpoint (AC: 5, 6, 7, 8, 10)
  - [ ] Create POST /api/triggers/:id/publish endpoint
  - [ ] Save configuration with all 3 prompt types to MongoDB
  - [ ] Auto-increment version number
  - [ ] Mark configuration as is_active = true
  - [ ] Mark previous active config as is_active = false
  - [ ] Create audit log entry for publish action
  - [ ] Return published configuration with version
- [ ] Task 3: Implement diff algorithm for config comparison (AC: 3)
  - [ ] Create backend/app/services/diff_service.py
  - [ ] Compare shared configuration (APIs, sections, models)
  - [ ] Compare all 3 prompt templates
  - [ ] Return structured diff with added/removed/changed
  - [ ] Highlight changes per prompt type
- [ ] Task 4: Update ValidationModal to trigger PublishConfirmationModal (AC: 1, 5)
  - [ ] Update PublishButton component
  - [ ] After validation passes, show PublishConfirmationModal
  - [ ] Pass configuration data to confirmation modal
  - [ ] Handle publish button click in modal
- [ ] Task 5: Create published config view page (AC: 11)
  - [ ] Create frontend/src/app/config/[triggerId]/published/page.tsx
  - [ ] Display read-only view of active configuration
  - [ ] Show all 3 prompt types in tabs
  - [ ] Display version number, timestamp, published by
  - [ ] Add breadcrumb navigation
- [ ] Task 6: Write unit and integration tests
  - [ ] Test publish endpoint
  - [ ] Test version auto-increment
  - [ ] Test is_active flag update
  - [ ] Test diff algorithm
  - [ ] Test PublishConfirmationModal component
  - [ ] Test publish flow end-to-end

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 5.1 - Completion]

Before starting this story, ensure the following stories are complete (v2.0):
- Story 1.1 v2.0: Trigger Management (trigger_prompts collection)
- Story 1.2 v2.0: Manual Trigger Configuration (data_config fields)
- Story 2.1 v2.0: API Configuration (data sources setup)
- Story 2.2 v2.0: Section Selection (data_config.sections)
- Story 2.3 v2.0: Section Ordering (data_config.section_order)
- Story 3.1 v2.0: Model Configuration (model_config fields)
- Story 3.2 v2.0: Multi-Model Selection (model_config.models array)
- Story 4.1 v2.0: Prompt Template Editor (prompts structure)
- Story 4.2 v2.0: Prompt Preview (validation before publish)
- Story 4.3 v2.0: isActive Flag Integration (NEW workflow activation)
- Story 5.1 v2.0: Validation Modal (all 3 prompt types validated)

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Backend Module Structure]

**Backend files to create/modify** in `backend/app/`:
```
backend/app/
‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îî‚îÄ‚îÄ configuration.py               # Add publish endpoint (MODIFY)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ publish_service.py             # Publish logic (NEW)
‚îÇ   ‚îú‚îÄ‚îÄ diff_service.py                # Configuration diff algorithm (NEW)
‚îÇ   ‚îî‚îÄ‚îÄ audit_service.py               # Create audit log (NEW)
‚îî‚îÄ‚îÄ models/
    ‚îî‚îÄ‚îÄ audit_log.py                   # AuditLog model (existing from Story 1.2)
```

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ       ‚îú‚îÄ‚îÄ PublishConfirmationModal.tsx   # Confirmation modal (NEW)
‚îÇ       ‚îú‚îÄ‚îÄ PromptDiffView.tsx             # Diff display (NEW)
‚îÇ       ‚îú‚îÄ‚îÄ PublishButton.tsx              # Update to show confirmation (MODIFY)
‚îÇ       ‚îî‚îÄ‚îÄ ValidationModal.tsx            # Update to trigger confirmation (MODIFY)
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ       ‚îî‚îÄ‚îÄ [triggerId]/
‚îÇ           ‚îî‚îÄ‚îÄ published/
‚îÇ               ‚îî‚îÄ‚îÄ page.tsx               # Published config view (NEW)
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ publish.ts                         # TypeScript publish types (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Backend Stack**:
- **FastAPI**: Publish endpoint
- **MongoDB**: Save versioned configurations
- **Python difflib**: For text diff algorithm

**Frontend Stack**:
- **React-Bootstrap**: Modal, accordion, tabs
- **TypeScript**: Type-safe publish flow
- **React Diff Viewer** (optional): Library for side-by-side diff display

### Publish Service Specification

[Source: architecture.md - Epic 5 - Publishing APIs]

**File: backend/app/services/publish_service.py** (New)

Complete publish service with versioning:

```python
from typing import Dict, Optional
from datetime import datetime
from motor.motor_asyncio import AsyncIOMotorDatabase
import logging

logger = logging.getLogger(__name__)

class PublishService:
    """Service for publishing configurations to production"""

    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db

    async def publish_configuration(
        self,
        trigger_id: str,
        user_id: str
    ) -> Dict:
        """
        Publish configuration to production with all 3 prompt types

        Args:
            trigger_id: Trigger ID to publish
            user_id: User ID performing publish action

        Returns:
            Published configuration with version number
        """
        # Get draft configuration (most recent non-active)
        draft_config = await self.db.configurations.find_one(
            {"trigger_id": trigger_id, "is_active": False},
            sort=[("updated_at", -1)]
        )

        if not draft_config:
            raise ValueError("No draft configuration found to publish")

        # Deactivate current active configuration
        await self.db.configurations.update_many(
            {"trigger_id": trigger_id, "is_active": True},
            {"$set": {"is_active": False}}
        )

        # Get next version number
        last_version = await self.db.configurations.find_one(
            {"trigger_id": trigger_id},
            sort=[("version", -1)]
        )
        next_version = (last_version.get("version", 0) + 1) if last_version else 1

        # Create published configuration
        published_config = {
            **draft_config,
            "version": next_version,
            "is_active": True,
            "published_at": datetime.utcnow(),
            "published_by": user_id
        }

        # Remove _id to insert new document
        published_config.pop("_id", None)

        # Insert published configuration
        result = await self.db.configurations.insert_one(published_config)
        published_config["_id"] = str(result.inserted_id)

        # Create audit log entry
        await self._create_audit_log(trigger_id, user_id, next_version, published_config)

        logger.info(
            f"Published configuration for trigger {trigger_id} as version {next_version} "
            f"with 3 prompt types by user {user_id}"
        )

        return published_config

    async def _create_audit_log(
        self,
        trigger_id: str,
        user_id: str,
        version: int,
        config: Dict
    ):
        """Create audit log entry for publish action"""
        audit_entry = {
            "user_id": user_id,
            "action": "published",
            "trigger_id": trigger_id,
            "timestamp": datetime.utcnow(),
            "details": {
                "version": version,
                "data_sections": config.get("data_sections", []),
                "model_config": config.get("model_config", {}),
                "prompt_types": list(config.get("prompts", {}).keys())
            }
        }

        await self.db.audit_log.insert_one(audit_entry)

    async def get_active_configuration(self, trigger_id: str) -> Optional[Dict]:
        """Get currently active published configuration"""
        return await self.db.configurations.find_one(
            {"trigger_id": trigger_id, "is_active": True}
        )
```

**File: backend/app/services/diff_service.py** (New)

Configuration diff algorithm:

```python
from typing import Dict, List, Optional
import difflib
import logging

logger = logging.getLogger(__name__)

class DiffService:
    """Service for computing configuration diffs"""

    @staticmethod
    def compute_diff(old_config: Optional[Dict], new_config: Dict) -> Dict:
        """
        Compute diff between old and new configurations

        Args:
            old_config: Previous configuration (or None if first publish)
            new_config: New configuration to publish

        Returns:
            Structured diff with changes per section
        """
        if not old_config:
            return {
                "is_first_publish": True,
                "shared_changes": {},
                "prompt_changes": {}
            }

        diff_result = {
            "is_first_publish": False,
            "shared_changes": DiffService._diff_shared_config(old_config, new_config),
            "prompt_changes": DiffService._diff_prompts(old_config, new_config)
        }

        return diff_result

    @staticmethod
    def _diff_shared_config(old: Dict, new: Dict) -> Dict:
        """Diff shared configuration (APIs, sections, models)"""
        changes = {}

        # Data sections diff
        old_sections = set(old.get("data_sections", []))
        new_sections = set(new.get("data_sections", []))

        if old_sections != new_sections:
            changes["data_sections"] = {
                "added": list(new_sections - old_sections),
                "removed": list(old_sections - new_sections)
            }

        # Section order diff
        old_order = old.get("section_order", [])
        new_order = new.get("section_order", [])

        if old_order != new_order:
            changes["section_order"] = {
                "old": old_order,
                "new": new_order
            }

        # Model config diff
        old_models = old.get("model_config", {}).get("selected_models", [])
        new_models = new.get("model_config", {}).get("selected_models", [])

        if old_models != new_models:
            changes["selected_models"] = {
                "old": old_models,
                "new": new_models
            }

        return changes

    @staticmethod
    def _diff_prompts(old: Dict, new: Dict) -> Dict:
        """Diff all 3 prompt types"""
        old_prompts = old.get("prompts", {})
        new_prompts = new.get("prompts", {})

        prompt_changes = {}

        for prompt_type in ["paid", "unpaid", "crawler"]:
            old_template = old_prompts.get(prompt_type, {}).get("template", "")
            new_template = new_prompts.get(prompt_type, {}).get("template", "")

            if old_template != new_template:
                # Compute line-by-line diff
                diff = list(difflib.unified_diff(
                    old_template.splitlines(keepends=True),
                    new_template.splitlines(keepends=True),
                    lineterm=''
                ))

                prompt_changes[prompt_type] = {
                    "changed": True,
                    "old_length": len(old_template),
                    "new_length": len(new_template),
                    "diff": diff
                }
            else:
                prompt_changes[prompt_type] = {
                    "changed": False
                }

        return prompt_changes
```

**File: backend/app/routers/configuration.py** (Update)

Add publish endpoint:

```python
from fastapi import APIRouter, HTTPException, Depends
from ..database import get_database
from ..services.publish_service import PublishService
from ..services.diff_service import DiffService
import logging

router = APIRouter(prefix="/api/triggers/{trigger_id}", tags=["configuration"])
logger = logging.getLogger(__name__)

# ... (existing endpoints)

@router.post("/publish")
async def publish_configuration(
    trigger_id: str,
    db = Depends(get_database),
    # user_id: str = Depends(get_current_user)  # TODO: Add auth in Story 1.1
):
    """
    Publish configuration to production with all 3 prompt types.
    Creates new version, marks as active, deactivates previous version.
    """
    service = PublishService(db)
    user_id = "system"  # TODO: Get from auth

    try:
        published_config = await service.publish_configuration(trigger_id, user_id)

        return {
            "success": True,
            "configuration": published_config,
            "version": published_config["version"],
            "timestamp": published_config["published_at"].isoformat()
        }
    except Exception as e:
        logger.error(f"Failed to publish configuration: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/publish/preview")
async def preview_publish(
    trigger_id: str,
    db = Depends(get_database)
):
    """
    Preview what will be published (for confirmation modal).
    Returns draft config and diff from active config.
    """
    service = PublishService(db)
    diff_service = DiffService()

    # Get draft configuration
    draft_config = await db.configurations.find_one(
        {"trigger_id": trigger_id, "is_active": False},
        sort=[("updated_at", -1)]
    )

    if not draft_config:
        raise HTTPException(status_code=404, detail="No draft configuration found")

    # Get active configuration for diff
    active_config = await service.get_active_configuration(trigger_id)

    # Compute diff
    diff = diff_service.compute_diff(active_config, draft_config)

    return {
        "success": True,
        "draft_config": draft_config,
        "active_config": active_config,
        "diff": diff
    }
```

### Frontend Component Specifications

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/components/config/PublishConfirmationModal.tsx** (New)

Confirmation modal showing all 3 prompt types:

```typescript
'use client';

import { Modal, Button, Alert, Accordion, Badge, Row, Col } from 'react-bootstrap';
import { useState } from 'react';

interface PromptConfig {
  template: string;
  version_history: any[];
  last_test_generation: any;
}

interface ConfigurationPreview {
  trigger_id: string;
  trigger_name: string;
  data_sections: string[];
  section_order: string[];
  model_config: {
    selected_models: string[];
    temperature: number;
    max_tokens: number;
  };
  prompts: {
    paid: PromptConfig;
    unpaid: PromptConfig;
    crawler: PromptConfig;
  };
}

interface Diff {
  is_first_publish: boolean;
  shared_changes: any;
  prompt_changes: Record<string, any>;
}

interface PublishConfirmationModalProps {
  show: boolean;
  onHide: () => void;
  onConfirmPublish: () => Promise<void>;
  config: ConfigurationPreview | null;
  diff: Diff | null;
  loading: boolean;
}

export default function PublishConfirmationModal({
  show,
  onHide,
  onConfirmPublish,
  config,
  diff,
  loading
}: PublishConfirmationModalProps) {
  const [expandedPrompt, setExpandedPrompt] = useState<string | null>(null);

  if (!config) return null;

  const promptTypeEmoji = {
    paid: 'üí∞',
    unpaid: 'üÜì',
    crawler: 'üï∑Ô∏è'
  };

  const promptTypeColor = {
    paid: '#0d6efd',
    unpaid: '#198754',
    crawler: '#fd7e14'
  };

  const truncatePrompt = (template: string, maxLength: number = 200) => {
    if (template.length <= maxLength) return template;
    return template.substring(0, maxLength) + '...';
  };

  const hasChanges = diff && !diff.is_first_publish && (
    Object.keys(diff.shared_changes).length > 0 ||
    Object.values(diff.prompt_changes).some((change: any) => change.changed)
  );

  return (
    <Modal show={show} onHide={onHide} size="xl">
      <Modal.Header closeButton>
        <Modal.Title>
          {diff?.is_first_publish ? 'üì¢ Publish Configuration' : 'üìù Update Configuration'}
        </Modal.Title>
      </Modal.Header>
      <Modal.Body style={{ maxHeight: '70vh', overflowY: 'auto' }}>
        <Alert variant={diff?.is_first_publish ? 'success' : 'warning'}>
          {diff?.is_first_publish ? (
            <>
              <strong>First Publish:</strong> This configuration will be published to production for the first time.
            </>
          ) : (
            <>
              <strong>Configuration Update:</strong> This will replace the current production configuration.
              {hasChanges && ' Changes are highlighted below.'}
            </>
          )}
        </Alert>

        {/* Trigger Info */}
        <h5 className="mb-3">Trigger: {config.trigger_name || config.trigger_id}</h5>

        {/* Shared Configuration */}
        <div className="mb-4">
          <h6 className="text-muted">Shared Configuration (Applies to All Prompt Types)</h6>
          <Row className="mt-2">
            <Col md={4}>
              <strong>Data Sections:</strong>
              <div>{config.data_sections.length} sections selected</div>
              <small className="text-muted">{config.data_sections.join(', ')}</small>
            </Col>
            <Col md={4}>
              <strong>Section Order:</strong>
              <div>{config.section_order.length} sections ordered</div>
              <small className="text-muted">{config.section_order.join(' ‚Üí ')}</small>
            </Col>
            <Col md={4}>
              <strong>Models:</strong>
              <div>{config.model_config.selected_models.length} models selected</div>
              <small className="text-muted">{config.model_config.selected_models.join(', ')}</small>
            </Col>
          </Row>
        </div>

        {/* Diff Summary */}
        {hasChanges && (
          <Alert variant="info" className="mb-4">
            <strong>Changes Summary:</strong>
            <ul className="mb-0 mt-2">
              {diff.shared_changes.data_sections && (
                <li>Data sections: {diff.shared_changes.data_sections.added?.length || 0} added, {diff.shared_changes.data_sections.removed?.length || 0} removed</li>
              )}
              {diff.shared_changes.section_order && <li>Section order changed</li>}
              {diff.shared_changes.selected_models && <li>Model selection changed</li>}
              {Object.entries(diff.prompt_changes).map(([type, change]: [string, any]) =>
                change.changed && <li key={type}>{type.charAt(0).toUpperCase() + type.slice(1)} prompt modified ({change.new_length} characters)</li>
              )}
            </ul>
          </Alert>
        )}

        {/* Prompt Previews */}
        <h6 className="text-muted mb-3">Prompt Previews</h6>
        <Accordion>
          {Object.entries(config.prompts).map(([promptType, promptConfig]) => {
            const changed = diff?.prompt_changes[promptType]?.changed;

            return (
              <Accordion.Item eventKey={promptType} key={promptType}>
                <Accordion.Header>
                  <div className="d-flex align-items-center gap-2 w-100">
                    <span style={{ color: promptTypeColor[promptType as keyof typeof promptTypeColor] }}>
                      {promptTypeEmoji[promptType as keyof typeof promptTypeEmoji]} {promptType.charAt(0).toUpperCase() + promptType.slice(1)} Prompt
                    </span>
                    {changed && <Badge bg="warning" className="ms-2">Modified</Badge>}
                    <Badge bg="secondary" className="ms-auto">{promptConfig.template.length} characters</Badge>
                  </div>
                </Accordion.Header>
                <Accordion.Body>
                  {expandedPrompt === promptType ? (
                    <>
                      <pre className="bg-light p-3" style={{ whiteSpace: 'pre-wrap', maxHeight: '300px', overflowY: 'auto' }}>
                        {promptConfig.template}
                      </pre>
                      <Button
                        variant="link"
                        size="sm"
                        onClick={() => setExpandedPrompt(null)}
                      >
                        Show Less
                      </Button>
                    </>
                  ) : (
                    <>
                      <div className="bg-light p-3 mb-2" style={{ whiteSpace: 'pre-wrap' }}>
                        {truncatePrompt(promptConfig.template)}
                      </div>
                      <Button
                        variant="link"
                        size="sm"
                        onClick={() => setExpandedPrompt(promptType)}
                      >
                        Show Full Prompt
                      </Button>
                    </>
                  )}

                  {promptConfig.last_test_generation && (
                    <div className="mt-2 text-muted">
                      <small>Last tested: {promptConfig.last_test_generation.timestamp}</small>
                    </div>
                  )}
                </Accordion.Body>
              </Accordion.Item>
            );
          })}
        </Accordion>

        <Alert variant="warning" className="mt-4">
          <strong>‚ö†Ô∏è Important:</strong> This configuration will be immediately available to the production news generation system for all 3 prompt types (paid, unpaid, crawler).
        </Alert>
      </Modal.Body>
      <Modal.Footer>
        <Button variant="secondary" onClick={onHide} disabled={loading}>
          Cancel
        </Button>
        <Button
          variant="success"
          onClick={onConfirmPublish}
          disabled={loading}
        >
          {loading ? 'Publishing...' : 'Publish to Production'}
        </Button>
      </Modal.Footer>
    </Modal>
  );
}
```

**File: frontend/src/components/config/PublishButton.tsx** (Update)

Update to show confirmation modal after validation:

```typescript
'use client';

import { useState } from 'react';
import { Button, Toast } from 'react-bootstrap';
import ValidationModal from './ValidationModal';
import PublishConfirmationModal from './PublishConfirmationModal';

interface PublishButtonProps {
  triggerId: string;
  triggerName: string;
  onPublishSuccess: () => void;
}

export default function PublishButton({ triggerId, triggerName, onPublishSuccess }: PublishButtonProps) {
  const [showValidation, setShowValidation] = useState(false);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [validation, setValidation] = useState(null);
  const [publishPreview, setPublishPreview] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const handlePublishClick = async () => {
    try {
      setLoading(true);
      setError(null);

      // Step 1: Validate configuration
      const response = await fetch(`/api/triggers/${triggerId}/config/validate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!response.ok) {
        throw new Error('Validation failed');
      }

      const data = await response.json();
      setValidation(data.validation);
      setShowValidation(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Validation failed');
    } finally {
      setLoading(false);
    }
  };

  const handleConfirmPublishFromValidation = async () => {
    try {
      setLoading(true);
      setError(null);

      // Step 2: Get publish preview (draft config + diff)
      const response = await fetch(`/api/triggers/${triggerId}/publish/preview`);

      if (!response.ok) {
        throw new Error('Failed to load publish preview');
      }

      const data = await response.json();
      setPublishPreview({
        config: { ...data.draft_config, trigger_name: triggerName },
        diff: data.diff
      });

      setShowValidation(false);
      setShowConfirmation(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load preview');
    } finally {
      setLoading(false);
    }
  };

  const handleFinalPublish = async () => {
    try {
      setLoading(true);
      setError(null);

      // Step 3: Publish to production
      const response = await fetch(`/api/triggers/${triggerId}/publish`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!response.ok) {
        throw new Error('Failed to publish configuration');
      }

      const data = await response.json();

      setSuccessMessage(
        `‚úÖ Published successfully with 3 prompt types as Version ${data.version}`
      );
      setShowConfirmation(false);
      onPublishSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to publish');
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Button
        variant="success"
        size="lg"
        onClick={handlePublishClick}
        disabled={loading}
      >
        {loading ? 'Processing...' : 'Publish Configuration'}
      </Button>

      {error && (
        <div className="alert alert-danger mt-3">{error}</div>
      )}

      {successMessage && (
        <Toast
          show={!!successMessage}
          onClose={() => setSuccessMessage(null)}
          delay={5000}
          autohide
          className="position-fixed top-0 end-0 m-3"
        >
          <Toast.Header>
            <strong className="me-auto">Success</strong>
          </Toast.Header>
          <Toast.Body>{successMessage}</Toast.Body>
        </Toast>
      )}

      <ValidationModal
        show={showValidation}
        onHide={() => setShowValidation(false)}
        validation={validation}
        onConfirmPublish={handleConfirmPublishFromValidation}
        loading={loading}
      />

      <PublishConfirmationModal
        show={showConfirmation}
        onHide={() => setShowConfirmation(false)}
        onConfirmPublish={handleFinalPublish}
        config={publishPreview?.config || null}
        diff={publishPreview?.diff || null}
        loading={loading}
      />
    </>
  );
}
```

### Implementation Notes

[Source: PRD - Epic 5: Configuration Publishing & Production Integration]

**Important Design Decisions**:

1. **3-Step Publish Flow**: Validation ‚Üí Confirmation ‚Üí Publish. User sees exactly what will be published before final confirmation.

2. **All 3 Prompts in Confirmation**: Modal displays all 3 prompt types (paid, unpaid, crawler) with previews and character counts.

3. **Diff View**: Shows what changed from active config if updating. Highlights changes in shared config and per-prompt type.

4. **Version Auto-Increment**: Backend automatically assigns next version number. Versions never reused.

5. **Single Active Config**: Only one configuration marked is_active per trigger. Publishing deactivates previous active config.

6. **Immediate Availability**: Published configuration immediately accessible via active-config API (Story 5.5).

7. **Audit Trail**: Every publish action logged to audit_log collection with version and details.

8. **Expandable Prompts**: Users can expand accordion to view full prompt in confirmation modal.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 5.2**:

**Unit Tests** (backend/tests/test_publish_service.py):

```python
import pytest
from app.services.publish_service import PublishService
from datetime import datetime

@pytest.mark.asyncio
async def test_publish_configuration_creates_version(db):
    """Test publishing creates new version"""
    # Create draft config
    await db.configurations.insert_one({
        "_id": "config_001",
        "trigger_id": "trigger_001",
        "data_sections": ["1", "2"],
        "section_order": ["1", "2"],
        "model_config": {"selected_models": ["gpt-4"]},
        "prompts": {
            "paid": {"template": "test"},
            "unpaid": {"template": "test"},
            "crawler": {"template": "test"}
        },
        "is_active": False,
        "version": 0,
        "updated_at": datetime.utcnow()
    })

    service = PublishService(db)
    result = await service.publish_configuration("trigger_001", "user_001")

    assert result["version"] == 1
    assert result["is_active"] is True
    assert result["published_by"] == "user_001"

@pytest.mark.asyncio
async def test_publish_deactivates_previous_version(db):
    """Test publishing deactivates previous active config"""
    # Create active config
    await db.configurations.insert_one({
        "_id": "config_001",
        "trigger_id": "trigger_001",
        "version": 1,
        "is_active": True,
        "prompts": {"paid": {"template": "old"}}
    })

    # Create draft config
    await db.configurations.insert_one({
        "_id": "config_002",
        "trigger_id": "trigger_001",
        "version": 1,
        "is_active": False,
        "prompts": {"paid": {"template": "new"}},
        "updated_at": datetime.utcnow()
    })

    service = PublishService(db)
    await service.publish_configuration("trigger_001", "user_001")

    # Check old config deactivated
    old_config = await db.configurations.find_one({"_id": "config_001"})
    assert old_config["is_active"] is False

    # Check new config active
    new_config = await db.configurations.find_one(
        {"trigger_id": "trigger_001", "is_active": True}
    )
    assert new_config["version"] == 2

@pytest.mark.asyncio
async def test_publish_creates_audit_log(db):
    """Test publishing creates audit log entry"""
    await db.configurations.insert_one({
        "_id": "config_001",
        "trigger_id": "trigger_001",
        "data_sections": ["1"],
        "is_active": False,
        "prompts": {},
        "updated_at": datetime.utcnow()
    })

    service = PublishService(db)
    await service.publish_configuration("trigger_001", "user_001")

    # Check audit log created
    audit_log = await db.audit_log.find_one({"trigger_id": "trigger_001"})
    assert audit_log is not None
    assert audit_log["action"] == "published"
    assert audit_log["user_id"] == "user_001"
```

**Frontend Tests** (frontend/__tests__/components/config/):

```typescript
// PublishConfirmationModal.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import PublishConfirmationModal from '@/components/config/PublishConfirmationModal';

describe('PublishConfirmationModal Component', () => {
  const mockConfig = {
    trigger_id: 'trigger_001',
    trigger_name: 'Earnings Alert',
    data_sections: ['1', '2', '3'],
    section_order: ['1', '2', '3'],
    model_config: {
      selected_models: ['gpt-4'],
      temperature: 0.7,
      max_tokens: 1000
    },
    prompts: {
      paid: {
        template: 'Paid prompt template here',
        version_history: [],
        last_test_generation: { timestamp: '2025-10-29' }
      },
      unpaid: {
        template: 'Unpaid prompt template here',
        version_history: [],
        last_test_generation: { timestamp: '2025-10-29' }
      },
      crawler: {
        template: 'Crawler prompt template here',
        version_history: [],
        last_test_generation: { timestamp: '2025-10-29' }
      }
    }
  };

  const mockDiff = {
    is_first_publish: false,
    shared_changes: {},
    prompt_changes: {
      paid: { changed: true, new_length: 100 },
      unpaid: { changed: false },
      crawler: { changed: false }
    }
  };

  test('renders trigger name and shared config', () => {
    render(
      <PublishConfirmationModal
        show={true}
        onHide={jest.fn()}
        onConfirmPublish={jest.fn()}
        config={mockConfig}
        diff={mockDiff}
        loading={false}
      />
    );

    expect(screen.getByText(/Trigger: Earnings Alert/)).toBeInTheDocument();
    expect(screen.getByText(/3 sections selected/)).toBeInTheDocument();
    expect(screen.getByText(/1 models selected/)).toBeInTheDocument();
  });

  test('displays all 3 prompt type previews', () => {
    render(
      <PublishConfirmationModal
        show={true}
        onHide={jest.fn()}
        onConfirmPublish={jest.fn()}
        config={mockConfig}
        diff={mockDiff}
        loading={false}
      />
    );

    expect(screen.getByText(/üí∞ Paid Prompt/)).toBeInTheDocument();
    expect(screen.getByText(/üÜì Unpaid Prompt/)).toBeInTheDocument();
    expect(screen.getByText(/üï∑Ô∏è Crawler Prompt/)).toBeInTheDocument();
  });

  test('shows modified badge for changed prompts', () => {
    render(
      <PublishConfirmationModal
        show={true}
        onHide={jest.fn()}
        onConfirmPublish={jest.fn()}
        config={mockConfig}
        diff={mockDiff}
        loading={false}
      />
    );

    const modifiedBadges = screen.getAllByText('Modified');
    expect(modifiedBadges.length).toBe(1); // Only paid prompt changed
  });

  test('publish button triggers publish action', async () => {
    const mockPublish = jest.fn();

    render(
      <PublishConfirmationModal
        show={true}
        onHide={jest.fn()}
        onConfirmPublish={mockPublish}
        config={mockConfig}
        diff={mockDiff}
        loading={false}
      />
    );

    const publishButton = screen.getByText('Publish to Production');
    fireEvent.click(publishButton);

    expect(mockPublish).toHaveBeenCalled();
  });
});
```

**Manual Verification**:
1. Validation passes and shows confirmation modal
2. Confirmation modal displays trigger name
3. Shared config shown: APIs, sections, models
4. All 3 prompt previews displayed with character counts
5. Expandable accordion shows full prompts
6. Diff summary shows what changed
7. Modified badge appears on changed prompts
8. "Publish to Production" button triggers publish
9. Success notification shows version number
10. Published config immediately accessible
11. "View Published Configuration" link works
12. Audit log entry created
13. No console errors

**Coverage Target**: 70%+ for publish logic

## News CMS Workflow Updates

[Source: News CMS Workflow Feature - Story 4.3 Integration]

This story implements the CRITICAL publishing mechanism that activates the NEW workflow for news generation. The publish action sets `isActive=true` in the `trigger_prompts` collection, which is the flag checked by Story 4.3 to determine whether to use the NEW or OLD generation method.

### Key Workflow Integration Points

1. **CRITICAL: Sets isActive=true on Publish**
   - When "Publish to Production" is confirmed, the backend atomically updates the `trigger_prompts` collection
   - Sets `isActive: true` on the published configuration
   - This flag is THE trigger for Story 4.3 to switch from OLD to NEW workflow
   - Without this flag set to true, the system continues using the legacy generation method

2. **Atomic Update to trigger_prompts Collection**
   - Single database transaction updates the entire configuration
   - Includes: `data_config`, `model_config`, `prompts` (paid/unpaid/crawler), and `isActive: true`
   - Ensures consistency - no partial updates that could break generation
   - Deactivates previous configuration (sets old `isActive: false`) before activating new one
   - Only one active configuration per trigger at any time

3. **Saves to prompt_versions for Rollback Capability**
   - Every publish creates a snapshot in `prompt_versions` collection
   - Enables Story 5.4 (Rollback) to restore previous configurations
   - Maintains complete audit trail of all published versions
   - Includes timestamp, user, and full configuration state

4. **Validation: At Least One Successful Preview Required Before Publish**
   - Backend enforces: cannot publish without successful preview generation
   - Prevents publishing untested prompts to production
   - Links to Story 4.2 (Prompt Preview) - must have `last_test_generation` for all 3 prompt types
   - Validation check occurs before showing confirmation modal

5. **Published Configuration Structure**
   - Complete configuration published to `trigger_prompts` collection includes:
     - `data_config`: API endpoints, sections array, section_order
     - `model_config`: selected models, temperature, max_tokens, provider settings
     - `prompts`: All 3 prompt types (paid, unpaid, crawler) with templates
     - `isActive: true`: THE critical flag that activates NEW workflow
     - `version`: Auto-incremented version number
     - `published_at`: Timestamp of publish action
     - `published_by`: User who performed publish

### Workflow Activation Flow

```
Story 5.1 (Validation) ‚Üí Story 5.2 (Publish with isActive=true) ‚Üí Story 4.3 (Check isActive flag)
                                                                        ‚Üì
                                                            If isActive=true: Use NEW workflow
                                                            If isActive=false: Use OLD workflow
```

### Backend Implementation Notes

The publish endpoint (`POST /api/triggers/{trigger_name}/publish`) must:
- Validate that draft configuration exists
- Check that all 3 prompts have successful preview generations
- Deactivate current active configuration (if exists)
- Create new configuration with `isActive: true`
- Auto-increment version number
- Save snapshot to `prompt_versions`
- Create audit log entry
- Return published configuration with version number

This ensures that the moment publish completes, the NEW workflow is immediately active for production news generation.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 5 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context, publish service with versioning, diff algorithm, 3-prompt confirmation modal, and testing standards | Bob (SM) |
| 2025-10-30 | 2.0 | Aligned with News CMS Workflow Feature requirements: Added Version 2.0 field, updated prerequisites to reference all updated stories through 4.3 v2.0, updated endpoint to POST /api/triggers/{trigger_name}/publish, added comprehensive News CMS Workflow Updates section documenting critical isActive=true flag integration, atomic updates to trigger_prompts collection, prompt_versions snapshot for rollback, validation requirements, and complete published configuration structure | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
