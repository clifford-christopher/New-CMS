# Story 3.1: Section Reordering Interface (Shared Across All Prompt Types)

## Status

✅ **Implemented** - Updated for Data Configuration Workflow v2.3 (November 2025)

## Story

**As a** content manager,
**I want** to reorder ALREADY SELECTED data sections via drag-and-drop in the Section Management tab,
**so that** I can control the sequence in which data appears in all prompt types (paid, unpaid, crawler).

**Critical Change (v2.3)**: This story now focuses ONLY on ORDERING. Section SELECTION happens in Story 2.5 (Data Configuration tab).

**Workflow Context**:
1. **Data Configuration Tab** (Story 2.5): User selects sections with checkboxes → Clicks "Use This Data"
2. **Section Management Tab** (This Story): Receives selected sections → User reorders them with drag-and-drop

## Acceptance Criteria

**Section Display by Data Mode**:

1. **OLD Mode**:
   - Displays single section: `{id: 'old_data', name: 'OLD Data (Complete)', source: 'old'}`
   - Drag handle disabled (no reordering needed)
   - Blue "OLD" source badge
   - Info message: "No reordering needed. Proceed to configure prompts."

2. **NEW Mode**:
   - Displays ONLY the sections selected in Data Configuration (not all 14)
   - Example: If user selected sections 1, 3, 5, 9 → shows 4 draggable items
   - Each section: Drag handle | Section number badge | Section name | Green "NEW" badge
   - Drag-and-drop enabled

3. **OLD_NEW Mode**:
   - Displays OLD section + selected NEW sections in ONE combined draggable list
   - Initial order: OLD section first, then NEW sections
   - Example display:
     ```
     [1] OLD Data (Complete) [blue badge] [drag handle]
     [2] Section 1: Company Info [green badge] [drag handle]
     [3] Section 5: Cash Flow [green badge] [drag handle]
     ```
   - **ALL sections draggable** - user can move OLD section anywhere in the list
   - Can achieve any arrangement (e.g., Section 1 → OLD → Section 5)

**Drag-and-Drop Implementation**:

4. Drag-and-drop functionality using React Beautiful DnD or React DnD library
5. Section order changes immediately reflected in UI without page reload
6. Visual feedback during drag: semi-transparent item, placeholder shows drop target
7. Hover state on drag handles
8. Keyboard accessibility support (Arrow keys + Space)

**Data Persistence & Preview**:

9. "Preview Data Structure" button shows JSON modal with final ordered structure
10. Section order saved to React state immediately on reorder
11. State passed to Prompt Engineering step for placeholder generation
12. localStorage key: `sectionOrder_{triggerId}` stores final ordered section IDs
13. "Reset Order" button resets to default order (OLD first if OLD_NEW, otherwise selection order)

**Validation & Error Handling**:

14. If no sections available (NEW/OLD_NEW with no selections), show warning alert
15. Warning message: "No sections selected. Go back to Data Configuration."
16. Meets FR11 (ordering selected sections) and FR12 (preview with reorder)

## Tasks / Subtasks

- [ ] Task 1: Create SectionManagement component (AC: 1, 2, 9)
  - [ ] Create frontend/src/components/config/SectionManagement.tsx
  - [ ] Display sections in current order from DataContext
  - [ ] Integrate react-beautiful-dnd for drag-and-drop
  - [ ] Add visual feedback for drag operations
- [ ] Task 2: Implement numbered input alternative (AC: 3)
  - [ ] Add position input for each section
  - [ ] Validate position range (1 to section count)
  - [ ] Handle position change with instant reordering
  - [ ] Prevent invalid position values
- [ ] Task 3: Implement section order updates (AC: 4, 6)
  - [ ] Update section_order in DataContext immediately
  - [ ] Call POST /api/triggers/:id/config/section-order endpoint
  - [ ] Auto-save changes to MongoDB
  - [ ] Handle API errors gracefully
- [ ] Task 4: Update preview functionality (AC: 5, 7)
  - [ ] Update PreviewModal to respect new section order
  - [ ] Show sections in reordered sequence
  - [ ] Display preview updates automatically on order change
  - [ ] Add "Preview with Current Order" button
- [ ] Task 5: Implement undo/redo (AC: 8)
  - [ ] Track previous section order state
  - [ ] Add "Undo" button to revert last reorder
  - [ ] Add "Redo" button to re-apply undone change
  - [ ] Single-level undo/redo sufficient for MVP
- [ ] Task 6: Create backend endpoint for section order (AC: 6)
  - [ ] Create POST /api/triggers/:id/config/section-order endpoint
  - [ ] Update section_order in Configuration document
  - [ ] Return updated configuration
- [ ] Task 7: Write unit and integration tests
  - [ ] Test SectionManagement drag-and-drop
  - [ ] Test numbered input reordering
  - [ ] Test section order persistence
  - [ ] Test undo/redo functionality
  - [ ] Test backend endpoint

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 2.5 - Completion]

Before starting this story, ensure Story 2.5 is complete:
- StructuredDataDisplay component shows parsed sections
- DataContext provides structured data
- Section data available in React Context
- Configuration Workspace displays structured sections

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── config/
│       ├── SectionManagement.tsx       # Section reordering panel (NEW)
│       ├── SectionOrderItem.tsx        # Individual draggable section (NEW)
│       ├── PreviewModal.tsx            # Update to respect section order (MODIFY)
│       └── StructuredDataDisplay.tsx   # May update order display (MODIFY)
├── contexts/
│   └── DataContext.tsx                 # Add section order state (MODIFY)
└── types/
    └── configuration.ts                # TypeScript types (existing)
```

**Backend files to create/modify** in `backend/app/`:
```
backend/app/
├── routers/
│   └── configuration.py                # Add section-order endpoint (MODIFY)
└── services/
    └── configuration_service.py        # Add update_section_order method (MODIFY)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **React Beautiful DnD**: Drag-and-drop library (install: `npm install react-beautiful-dnd @types/react-beautiful-dnd`)
- **React-Bootstrap**: For panels, buttons, cards
- **React Context API**: DataContext for section order state
- **TypeScript**: Type safety for section order operations

**Alternative Library**:
- **React DnD**: More flexible but more complex API
- **Bootstrap Sortable**: jQuery-based (avoid if possible due to React compatibility)

**Decision**: Use **react-beautiful-dnd** for React-friendly API and excellent touch support.

### Multi-Prompt Type Architecture

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Shared vs. Separate Components**:
- **Section Management**: SHARED across all prompt types (configured once, applies to all)
- **Section Order**: Single configuration applies to paid, unpaid, and crawler prompts
- **Data Structure**: All prompt types receive data in the same section order

**Why Shared?**:
- Data consistency across prompt types
- Simplifies UX (one section order, not three)
- Reduces cognitive load for users
- Section order is a data configuration concern, not a prompt-specific concern

### React Context Updates for Section Order

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/DataContext.tsx** (Update)

Add section order state management:

```typescript
'use client';

import React, { createContext, useContext, useState, ReactNode } from 'react';

interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface StructuredData {
  sections: Record<string, SectionData>;
  metadata: {
    total_sections: number;
    parsed_at: string;
  };
}

interface DataContextType {
  rawData: Record<string, any> | null;
  structuredData: StructuredData | null;
  dataStatus: Record<string, any> | null;
  stockId: string | null;
  sectionOrder: string[];                          // NEW: Section order state
  previousSectionOrder: string[] | null;           // NEW: For undo support
  setRawData: (data: Record<string, any> | null) => void;
  setStructuredData: (data: StructuredData | null) => void;
  setDataStatus: (status: Record<string, any> | null) => void;
  setStockId: (id: string | null) => void;
  setSectionOrder: (order: string[]) => void;      // NEW: Update section order
  undoSectionOrder: () => void;                    // NEW: Undo reorder
  clearData: () => void;
}

const DataContext = createContext<DataContextType | undefined>(undefined);

export function DataProvider({ children }: { children: ReactNode }) {
  const [rawData, setRawData] = useState<Record<string, any> | null>(null);
  const [structuredData, setStructuredData] = useState<StructuredData | null>(null);
  const [dataStatus, setDataStatus] = useState<Record<string, any> | null>(null);
  const [stockId, setStockId] = useState<string | null>(null);
  const [sectionOrder, setSectionOrderState] = useState<string[]>([]);
  const [previousSectionOrder, setPreviousSectionOrder] = useState<string[] | null>(null);

  const setSectionOrder = (newOrder: string[]) => {
    setPreviousSectionOrder(sectionOrder); // Save current order for undo
    setSectionOrderState(newOrder);
  };

  const undoSectionOrder = () => {
    if (previousSectionOrder) {
      setSectionOrderState(previousSectionOrder);
      setPreviousSectionOrder(null);
    }
  };

  const clearData = () => {
    setRawData(null);
    setStructuredData(null);
    setDataStatus(null);
    setStockId(null);
    setSectionOrderState([]);
    setPreviousSectionOrder(null);
  };

  const value: DataContextType = {
    rawData,
    structuredData,
    dataStatus,
    stockId,
    sectionOrder,
    previousSectionOrder,
    setRawData,
    setStructuredData,
    setDataStatus,
    setStockId,
    setSectionOrder,
    undoSectionOrder,
    clearData,
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
}

export function useData() {
  const context = useContext(DataContext);
  if (context === undefined) {
    throw new Error('useData must be used within a DataProvider');
  }
  return context;
}
```

### Frontend Component Specifications

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/components/config/SectionManagement.tsx** (New)

Complete section management component with drag-and-drop:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Card, Button, Alert, Row, Col } from 'react-bootstrap';
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { useData } from '@/contexts/DataContext';
import SectionOrderItem from './SectionOrderItem';

interface SectionManagementProps {
  triggerId: string;
}

export default function SectionManagement({ triggerId }: SectionManagementProps) {
  const {
    structuredData,
    sectionOrder,
    previousSectionOrder,
    setSectionOrder,
    undoSectionOrder
  } = useData();

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showPreview, setShowPreview] = useState(false);

  // Initialize section order from structured data
  useEffect(() => {
    if (structuredData && sectionOrder.length === 0) {
      const initialOrder = Object.keys(structuredData.sections).sort((a, b) =>
        parseInt(a) - parseInt(b)
      );
      setSectionOrder(initialOrder);
    }
  }, [structuredData, sectionOrder, setSectionOrder]);

  const handleDragEnd = async (result: DropResult) => {
    if (!result.destination) return;

    const newOrder = Array.from(sectionOrder);
    const [removed] = newOrder.splice(result.source.index, 1);
    newOrder.splice(result.destination.index, 0, removed);

    setSectionOrder(newOrder);
    await saveSectionOrder(newOrder);
  };

  const handlePositionChange = async (sectionId: string, newPosition: number) => {
    const currentIndex = sectionOrder.indexOf(sectionId);
    if (currentIndex === -1 || newPosition < 1 || newPosition > sectionOrder.length) {
      setError('Invalid position value');
      return;
    }

    const newOrder = Array.from(sectionOrder);
    newOrder.splice(currentIndex, 1);
    newOrder.splice(newPosition - 1, 0, sectionId);

    setSectionOrder(newOrder);
    await saveSectionOrder(newOrder);
  };

  const saveSectionOrder = async (order: string[]) => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch(`/api/triggers/${triggerId}/config/section-order`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ section_order: order })
      });

      if (!response.ok) {
        throw new Error('Failed to save section order');
      }

      // Success - order already updated in context
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save section order');
      // Revert on error
      if (previousSectionOrder) {
        setSectionOrder(previousSectionOrder);
      }
    } finally {
      setLoading(false);
    }
  };

  const handleUndo = () => {
    undoSectionOrder();
    if (previousSectionOrder) {
      saveSectionOrder(previousSectionOrder);
    }
  };

  if (!structuredData || sectionOrder.length === 0) {
    return (
      <Card className="mt-4">
        <Card.Header>
          <h5>Section Management</h5>
        </Card.Header>
        <Card.Body>
          <Alert variant="info">
            Parse data first to enable section reordering.
          </Alert>
        </Card.Body>
      </Card>
    );
  }

  return (
    <Card className="mt-4">
      <Card.Header className="d-flex justify-content-between align-items-center">
        <div>
          <h5 className="mb-0">Section Management</h5>
          <small className="text-muted">
            Drag sections to reorder or use numbered input. Order applies to all prompt types.
          </small>
        </div>
        <div className="d-flex gap-2">
          <Button
            variant="outline-secondary"
            size="sm"
            onClick={handleUndo}
            disabled={!previousSectionOrder || loading}
          >
            Undo
          </Button>
          <Button
            variant="primary"
            size="sm"
            onClick={() => setShowPreview(true)}
          >
            Preview Data Structure
          </Button>
        </div>
      </Card.Header>
      <Card.Body>
        {error && <Alert variant="danger" dismissible onClose={() => setError(null)}>{error}</Alert>}

        {loading && (
          <Alert variant="info">Saving section order...</Alert>
        )}

        <DragDropContext onDragEnd={handleDragEnd}>
          <Droppable droppableId="section-list">
            {(provided, snapshot) => (
              <div
                ref={provided.innerRef}
                {...provided.droppableProps}
                className={`section-list ${snapshot.isDraggingOver ? 'dragging-over' : ''}`}
              >
                {sectionOrder.map((sectionId, index) => {
                  const section = structuredData.sections[sectionId];
                  if (!section) return null;

                  return (
                    <Draggable
                      key={sectionId}
                      draggableId={sectionId}
                      index={index}
                    >
                      {(provided, snapshot) => (
                        <SectionOrderItem
                          sectionId={sectionId}
                          section={section}
                          position={index + 1}
                          totalSections={sectionOrder.length}
                          provided={provided}
                          isDragging={snapshot.isDragging}
                          onPositionChange={handlePositionChange}
                        />
                      )}
                    </Draggable>
                  );
                })}
                {provided.placeholder}
              </div>
            )}
          </Droppable>
        </DragDropContext>
      </Card.Body>

      <style jsx>{`
        .section-list {
          transition: background-color 0.2s ease;
        }
        .section-list.dragging-over {
          background-color: #f0f8ff;
        }
      `}</style>
    </Card>
  );
}
```

**File: frontend/src/components/config/SectionOrderItem.tsx** (New)

Individual draggable section item:

```typescript
'use client';

import { useState } from 'react';
import { Card, Form, Badge } from 'react-bootstrap';
import { DraggableProvided } from 'react-beautiful-dnd';

interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface SectionOrderItemProps {
  sectionId: string;
  section: SectionData;
  position: number;
  totalSections: number;
  provided: DraggableProvided;
  isDragging: boolean;
  onPositionChange: (sectionId: string, newPosition: number) => void;
}

export default function SectionOrderItem({
  sectionId,
  section,
  position,
  totalSections,
  provided,
  isDragging,
  onPositionChange
}: SectionOrderItemProps) {
  const [inputPosition, setInputPosition] = useState(position.toString());

  const handlePositionBlur = () => {
    const newPos = parseInt(inputPosition);
    if (newPos !== position && newPos >= 1 && newPos <= totalSections) {
      onPositionChange(sectionId, newPos);
    } else {
      setInputPosition(position.toString()); // Reset invalid input
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handlePositionBlur();
    }
  };

  // Section ID to API mapping (same as backend)
  const sectionToApiMap: Record<string, string> = {
    "1": "Earnings API", "2": "Earnings API", "3": "Price API", "4": "Price API",
    "5": "Earnings API", "6": "Price API", "7": "Earnings API", "8": "Price API",
    "9": "Earnings API", "10": "Price API", "11": "Earnings API", "12": "Price API",
    "13": "Earnings API", "14": "Price API"
  };

  const sourceApi = sectionToApiMap[sectionId] || "Unknown API";

  return (
    <div
      ref={provided.innerRef}
      {...provided.draggableProps}
      className={`section-order-item mb-2 ${isDragging ? 'dragging' : ''}`}
    >
      <Card className={isDragging ? 'shadow-lg' : ''}>
        <Card.Body className="d-flex align-items-center gap-3 py-2">
          {/* Drag Handle */}
          <div {...provided.dragHandleProps} className="drag-handle">
            <i className="bi bi-grip-vertical fs-4 text-muted" style={{ cursor: 'grab' }}></i>
          </div>

          {/* Position Input */}
          <Form.Control
            type="number"
            value={inputPosition}
            onChange={(e) => setInputPosition(e.target.value)}
            onBlur={handlePositionBlur}
            onKeyPress={handleKeyPress}
            min={1}
            max={totalSections}
            style={{ width: '60px' }}
            className="text-center"
          />

          {/* Section Info */}
          <div className="flex-grow-1">
            <strong>Section {sectionId}: {section.section_name}</strong>
            <div className="d-flex gap-2 mt-1">
              <Badge bg="info">{sourceApi}</Badge>
              {section.metadata.data_available ? (
                <Badge bg="success">Data Available</Badge>
              ) : (
                <Badge bg="secondary">No Data</Badge>
              )}
            </div>
          </div>

          {/* Position Display */}
          <div className="text-muted">
            Position {position} of {totalSections}
          </div>
        </Card.Body>
      </Card>

      <style jsx>{`
        .section-order-item.dragging {
          opacity: 0.5;
        }
        .drag-handle:active {
          cursor: grabbing !important;
        }
      `}</style>
    </div>
  );
}
```

### Backend API Implementation

[Source: architecture.md - Source Tree and Module Organization - Backend Module Structure]

**File: backend/app/routers/configuration.py** (Update)

Add section order endpoint:

```python
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from pydantic import BaseModel
from ..database import get_database
from ..services.configuration_service import ConfigurationService
import logging

router = APIRouter(prefix="/api/triggers/{trigger_id}/config", tags=["configuration"])
logger = logging.getLogger(__name__)

# ... (existing endpoints)

class SectionOrderRequest(BaseModel):
    section_order: List[str]

@router.post("/section-order")
async def update_section_order(
    trigger_id: str,
    request: SectionOrderRequest,
    db = Depends(get_database)
):
    """
    Update section order for trigger configuration.
    Section order applies to all prompt types (shared configuration).
    """
    service = ConfigurationService(db)

    try:
        # Validate section order (must be valid section IDs)
        valid_sections = [str(i) for i in range(1, 15)]  # Sections 1-14
        for section_id in request.section_order:
            if section_id not in valid_sections:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid section ID: {section_id}"
                )

        config = await service.update_section_order(trigger_id, request.section_order)

        return {
            "success": True,
            "configuration": config
        }
    except Exception as e:
        logger.error(f"Failed to update section order: {e}")
        raise HTTPException(status_code=400, detail=str(e))
```

**File: backend/app/services/configuration_service.py** (Update)

Add update_section_order method:

```python
from datetime import datetime
from typing import List, Dict, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase

class ConfigurationService:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db

    # ... (existing methods)

    async def update_section_order(self, trigger_id: str, section_order: List[str]) -> Dict:
        """Update section order in configuration"""
        config = await self.get_configuration(trigger_id)

        # Validate that all sections in order exist in data_sections
        for section_id in section_order:
            if section_id not in config.get("data_sections", []):
                raise ValueError(
                    f"Section {section_id} not in configured data sections. "
                    f"Add section to data_sections before reordering."
                )

        # Update section order
        update_data = {
            "$set": {
                "section_order": section_order,
                "updated_at": datetime.utcnow()
            }
        }

        await self.db.configurations.update_one(
            {"_id": config["_id"]},
            update_data
        )

        # Return updated configuration
        return await self.db.configurations.find_one({"_id": config["_id"]})
```

### Implementation Notes

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Important Design Decisions**:

1. **Shared Section Order**: Section order is SHARED across all prompt types (paid, unpaid, crawler). One configuration applies to all. This simplifies UX and ensures data consistency.

2. **Drag-and-Drop Library**: Use **react-beautiful-dnd** for excellent React integration, touch support, and accessibility.

3. **Alternative Input**: Numbered input provides accessibility alternative and precision control for keyboard users.

4. **Auto-Save**: Section order changes auto-save to MongoDB immediately (no manual save button).

5. **Single-Level Undo**: Simple undo/redo implementation stores previous order. Single-level undo sufficient for MVP.

6. **Visual Feedback**: Dragging highlights drop zones with background color change. Dragged item shows opacity change.

7. **Validation**: Backend validates that reordered sections exist in configured data_sections. Cannot reorder sections not yet added.

8. **Preview Integration**: PreviewModal respects section order when displaying final data structure.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 3.1**:

**Unit Tests** (frontend/__tests__/components/config/):

```typescript
// SectionManagement.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { DragDropContext } from 'react-beautiful-dnd';
import SectionManagement from '@/components/config/SectionManagement';
import { DataProvider } from '@/contexts/DataContext';

describe('SectionManagement Component', () => {
  const mockStructuredData = {
    sections: {
      "1": {
        section_name: "Earnings Summary",
        section_id: "1",
        data: { summary: "Test data" },
        metadata: { parsed_at: "2025-10-29", data_available: true }
      },
      "2": {
        section_name: "Revenue Breakdown",
        section_id: "2",
        data: { summary: "Test data" },
        metadata: { parsed_at: "2025-10-29", data_available: true }
      },
      "3": {
        section_name: "Price History",
        section_id: "3",
        data: { summary: "Test data" },
        metadata: { parsed_at: "2025-10-29", data_available: true }
      }
    },
    metadata: {
      total_sections: 3,
      parsed_at: "2025-10-29T10:00:00Z"
    }
  };

  const renderWithContext = (component: React.ReactElement) => {
    return render(
      <DataProvider>
        {component}
      </DataProvider>
    );
  };

  test('renders section list in current order', () => {
    renderWithContext(<SectionManagement triggerId="trigger_001" />);

    expect(screen.getByText('Section Management')).toBeInTheDocument();
    expect(screen.getByText(/Section 1: Earnings Summary/)).toBeInTheDocument();
    expect(screen.getByText(/Section 2: Revenue Breakdown/)).toBeInTheDocument();
  });

  test('displays empty state when no structured data', () => {
    renderWithContext(<SectionManagement triggerId="trigger_001" />);

    expect(screen.getByText(/Parse data first to enable section reordering/)).toBeInTheDocument();
  });

  test('position input changes trigger reorder', async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true, configuration: {} })
      })
    );

    renderWithContext(<SectionManagement triggerId="trigger_001" />);

    // Find position input for section 1
    const positionInput = screen.getAllByRole('spinbutton')[0];
    fireEvent.change(positionInput, { target: { value: '3' } });
    fireEvent.blur(positionInput);

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/triggers/trigger_001/config/section-order',
        expect.objectContaining({ method: 'POST' })
      );
    });
  });

  test('undo button reverts section order', async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      })
    );

    renderWithContext(<SectionManagement triggerId="trigger_001" />);

    // Perform reorder
    const positionInput = screen.getAllByRole('spinbutton')[0];
    fireEvent.change(positionInput, { target: { value: '2' } });
    fireEvent.blur(positionInput);

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalled();
    });

    // Click undo
    const undoButton = screen.getByText('Undo');
    fireEvent.click(undoButton);

    // Should revert and save original order
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(2);
    });
  });

  test('displays error on save failure', async () => {
    global.fetch = jest.fn(() =>
      Promise.reject(new Error('Failed to save section order'))
    );

    renderWithContext(<SectionManagement triggerId="trigger_001" />);

    const positionInput = screen.getAllByRole('spinbutton')[0];
    fireEvent.change(positionInput, { target: { value: '2' } });
    fireEvent.blur(positionInput);

    await waitFor(() => {
      expect(screen.getByText(/Failed to save section order/)).toBeInTheDocument();
    });
  });
});

// SectionOrderItem.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { DraggableProvided } from 'react-beautiful-dnd';
import SectionOrderItem from '@/components/config/SectionOrderItem';

describe('SectionOrderItem Component', () => {
  const mockProvided: DraggableProvided = {
    innerRef: jest.fn(),
    draggableProps: {},
    dragHandleProps: {}
  } as any;

  const mockSection = {
    section_name: "Earnings Summary",
    section_id: "1",
    data: { summary: "Test" },
    metadata: { parsed_at: "2025-10-29", data_available: true }
  };

  test('renders section with position input', () => {
    render(
      <SectionOrderItem
        sectionId="1"
        section={mockSection}
        position={1}
        totalSections={5}
        provided={mockProvided}
        isDragging={false}
        onPositionChange={jest.fn()}
      />
    );

    expect(screen.getByText(/Section 1: Earnings Summary/)).toBeInTheDocument();
    expect(screen.getByDisplayValue('1')).toBeInTheDocument();
    expect(screen.getByText(/Position 1 of 5/)).toBeInTheDocument();
  });

  test('position input triggers position change on blur', () => {
    const mockOnPositionChange = jest.fn();

    render(
      <SectionOrderItem
        sectionId="1"
        section={mockSection}
        position={1}
        totalSections={5}
        provided={mockProvided}
        isDragging={false}
        onPositionChange={mockOnPositionChange}
      />
    );

    const input = screen.getByDisplayValue('1');
    fireEvent.change(input, { target: { value: '3' } });
    fireEvent.blur(input);

    expect(mockOnPositionChange).toHaveBeenCalledWith('1', 3);
  });

  test('invalid position input resets on blur', () => {
    render(
      <SectionOrderItem
        sectionId="1"
        section={mockSection}
        position={1}
        totalSections={5}
        provided={mockProvided}
        isDragging={false}
        onPositionChange={jest.fn()}
      />
    );

    const input = screen.getByDisplayValue('1') as HTMLInputElement;
    fireEvent.change(input, { target: { value: '10' } });
    fireEvent.blur(input);

    // Should reset to original position
    expect(input.value).toBe('1');
  });

  test('displays correct source API badge', () => {
    render(
      <SectionOrderItem
        sectionId="1"
        section={mockSection}
        position={1}
        totalSections={5}
        provided={mockProvided}
        isDragging={false}
        onPositionChange={jest.fn()}
      />
    );

    expect(screen.getByText('Earnings API')).toBeInTheDocument();
  });
});
```

**Integration Tests** (backend/tests/test_configuration.py):

```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_update_section_order(client: AsyncClient, db):
    """Test POST /api/triggers/:id/config/section-order endpoint"""
    # Create configuration with sections
    await db.configurations.insert_one({
        "_id": "config_001",
        "trigger_id": "trigger_001",
        "data_sections": ["1", "2", "3"],
        "section_order": ["1", "2", "3"]
    })

    response = await client.post(
        "/api/triggers/trigger_001/config/section-order",
        json={"section_order": ["3", "1", "2"]}
    )

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["configuration"]["section_order"] == ["3", "1", "2"]

@pytest.mark.asyncio
async def test_update_section_order_with_invalid_section(client: AsyncClient):
    """Test section order update with invalid section ID"""
    response = await client.post(
        "/api/triggers/trigger_001/config/section-order",
        json={"section_order": ["1", "99"]}  # 99 is invalid
    )

    assert response.status_code == 400
    assert "Invalid section ID" in response.json()["detail"]

@pytest.mark.asyncio
async def test_update_section_order_with_unconfigured_section(client: AsyncClient, db):
    """Test reordering section not in data_sections"""
    await db.configurations.insert_one({
        "_id": "config_002",
        "trigger_id": "trigger_002",
        "data_sections": ["1", "2"],  # Only sections 1 and 2
        "section_order": ["1", "2"]
    })

    response = await client.post(
        "/api/triggers/trigger_002/config/section-order",
        json={"section_order": ["1", "2", "3"]}  # Section 3 not configured
    )

    assert response.status_code == 400
    assert "not in configured data sections" in response.json()["detail"]

@pytest.mark.asyncio
async def test_section_order_persists(client: AsyncClient, db):
    """Test that section order persists to database"""
    await db.configurations.insert_one({
        "_id": "config_003",
        "trigger_id": "trigger_003",
        "data_sections": ["1", "2", "3"],
        "section_order": ["1", "2", "3"]
    })

    await client.post(
        "/api/triggers/trigger_003/config/section-order",
        json={"section_order": ["2", "3", "1"]}
    )

    # Verify persistence
    config = await db.configurations.find_one({"trigger_id": "trigger_003"})
    assert config["section_order"] == ["2", "3", "1"]
```

**Manual Verification Checklist**:
1. SectionManagement component appears after parsing data
2. Sections displayed in numbered list with drag handles
3. Drag-and-drop reordering works smoothly
4. Drop zones highlighted during drag operation
5. Position input accepts valid numbers (1 to total sections)
6. Invalid position input rejected or reset
7. Section order saves to MongoDB automatically
8. Toast notification confirms successful save
9. Undo button reverts last reorder
10. Undo button disabled when no previous state
11. Preview Data Structure respects new section order
12. Section order persists across page refresh
13. API errors display clear messages
14. Responsive layout on desktop and tablet
15. No console errors in browser

**Coverage Target**: 70%+ for section reordering logic

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 3 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
