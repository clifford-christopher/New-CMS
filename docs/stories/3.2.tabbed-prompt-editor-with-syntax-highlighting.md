# Story 3.2: Multi-Type Prompt Editor with Tabs and Pre-population

## Status

‚úÖ Implemented - November 2025

## Version 2.0

## Story

**As a** content manager,
**I want** a tabbed Monaco Editor for crafting independent prompts (paid/unpaid/crawler) with pre-population from existing prompts,
**so that** I can write prompts for different audiences using existing templates as a starting point.

## Acceptance Criteria

1. Monaco Editor component integrated with tabbed interface for 3 prompt types
2. Tabs displayed horizontally: [üí∞ Paid] [üÜì Unpaid] [üï∑Ô∏è Crawler]
3. Paid tab always visible and active by default (required prompt)
4. Unpaid and Crawler tabs have checkboxes to enable/disable (optional prompts)
5. Only checked prompt types show tabs in the interface
6. Active tab highlighted with blue underline (#0d6efd), inactive tabs shown in gray
7. Clicking a tab switches the editor content to that prompt type's template
8. Each prompt type maintains its own independent template
9. **Pre-populate editors** with existing prompts from `GET /api/triggers/{trigger_name}/prompts` (Story 2.3)
10. If no existing prompt: Start with blank or example template
11. Syntax highlighting for placeholders: `{{section_1}}`, `{{section_2}}`, `{data.field}`
12. Line numbers, search/replace, keyboard shortcuts (Ctrl+F, Ctrl+Z) available
13. Auto-save to WorkflowContext every 5 seconds (debounced) per prompt type
14. Character count displayed below editor for each prompt type
15. Shared data configuration across all prompt types (from Story 2.5)
16. Tab indicator shows warning icon if validation errors exist in that prompt's template
17. Meets FR13, FR14, FR35, FR36, FR37, FR38: multi-type prompts with pre-population

## Tasks / Subtasks

- [ ] Task 1: Create PromptContext provider for multi-type prompt state (AC: 4, 5, 11)
  - [ ] Create frontend/src/contexts/PromptContext.tsx
  - [ ] State management for paid, unpaid, crawler prompt templates
  - [ ] Auto-save logic with 5-second debounce per prompt type
  - [ ] Track active tab and checked prompt types
- [ ] Task 2: Create PromptEditor component with Monaco integration (AC: 1, 6, 7, 8, 9)
  - [ ] Install @monaco-editor/react package
  - [ ] Create frontend/src/components/config/PromptEditor.tsx
  - [ ] Configure syntax highlighting for placeholder format
  - [ ] Enable line numbers, search/replace, keyboard shortcuts
  - [ ] Implement resizable/full-screen mode
- [ ] Task 3: Implement tabbed interface (AC: 2, 3, 4, 14)
  - [ ] Create tab navigation with icons
  - [ ] Show only tabs for checked prompt types
  - [ ] Highlight active tab with blue underline
  - [ ] Switch editor content on tab click
  - [ ] Default to paid tab on load
- [ ] Task 4: Add character/word count display (AC: 13)
  - [ ] Calculate character count per prompt type
  - [ ] Display count below editor
  - [ ] Update count in real-time as user types
- [ ] Task 5: Implement theme configuration (AC: 12)
  - [ ] Add theme toggle or auto-detect system preference
  - [ ] Support light/dark Monaco themes
  - [ ] Persist theme preference in localStorage
- [ ] Task 6: Create backend endpoint for prompt persistence (AC: 11)
  - [ ] Create POST /api/triggers/:id/config/prompts endpoint
  - [ ] Update prompts object in Configuration document
  - [ ] Return updated configuration
- [ ] Task 7: Write unit and integration tests
  - [ ] Test PromptContext state management
  - [ ] Test tab switching and active state
  - [ ] Test auto-save with debouncing
  - [ ] Test Monaco editor initialization
  - [ ] Test backend endpoint

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 2.5 - Completion]

Before starting this story, ensure Story 2.5 is complete:
- StructuredDataDisplay component shows parsed sections
- DataContext provides structured data and section order
- Configuration Workspace displays structured sections

**Story 3.1 Dependency**:
- SectionManagement component displays section order (shared across all prompt types)
- Section order saved to Configuration in MongoDB
- "Preview Data Structure" respects new section order

**Story 2.3 v2.0 - Trigger Data Retrieval**:
- `GET /api/triggers/{trigger_name}/data?stockid={stockid}` endpoint for fetching raw trigger data
- `GET /api/triggers/{trigger_name}/prompts` endpoint for retrieving existing prompt templates

**Story 2.4 v2.0 - Async Job Pattern**:
- Async job processing pattern for long-running operations
- Job status polling and progress tracking
- Integration with WorkflowContext for job state management

**Story 2.5 v2.0 - Section Selection**:
- Section selection UI for choosing which data sections to include
- Section visibility toggles and ordering
- Integration with prompt placeholders

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ       ‚îú‚îÄ‚îÄ PromptEditor.tsx              # Tabbed Monaco Editor (NEW)
‚îÇ       ‚îú‚îÄ‚îÄ PromptTabs.tsx                # Tab navigation component (NEW)
‚îÇ       ‚îú‚îÄ‚îÄ CharacterCounter.tsx          # Character/word count display (NEW)
‚îÇ       ‚îú‚îÄ‚îÄ TriggerContextBar.tsx         # Update checkbox state (MODIFY)
‚îÇ       ‚îî‚îÄ‚îÄ ConfigurationWorkspace.tsx    # Integrate PromptEditor (MODIFY)
‚îú‚îÄ‚îÄ contexts/
‚îÇ   ‚îú‚îÄ‚îÄ PromptContext.tsx                 # Prompt state management (NEW)
‚îÇ   ‚îî‚îÄ‚îÄ DataContext.tsx                   # Existing data context
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ configuration.ts                  # TypeScript types (existing)
```

**Backend files to create/modify** in `backend/app/`:
```
backend/app/
‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îî‚îÄ‚îÄ configuration.py                  # Add prompts endpoint (MODIFY)
‚îî‚îÄ‚îÄ services/
    ‚îî‚îÄ‚îÄ configuration_service.py          # Add update_prompts method (MODIFY)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **Monaco Editor**: `@monaco-editor/react` (install: `npm install @monaco-editor/react monaco-editor`)
- **React-Bootstrap**: For tabs, buttons, layout
- **React Context API**: PromptContext for multi-type prompt state
- **TypeScript**: Type safety for prompt operations
- **useDebouncedCallback**: For auto-save (install: `npm install use-debounce`)

**Monaco Editor Features**:
- Syntax highlighting with custom language definition
- Line numbers and minimap
- Search/replace (Ctrl+F, Ctrl+H)
- Undo/redo (Ctrl+Z, Ctrl+Y)
- Multiple themes (vs-dark, vs-light)
- Resizable container

**Decision**: Use **@monaco-editor/react** for official React wrapper with excellent TypeScript support.

### Multi-Prompt Type Architecture

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Tabbed Interface Pattern**:
- **Shared Editor Instance**: Single Monaco Editor component, content changes per tab
- **Independent Templates**: Each prompt type (paid, unpaid, crawler) has separate template
- **Tab Visibility**: Controlled by checkboxes in Trigger Context Bar
- **Default State**: Paid tab always visible and active by default
- **Auto-Save**: Debounced save per prompt type (5 seconds after last edit)

**Why Tabbed Interface?**:
- Single editor reduces screen clutter
- Clear visual separation between prompt types
- Familiar UI pattern (like browser tabs)
- Efficient use of screen space

### React Context for Prompt Management

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/PromptContext.tsx** (New)

Complete prompt state management with auto-save:

```typescript
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { useDebouncedCallback } from 'use-debounce';

type PromptType = 'paid' | 'unpaid' | 'crawler';

interface PromptTemplate {
  content: string;
  lastSaved: Date | null;
  characterCount: number;
  wordCount: number;
}

interface PromptContextType {
  prompts: Record<PromptType, PromptTemplate>;
  activeTab: PromptType;
  checkedTypes: Set<PromptType>;
  editorTheme: 'vs-light' | 'vs-dark';
  setPromptContent: (type: PromptType, content: string) => void;
  setActiveTab: (type: PromptType) => void;
  setCheckedTypes: (types: Set<PromptType>) => void;
  setEditorTheme: (theme: 'vs-light' | 'vs-dark') => void;
  savePrompts: (triggerId: string) => Promise<void>;
  loadPrompts: (triggerId: string) => Promise<void>;
  isSaving: boolean;
  saveError: string | null;
}

const PromptContext = createContext<PromptContextType | undefined>(undefined);

const calculateStats = (content: string) => {
  const characterCount = content.length;
  const wordCount = content.trim() ? content.trim().split(/\s+/).length : 0;
  return { characterCount, wordCount };
};

export function PromptProvider({ children }: { children: ReactNode }) {
  const [prompts, setPrompts] = useState<Record<PromptType, PromptTemplate>>({
    paid: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 },
    unpaid: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 },
    crawler: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 }
  });

  const [activeTab, setActiveTab] = useState<PromptType>('paid');
  const [checkedTypes, setCheckedTypes] = useState<Set<PromptType>>(new Set(['paid']));
  const [editorTheme, setEditorThemeState] = useState<'vs-light' | 'vs-dark'>('vs-dark');
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [triggerId, setTriggerId] = useState<string | null>(null);

  // Load theme from localStorage on mount
  useEffect(() => {
    const savedTheme = localStorage.getItem('editor-theme') as 'vs-light' | 'vs-dark' | null;
    if (savedTheme) {
      setEditorThemeState(savedTheme);
    } else {
      // Auto-detect system preference
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setEditorThemeState(prefersDark ? 'vs-dark' : 'vs-light');
    }
  }, []);

  const setEditorTheme = (theme: 'vs-light' | 'vs-dark') => {
    setEditorThemeState(theme);
    localStorage.setItem('editor-theme', theme);
  };

  const setPromptContent = (type: PromptType, content: string) => {
    const stats = calculateStats(content);
    setPrompts(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        content,
        ...stats
      }
    }));

    // Trigger auto-save (debounced)
    if (triggerId) {
      debouncedSave(triggerId);
    }
  };

  const savePrompts = async (tid: string) => {
    try {
      setIsSaving(true);
      setSaveError(null);

      const response = await fetch(`/api/triggers/${tid}/config/prompts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompts: {
            paid: { template: prompts.paid.content },
            unpaid: { template: prompts.unpaid.content },
            crawler: { template: prompts.crawler.content }
          }
        })
      });

      if (!response.ok) {
        throw new Error('Failed to save prompts');
      }

      // Update lastSaved timestamps
      const now = new Date();
      setPrompts(prev => ({
        paid: { ...prev.paid, lastSaved: now },
        unpaid: { ...prev.unpaid, lastSaved: now },
        crawler: { ...prev.crawler, lastSaved: now }
      }));

    } catch (err) {
      setSaveError(err instanceof Error ? err.message : 'Failed to save prompts');
      throw err;
    } finally {
      setIsSaving(false);
    }
  };

  // Debounced save function (5 seconds)
  const debouncedSave = useDebouncedCallback(
    async (tid: string) => {
      try {
        await savePrompts(tid);
      } catch (err) {
        console.error('Auto-save failed:', err);
      }
    },
    5000
  );

  const loadPrompts = async (tid: string) => {
    try {
      setTriggerId(tid);
      const response = await fetch(`/api/triggers/${tid}/config`);

      if (!response.ok) {
        throw new Error('Failed to load configuration');
      }

      const config = await response.json();

      if (config.prompts) {
        setPrompts({
          paid: {
            content: config.prompts.paid?.template || '',
            lastSaved: config.prompts.paid?.last_saved ? new Date(config.prompts.paid.last_saved) : null,
            ...calculateStats(config.prompts.paid?.template || '')
          },
          unpaid: {
            content: config.prompts.unpaid?.template || '',
            lastSaved: config.prompts.unpaid?.last_saved ? new Date(config.prompts.unpaid.last_saved) : null,
            ...calculateStats(config.prompts.unpaid?.template || '')
          },
          crawler: {
            content: config.prompts.crawler?.template || '',
            lastSaved: config.prompts.crawler?.last_saved ? new Date(config.prompts.crawler.last_saved) : null,
            ...calculateStats(config.prompts.crawler?.template || '')
          }
        });
      }
    } catch (err) {
      setSaveError(err instanceof Error ? err.message : 'Failed to load prompts');
    }
  };

  const value: PromptContextType = {
    prompts,
    activeTab,
    checkedTypes,
    editorTheme,
    setPromptContent,
    setActiveTab,
    setCheckedTypes,
    setEditorTheme,
    savePrompts,
    loadPrompts,
    isSaving,
    saveError
  };

  return <PromptContext.Provider value={value}>{children}</PromptContext.Provider>;
}

export function usePrompt() {
  const context = useContext(PromptContext);
  if (context === undefined) {
    throw new Error('usePrompt must be used within a PromptProvider');
  }
  return context;
}
```

### Frontend Component Specifications

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/components/config/PromptEditor.tsx** (New)

Complete tabbed Monaco Editor with syntax highlighting:

```typescript
'use client';

import { useEffect, useRef } from 'react';
import { Card, Alert } from 'react-bootstrap';
import Editor from '@monaco-editor/react';
import { usePrompt } from '@/contexts/PromptContext';
import { useData } from '@/contexts/DataContext';
import PromptTabs from './PromptTabs';
import CharacterCounter from './CharacterCounter';

interface PromptEditorProps {
  triggerId: string;
}

export default function PromptEditor({ triggerId }: PromptEditorProps) {
  const {
    prompts,
    activeTab,
    editorTheme,
    setPromptContent,
    isSaving,
    saveError,
    loadPrompts
  } = usePrompt();

  const { structuredData } = useData();
  const editorRef = useRef<any>(null);

  // Load prompts on mount
  useEffect(() => {
    loadPrompts(triggerId);
  }, [triggerId]);

  // Configure Monaco Editor with custom language
  const handleEditorDidMount = (editor: any, monaco: any) => {
    editorRef.current = editor;

    // Define custom language for prompt placeholders
    monaco.languages.register({ id: 'prompt-template' });

    monaco.languages.setMonarchTokensProvider('prompt-template', {
      tokenizer: {
        root: [
          // Highlight {{section_name}} placeholders
          [/\{\{[a-zA-Z_][a-zA-Z0-9_]*\}\}/, 'custom-placeholder'],
          // Highlight {data.field} placeholders
          [/\{data\.[a-zA-Z_][a-zA-Z0-9_.]*\}/, 'custom-placeholder'],
          // Comments
          [/#.*$/, 'comment']
        ]
      }
    });

    // Define custom theme
    monaco.editor.defineTheme('prompt-dark', {
      base: 'vs-dark',
      inherit: true,
      rules: [
        { token: 'custom-placeholder', foreground: '569cd6', fontStyle: 'bold' },
        { token: 'comment', foreground: '6a9955', fontStyle: 'italic' }
      ],
      colors: {}
    });

    monaco.editor.defineTheme('prompt-light', {
      base: 'vs',
      inherit: true,
      rules: [
        { token: 'custom-placeholder', foreground: '0000ff', fontStyle: 'bold' },
        { token: 'comment', foreground: '008000', fontStyle: 'italic' }
      ],
      colors: {}
    });
  };

  const handleEditorChange = (value: string | undefined) => {
    if (value !== undefined) {
      setPromptContent(activeTab, value);
    }
  };

  const currentPrompt = prompts[activeTab];

  return (
    <Card className="mt-4">
      <Card.Header className="d-flex justify-content-between align-items-center">
        <div>
          <h5 className="mb-0">Prompt Editor</h5>
          <small className="text-muted">
            Craft prompts with placeholders (e.g., {'{{section_1}}'}, {'{data.earnings.summary}'})
          </small>
        </div>
        <div className="d-flex gap-2 align-items-center">
          {isSaving && (
            <span className="text-muted">
              <i className="bi bi-cloud-upload me-1"></i>
              Saving...
            </span>
          )}
          {currentPrompt.lastSaved && !isSaving && (
            <small className="text-success">
              <i className="bi bi-check-circle me-1"></i>
              Saved {formatLastSaved(currentPrompt.lastSaved)}
            </small>
          )}
        </div>
      </Card.Header>

      <Card.Body className="p-0">
        {saveError && (
          <Alert variant="danger" className="m-3 mb-0" dismissible>
            {saveError}
          </Alert>
        )}

        {!structuredData && (
          <Alert variant="info" className="m-3 mb-0">
            Parse data first to enable placeholder autocomplete.
          </Alert>
        )}

        {/* Tab Navigation */}
        <PromptTabs />

        {/* Monaco Editor */}
        <div style={{ height: '500px', position: 'relative' }}>
          <Editor
            height="100%"
            language="prompt-template"
            theme={editorTheme === 'vs-dark' ? 'prompt-dark' : 'prompt-light'}
            value={currentPrompt.content}
            onChange={handleEditorChange}
            onMount={handleEditorDidMount}
            options={{
              minimap: { enabled: true },
              lineNumbers: 'on',
              scrollBeyondLastLine: false,
              wordWrap: 'on',
              fontSize: 14,
              tabSize: 2,
              insertSpaces: true,
              automaticLayout: true,
              suggestOnTriggerCharacters: true,
              quickSuggestions: true,
              formatOnPaste: true,
              formatOnType: true
            }}
          />
        </div>

        {/* Character Counter */}
        <CharacterCounter
          characterCount={currentPrompt.characterCount}
          wordCount={currentPrompt.wordCount}
          promptType={activeTab}
        />
      </Card.Body>

      <style jsx>{`
        .monaco-editor .custom-placeholder {
          color: #569cd6;
          font-weight: bold;
        }
      `}</style>
    </Card>
  );
}

function formatLastSaved(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSec = Math.floor(diffMs / 1000);

  if (diffSec < 60) return 'just now';
  if (diffSec < 3600) return `${Math.floor(diffSec / 60)} min ago`;
  if (diffSec < 86400) return `${Math.floor(diffSec / 3600)} hr ago`;
  return date.toLocaleDateString();
}
```

**File: frontend/src/components/config/PromptTabs.tsx** (New)

Tab navigation component:

```typescript
'use client';

import { Nav } from 'react-bootstrap';
import { usePrompt } from '@/contexts/PromptContext';

type PromptType = 'paid' | 'unpaid' | 'crawler';

const TAB_CONFIG: Record<PromptType, { icon: string; label: string; color: string }> = {
  paid: { icon: 'üí∞', label: 'Paid', color: '#0d6efd' },
  unpaid: { icon: 'üÜì', label: 'Unpaid', color: '#198754' },
  crawler: { icon: 'üï∑Ô∏è', label: 'Crawler', color: '#fd7e14' }
};

export default function PromptTabs() {
  const { activeTab, checkedTypes, setActiveTab } = usePrompt();

  // Filter tabs to show only checked types
  const visibleTabs = (['paid', 'unpaid', 'crawler'] as PromptType[]).filter(type =>
    checkedTypes.has(type)
  );

  return (
    <Nav variant="tabs" className="px-3 pt-2" style={{ borderBottom: '1px solid #dee2e6' }}>
      {visibleTabs.map(type => {
        const config = TAB_CONFIG[type];
        const isActive = activeTab === type;

        return (
          <Nav.Item key={type}>
            <Nav.Link
              active={isActive}
              onClick={() => setActiveTab(type)}
              style={{
                cursor: 'pointer',
                borderBottom: isActive ? `3px solid ${config.color}` : 'none',
                color: isActive ? config.color : '#6c757d',
                fontWeight: isActive ? 'bold' : 'normal'
              }}
            >
              <span className="me-2">{config.icon}</span>
              {config.label}
            </Nav.Link>
          </Nav.Item>
        );
      })}
    </Nav>
  );
}
```

**File: frontend/src/components/config/CharacterCounter.tsx** (New)

Character and word count display:

```typescript
'use client';

import { Badge } from 'react-bootstrap';

interface CharacterCounterProps {
  characterCount: number;
  wordCount: number;
  promptType: 'paid' | 'unpaid' | 'crawler';
}

export default function CharacterCounter({
  characterCount,
  wordCount,
  promptType
}: CharacterCounterProps) {
  // Estimate token count (rough approximation: 1 token ‚âà 4 characters)
  const estimatedTokens = Math.ceil(characterCount / 4);

  return (
    <div className="d-flex justify-content-between align-items-center px-3 py-2 bg-light border-top">
      <div className="d-flex gap-3">
        <small className="text-muted">
          <i className="bi bi-fonts me-1"></i>
          <strong>{characterCount.toLocaleString()}</strong> characters
        </small>
        <small className="text-muted">
          <i className="bi bi-chat-text me-1"></i>
          <strong>{wordCount.toLocaleString()}</strong> words
        </small>
        <small className="text-muted">
          <i className="bi bi-lightning me-1"></i>
          ~<strong>{estimatedTokens.toLocaleString()}</strong> tokens (est.)
        </small>
      </div>
      <Badge bg="secondary" className="text-capitalize">
        {promptType} Prompt
      </Badge>
    </div>
  );
}
```

### Backend API Implementation

[Source: architecture.md - Source Tree and Module Organization - Backend Module Structure]

**File: backend/app/routers/configuration.py** (Update)

Add prompts endpoint:

```python
from fastapi import APIRouter, HTTPException, Depends
from typing import Dict
from pydantic import BaseModel
from ..database import get_database
from ..services.configuration_service import ConfigurationService
import logging

router = APIRouter(prefix="/api/triggers/{trigger_id}/config", tags=["configuration"])
logger = logging.getLogger(__name__)

# ... (existing endpoints)

class PromptTemplateRequest(BaseModel):
    template: str

class PromptsRequest(BaseModel):
    prompts: Dict[str, PromptTemplateRequest]  # {"paid": {...}, "unpaid": {...}, "crawler": {...}}

@router.post("/prompts")
async def update_prompts(
    trigger_id: str,
    request: PromptsRequest,
    db = Depends(get_database)
):
    """
    Update prompt templates for all prompt types.
    Accepts prompts object with paid, unpaid, crawler templates.
    """
    service = ConfigurationService(db)

    try:
        # Validate that prompt types are valid
        valid_types = {"paid", "unpaid", "crawler"}
        for prompt_type in request.prompts.keys():
            if prompt_type not in valid_types:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid prompt type: {prompt_type}. Must be one of: paid, unpaid, crawler"
                )

        config = await service.update_prompts(trigger_id, request.prompts)

        return {
            "success": True,
            "configuration": config
        }
    except Exception as e:
        logger.error(f"Failed to update prompts: {e}")
        raise HTTPException(status_code=400, detail=str(e))
```

**File: backend/app/services/configuration_service.py** (Update)

Add update_prompts method:

```python
from datetime import datetime
from typing import Dict, Any
from motor.motor_asyncio import AsyncIOMotorDatabase

class ConfigurationService:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db

    # ... (existing methods)

    async def update_prompts(self, trigger_id: str, prompts: Dict[str, Any]) -> Dict:
        """Update prompt templates for all prompt types"""
        config = await self.get_configuration(trigger_id)

        # Build prompts update with version history
        prompts_update = {}
        for prompt_type, prompt_data in prompts.items():
            template = prompt_data.get("template", "")

            # Get existing prompt config or initialize
            existing_prompt = config.get("prompts", {}).get(prompt_type, {})
            version_history = existing_prompt.get("version_history", [])

            # Add current version to history (keep last 10)
            if existing_prompt.get("template"):
                version_history.append({
                    "template": existing_prompt["template"],
                    "timestamp": existing_prompt.get("last_saved", datetime.utcnow()),
                    "user_id": "current_user"  # TODO: Get from auth context
                })
                version_history = version_history[-10:]  # Keep last 10 versions

            prompts_update[f"prompts.{prompt_type}"] = {
                "template": template,
                "last_saved": datetime.utcnow(),
                "version_history": version_history,
                "character_count": len(template),
                "word_count": len(template.split()) if template else 0
            }

        # Update prompts
        update_data = {
            "$set": {
                **prompts_update,
                "updated_at": datetime.utcnow()
            }
        }

        await self.db.configurations.update_one(
            {"_id": config["_id"]},
            update_data
        )

        # Return updated configuration
        return await self.db.configurations.find_one({"_id": config["_id"]})
```

### Implementation Notes

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Important Design Decisions**:

1. **Tabbed Interface**: Single Monaco Editor instance with content switching per tab. Reduces memory footprint and provides familiar UX.

2. **Auto-Save**: 5-second debounce per prompt type. Changes auto-save to MongoDB without user intervention. Visual feedback shows "Saving..." and "Saved" timestamps.

3. **Syntax Highlighting**: Custom Monaco language definition highlights `{{section_name}}` and `{data.field}` placeholders in blue/bold. Easy to spot placeholder errors.

4. **Character/Word/Token Count**: Real-time stats help users estimate LLM costs before generation. Token count is approximate (4 chars ‚âà 1 token).

5. **Theme Configuration**: Light/dark mode with localStorage persistence. Auto-detects system preference on first load.

6. **Tab Visibility**: Only checked prompt types (from Trigger Context Bar) display as tabs. Paid tab always visible by default.

7. **Version History**: Backend stores last 10 versions per prompt type for undo/redo support (Story 3.5).

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 3.2**:

**Unit Tests** (frontend/__tests__/components/config/):

```typescript
// PromptEditor.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import PromptEditor from '@/components/config/PromptEditor';
import { PromptProvider } from '@/contexts/PromptContext';
import { DataProvider } from '@/contexts/DataContext';

describe('PromptEditor Component', () => {
  const renderWithContext = (component: React.ReactElement) => {
    return render(
      <DataProvider>
        <PromptProvider>
          {component}
        </PromptProvider>
      </DataProvider>
    );
  };

  test('renders Monaco Editor with tabs', async () => {
    renderWithContext(<PromptEditor triggerId="trigger_001" />);

    await waitFor(() => {
      expect(screen.getByText('Prompt Editor')).toBeInTheDocument();
    });

    // Check default tab (Paid) is visible
    expect(screen.getByText(/üí∞ Paid/)).toBeInTheDocument();
  });

  test('switches editor content when tab clicked', async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          prompts: {
            paid: { template: 'Paid prompt content' },
            unpaid: { template: 'Unpaid prompt content' }
          }
        })
      })
    );

    renderWithContext(<PromptEditor triggerId="trigger_001" />);

    await waitFor(() => {
      expect(screen.getByText(/üí∞ Paid/)).toBeInTheDocument();
    });

    // Click unpaid tab
    const unpaidTab = screen.getByText(/üÜì Unpaid/);
    fireEvent.click(unpaidTab);

    await waitFor(() => {
      // Editor should show unpaid content (checked via Monaco Editor props)
      expect(unpaidTab.parentElement).toHaveClass('active');
    });
  });

  test('displays character and word count', async () => {
    renderWithContext(<PromptEditor triggerId="trigger_001" />);

    await waitFor(() => {
      expect(screen.getByText(/characters/)).toBeInTheDocument();
      expect(screen.getByText(/words/)).toBeInTheDocument();
      expect(screen.getByText(/tokens/)).toBeInTheDocument();
    });
  });

  test('auto-saves after 5 seconds of inactivity', async () => {
    jest.useFakeTimers();

    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      })
    );

    renderWithContext(<PromptEditor triggerId="trigger_001" />);

    await waitFor(() => {
      expect(screen.getByText('Prompt Editor')).toBeInTheDocument();
    });

    // Simulate typing (this would be Monaco Editor onChange)
    // In real test, use Monaco Editor's test utilities

    // Fast-forward 5 seconds
    jest.advanceTimersByTime(5000);

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/triggers/trigger_001/config/prompts',
        expect.objectContaining({ method: 'POST' })
      );
    });

    jest.useRealTimers();
  });

  test('displays save error on API failure', async () => {
    global.fetch = jest.fn(() =>
      Promise.reject(new Error('Failed to save prompts'))
    );

    renderWithContext(<PromptEditor triggerId="trigger_001" />);

    // Trigger save manually
    // ... (depends on component implementation)

    await waitFor(() => {
      expect(screen.getByText(/Failed to save prompts/)).toBeInTheDocument();
    });
  });
});

// PromptTabs.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import PromptTabs from '@/components/config/PromptTabs';
import { PromptProvider } from '@/contexts/PromptContext';

describe('PromptTabs Component', () => {
  test('renders only checked prompt types', () => {
    render(
      <PromptProvider>
        <PromptTabs />
      </PromptProvider>
    );

    // Paid should always be visible
    expect(screen.getByText(/üí∞ Paid/)).toBeInTheDocument();

    // Unpaid and crawler should not be visible if not checked
    // (This depends on initial state in PromptProvider)
  });

  test('highlights active tab', () => {
    render(
      <PromptProvider>
        <PromptTabs />
      </PromptProvider>
    );

    const paidTab = screen.getByText(/üí∞ Paid/).closest('a');
    expect(paidTab).toHaveStyle({ fontWeight: 'bold' });
  });

  test('switches active tab on click', () => {
    render(
      <PromptProvider>
        <PromptTabs />
      </PromptProvider>
    );

    const unpaidTab = screen.getByText(/üÜì Unpaid/);
    fireEvent.click(unpaidTab);

    expect(unpaidTab.closest('a')).toHaveStyle({ fontWeight: 'bold' });
  });
});

// CharacterCounter.test.tsx
import { render, screen } from '@testing-library/react';
import CharacterCounter from '@/components/config/CharacterCounter';

describe('CharacterCounter Component', () => {
  test('displays character, word, and token counts', () => {
    render(
      <CharacterCounter
        characterCount={500}
        wordCount={100}
        promptType="paid"
      />
    );

    expect(screen.getByText(/500/)).toBeInTheDocument();
    expect(screen.getByText(/100/)).toBeInTheDocument();
    expect(screen.getByText(/125/)).toBeInTheDocument(); // 500 / 4 ‚âà 125 tokens
  });

  test('displays prompt type badge', () => {
    render(
      <CharacterCounter
        characterCount={500}
        wordCount={100}
        promptType="paid"
      />
    );

    expect(screen.getByText('paid Prompt')).toBeInTheDocument();
  });
});
```

**Integration Tests** (backend/tests/test_configuration.py):

```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_update_prompts(client: AsyncClient, db):
    """Test POST /api/triggers/:id/config/prompts endpoint"""
    # Create configuration
    await db.configurations.insert_one({
        "_id": "config_001",
        "trigger_id": "trigger_001",
        "prompts": {
            "paid": {"template": "Old paid prompt"},
            "unpaid": {"template": "Old unpaid prompt"},
            "crawler": {"template": "Old crawler prompt"}
        }
    })

    response = await client.post(
        "/api/triggers/trigger_001/config/prompts",
        json={
            "prompts": {
                "paid": {"template": "New paid prompt"},
                "unpaid": {"template": "New unpaid prompt"},
                "crawler": {"template": "New crawler prompt"}
            }
        }
    )

    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["configuration"]["prompts"]["paid"]["template"] == "New paid prompt"
    assert data["configuration"]["prompts"]["unpaid"]["template"] == "New unpaid prompt"
    assert data["configuration"]["prompts"]["crawler"]["template"] == "New crawler prompt"

@pytest.mark.asyncio
async def test_update_prompts_with_invalid_type(client: AsyncClient):
    """Test prompt update with invalid prompt type"""
    response = await client.post(
        "/api/triggers/trigger_001/config/prompts",
        json={
            "prompts": {
                "invalid_type": {"template": "Test"}
            }
        }
    )

    assert response.status_code == 400
    assert "Invalid prompt type" in response.json()["detail"]

@pytest.mark.asyncio
async def test_prompt_version_history(client: AsyncClient, db):
    """Test that version history is maintained"""
    await db.configurations.insert_one({
        "_id": "config_002",
        "trigger_id": "trigger_002",
        "prompts": {
            "paid": {
                "template": "Version 1",
                "version_history": []
            }
        }
    })

    # Update prompt
    await client.post(
        "/api/triggers/trigger_002/config/prompts",
        json={
            "prompts": {
                "paid": {"template": "Version 2"}
            }
        }
    )

    # Check version history
    config = await db.configurations.find_one({"trigger_id": "trigger_002"})
    assert len(config["prompts"]["paid"]["version_history"]) == 1
    assert config["prompts"]["paid"]["version_history"][0]["template"] == "Version 1"
    assert config["prompts"]["paid"]["template"] == "Version 2"

@pytest.mark.asyncio
async def test_character_count_stored(client: AsyncClient, db):
    """Test that character and word counts are stored"""
    await db.configurations.insert_one({
        "_id": "config_003",
        "trigger_id": "trigger_003",
        "prompts": {}
    })

    response = await client.post(
        "/api/triggers/trigger_003/config/prompts",
        json={
            "prompts": {
                "paid": {"template": "This is a test prompt with some words"}
            }
        }
    )

    config = await db.configurations.find_one({"trigger_id": "trigger_003"})
    assert config["prompts"]["paid"]["character_count"] > 0
    assert config["prompts"]["paid"]["word_count"] == 8
```

**Manual Verification Checklist**:
1. Monaco Editor loads with syntax highlighting
2. Tabs display only for checked prompt types
3. Active tab highlighted with blue underline
4. Clicking tab switches editor content
5. Each prompt type maintains separate content
6. Placeholders (`{{section_name}}`, `{data.field}`) highlighted in blue/bold
7. Line numbers, search (Ctrl+F), undo (Ctrl+Z) work
8. Editor resizable or full-screen mode available
9. Character/word/token count updates in real-time
10. Auto-save triggers after 5 seconds of inactivity
11. "Saving..." and "Saved" indicators display correctly
12. Theme toggles between light/dark modes
13. Theme preference persists in localStorage
14. Prompts save to MongoDB successfully
15. Version history maintained in backend (10 versions max)
16. No console errors in browser

**Coverage Target**: 70%+ for prompt management logic

## News CMS Workflow Updates

### Multi-Type Prompt Architecture

**Three Prompt Types**:

1. **Paid Prompt** (üí∞ icon):
   - Required prompt type, always visible in the interface
   - Cannot be disabled or hidden
   - Active by default when opening the prompt editor
   - Used for generating content for paid/premium news articles
   - Pre-populated from `GET /api/triggers/{trigger_name}/prompts` endpoint

2. **Unpaid Prompt** (üÜì icon):
   - Optional prompt type with checkbox toggle
   - Only visible when checkbox is enabled
   - Used for generating content for free/public news articles
   - Pre-populated from `GET /api/triggers/{trigger_name}/prompts` endpoint
   - Checkbox state managed in WorkflowContext

3. **Crawler Prompt** (üï∑Ô∏è icon):
   - Optional prompt type with checkbox toggle
   - Only visible when checkbox is enabled
   - Used for generating structured data for search engine crawlers
   - Pre-populated from `GET /api/triggers/{trigger_name}/prompts` endpoint
   - Checkbox state managed in WorkflowContext

### Prompt Pre-population Flow

**Data Source**: `GET /api/triggers/{trigger_name}/prompts`

Response format:
```json
{
  "paid": {
    "template": "Existing paid prompt template...",
    "last_saved": "2025-10-29T10:30:00Z"
  },
  "unpaid": {
    "template": "Existing unpaid prompt template...",
    "last_saved": "2025-10-29T10:30:00Z"
  },
  "crawler": {
    "template": "Existing crawler prompt template...",
    "last_saved": "2025-10-29T10:30:00Z"
  }
}
```

**Pre-population Logic**:
1. On component mount, fetch existing prompts via `GET /api/triggers/{trigger_name}/prompts`
2. If prompt exists for a given type, populate Monaco Editor with existing template
3. If no prompt exists, start with blank editor (or optional example template)
4. Display last saved timestamp if available
5. User can edit and auto-save updates every 5 seconds

### Tab Icons and Visual Design

**Tab Configuration**:
- **üí∞ Paid**: Blue color (#0d6efd), always visible, default active
- **üÜì Unpaid**: Green color (#198754), optional with checkbox
- **üï∑Ô∏è Crawler**: Orange color (#fd7e14), optional with checkbox

**Active Tab Styling**:
- Blue underline (3px solid) in tab's assigned color
- Bold font weight
- Colored text matching tab color
- Inactive tabs shown in gray (#6c757d)

### Monaco Editor Integration

**Syntax Highlighting Features**:
- Custom language definition for prompt templates
- Placeholder highlighting:
  - `{{section_name}}` - Section placeholders (blue, bold)
  - `{data.field}` - Data field placeholders (blue, bold)
  - `# comments` - Comment lines (green/gray, italic)
- Line numbers enabled
- Search/replace (Ctrl+F, Ctrl+H)
- Undo/redo (Ctrl+Z, Ctrl+Y)
- Code minimap for navigation
- Auto-complete for placeholders (future enhancement)

**Editor Configuration**:
- Height: 500px
- Word wrap: enabled
- Font size: 14px
- Tab size: 2 spaces
- Theme: Auto-detect system preference (light/dark)
- Theme persistence in localStorage

### WorkflowContext Integration

**State Management**:
- Prompt editor state synchronized with WorkflowContext
- Checkbox states (unpaid, crawler) stored in workflow state
- Active tab selection persisted during workflow session
- Auto-save triggered via WorkflowContext debounced updates
- Integration with async job pattern for prompt generation (Story 2.4 v2.0)

**Context Properties**:
```typescript
interface WorkflowContextType {
  // ... existing properties
  promptEditor: {
    activeTab: 'paid' | 'unpaid' | 'crawler';
    enabledTypes: Set<'paid' | 'unpaid' | 'crawler'>;
    prompts: {
      paid: { content: string; lastSaved: Date | null };
      unpaid: { content: string; lastSaved: Date | null };
      crawler: { content: string; lastSaved: Date | null };
    };
    isSaving: boolean;
    lastError: string | null;
  };
  updatePromptContent: (type: string, content: string) => void;
  setActivePromptTab: (type: string) => void;
  togglePromptType: (type: 'unpaid' | 'crawler', enabled: boolean) => void;
}
```

**Auto-Save Behavior**:
1. User edits prompt in Monaco Editor
2. Change triggers debounced update (5 seconds)
3. PromptContext calls `updatePromptContent()` in WorkflowContext
4. WorkflowContext persists to backend via `POST /api/triggers/:id/config/prompts`
5. Visual feedback: "Saving..." indicator, then "Saved X min ago"
6. Errors displayed in Alert component above editor

### Integration with Section Selection (Story 2.5 v2.0)

**Shared Section Configuration**:
- All three prompt types (paid, unpaid, crawler) share the same section configuration
- Section order and visibility from Story 2.5 applies to all prompts
- Placeholders like `{{section_1}}`, `{{section_2}}` reference shared section configuration
- Changing section order updates all prompt templates simultaneously
- Section selection UI displayed above prompt editor (from Story 3.1)

**Placeholder Validation**:
- Validate that placeholders in prompts match available sections
- Warn if placeholder references non-existent section
- Tab indicator shows warning icon if validation errors exist
- Future: Auto-complete suggestions based on available sections

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 3 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |
| 2025-10-30 | 2.0 | Aligned with News CMS Workflow: Added three prompt types (paid/unpaid/crawler), pre-population from GET /api/triggers/{trigger_name}/prompts, tab icons, Monaco Editor integration, WorkflowContext integration, and Story 2.3/2.4/2.5 v2.0 prerequisites | Bob (SM) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Implementation Date

November 3, 2025

### Completion Notes List

1. **Monaco Editor Integration**: Successfully integrated @monaco-editor/react with custom language definition for prompt placeholders
2. **Custom Syntax Highlighting**: Defined `prompt-template` language with regex tokenizers for `{{section_name}}` and `{data.field}` patterns
3. **Auto-Save Implementation**: Used `use-debounce` package for 5-second debounced save to prevent excessive API calls
4. **Context Architecture**: Clean separation with PromptProvider managing all prompt state independently
5. **Theme Support**: Implemented light/dark themes with localStorage persistence and system preference detection
6. **Backend Endpoint**: Created POST /api/triggers/{trigger_name}/config/prompts with version history support
7. **Unicode Fix**: Fixed Windows console encoding issue by replacing emoji characters with [OK]/[ERROR] text
8. **Tab Visibility**: Tabs dynamically show/hide based on checkbox selections with proper context synchronization

### File List

**Frontend Files Created:**
- `frontend/src/contexts/PromptContext.tsx` (191 lines) - Complete prompt state management with auto-save
- `frontend/src/components/config/CharacterCounter.tsx` (44 lines) - Character/word/token counter component
- `frontend/src/components/config/PromptTabs.tsx` (51 lines) - Tab navigation with color-coded indicators
- `frontend/src/components/config/PromptEditor.tsx` (169 lines) - Monaco Editor with syntax highlighting

**Frontend Files Modified:**
- `frontend/src/app/config/[triggerId]/page.tsx` - Added PromptEditorWrapper integration in Prompt Engineering step

**Backend Files Modified:**
- `backend/app/routers/triggers.py` - Added POST /{trigger_name}/config/prompts endpoint (lines 429-528)
- `backend/app/database.py` - Fixed Unicode emoji encoding for Windows console

**Packages Installed:**
- `@monaco-editor/react` - Monaco Editor React wrapper
- `use-debounce` - Debounce hooks for auto-save functionality

## QA Results

*To be filled by QA agent*
