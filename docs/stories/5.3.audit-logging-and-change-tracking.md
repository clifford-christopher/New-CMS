# Story 5.3: Audit Logging and Change Tracking

## Status

Draft

## Story

**As a** compliance officer or system administrator,
**I want** comprehensive audit logs of all configuration changes,
**so that** we can track who made changes, when, and what was changed.

## Acceptance Criteria

1. All configuration changes logged to MongoDB `audit_log` collection with: user_id, action, timestamp, trigger_id, details (JSON diff)
2. Logged actions include: configuration created, updated, published, API added/removed, prompt edited, model changed
3. Backend middleware automatically logs all write operations to configurations
4. Meets FR32, FR33, FR34: logging of changes, tracking production configs, maintaining history
5. Audit log UI accessible from navigation (admin/audit page)
6. Audit log table displays: timestamp, user, trigger, action, details (expandable)
7. Filtering by trigger, user, date range, action type
8. Export audit log to CSV or JSON for compliance reporting
9. Audit logs immutable (no deletion or editing allowed via UI)
10. Meets NFR15: comprehensive audit logs for compliance

## Tasks / Subtasks

- [ ] Task 1: Create audit middleware for automatic logging (AC: 1, 2, 3)
  - [ ] Create backend/app/middleware/audit.py
  - [ ] Implement middleware to intercept write operations
  - [ ] Log actions: created, updated, published, api_added, prompt_edited
  - [ ] Capture user_id, trigger_id, timestamp, details (JSON diff)
  - [ ] Integrate middleware into FastAPI app
- [ ] Task 2: Create AuditService for logging logic (AC: 1, 4)
  - [ ] Create backend/app/services/audit_service.py
  - [ ] Implement create_audit_log method
  - [ ] Implement compute_diff for configuration changes
  - [ ] Store logs in audit_log collection
  - [ ] Ensure logs are immutable
- [ ] Task 3: Create audit log query endpoints (AC: 5, 7)
  - [ ] Create GET /api/audit/logs endpoint with pagination
  - [ ] Implement filtering: trigger_id, user_id, date_range, action
  - [ ] Return audit logs sorted by timestamp (descending)
  - [ ] Add endpoint GET /api/audit/logs/:id for single log details
- [ ] Task 4: Create export endpoints (AC: 8)
  - [ ] Create GET /api/audit/export/csv endpoint
  - [ ] Create GET /api/audit/export/json endpoint
  - [ ] Apply same filters as query endpoint
  - [ ] Return downloadable file
- [ ] Task 5: Create AuditLogTable UI component (AC: 5, 6, 7, 9)
  - [ ] Create frontend/src/components/audit/AuditLogTable.tsx
  - [ ] Display: timestamp, user, trigger, action, details (collapsible)
  - [ ] Implement filters: trigger, user, date range, action type
  - [ ] Add pagination controls
  - [ ] Show expandable details section
  - [ ] No delete/edit buttons (immutable logs)
- [ ] Task 6: Create audit log page (AC: 5)
  - [ ] Create frontend/src/app/audit/page.tsx
  - [ ] Add "Audit Log" link to navigation
  - [ ] Display AuditLogTable component
  - [ ] Add export buttons (CSV, JSON)
  - [ ] Add breadcrumb navigation
- [ ] Task 7: Write unit and integration tests
  - [ ] Test audit middleware
  - [ ] Test AuditService
  - [ ] Test audit log endpoints
  - [ ] Test export functionality
  - [ ] Test AuditLogTable component
  - [ ] Test immutability (no delete/edit)

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 5.2 - Completion]

Before starting this story, ensure Story 5.2 is complete:
- Publish endpoint working
- PublishService creates audit log entries on publish
- AuditLog model defined (from Story 1.2)
- MongoDB audit_log collection exists

[Source: Story 1.2 - AuditLog Model]

The AuditLog model is already defined in Story 1.2:
```python
class AuditLog(BaseModel):
    id: str = Field(alias="_id")
    user_id: str
    action: str
    trigger_id: str
    timestamp: datetime
    details: Dict
```

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Backend Module Structure]

**Backend files to create/modify** in `backend/app/`:
```
backend/app/
├── middleware/
│   └── audit.py                       # Audit middleware (NEW)
├── services/
│   └── audit_service.py               # Audit logging service (NEW)
├── routers/
│   └── audit.py                       # Audit log endpoints (NEW)
└── models/
    └── audit_log.py                   # AuditLog model (existing from Story 1.2)
```

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── audit/
│       ├── AuditLogTable.tsx          # Audit log table (NEW)
│       ├── AuditLogFilters.tsx        # Filter controls (NEW)
│       └── AuditLogDetails.tsx        # Expandable details (NEW)
├── app/
│   └── audit/
│       └── page.tsx                   # Audit log page (NEW)
└── types/
    └── audit.ts                       # TypeScript audit types (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Backend Stack**:
- **FastAPI**: Middleware integration, audit endpoints
- **Pydantic**: Audit log models
- **MongoDB**: Store audit logs in audit_log collection
- **Python difflib**: Compute JSON diffs

**Frontend Stack**:
- **React-Bootstrap**: Table, filters, pagination
- **TypeScript**: Type-safe audit log display
- **date-fns**: Date formatting and filtering

### Audit Middleware Specification

[Source: architecture.md - Epic 5 - Audit Logging]

**File: backend/app/middleware/audit.py** (New)

Complete audit middleware for automatic logging:

```python
from fastapi import Request
from typing import Callable
import logging
import json
from datetime import datetime

logger = logging.getLogger(__name__)

class AuditMiddleware:
    """
    Middleware to automatically log all write operations to configurations.
    Intercepts POST, PUT, PATCH, DELETE requests and logs to audit_log.
    """

    def __init__(self, app):
        self.app = app

    async def __call__(self, scope, receive, send):
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return

        request = Request(scope, receive)

        # Only log write operations
        if request.method in ["POST", "PUT", "PATCH", "DELETE"]:
            # Check if request is for configuration endpoints
            if "/api/triggers/" in str(request.url):
                await self._log_request(request)

        await self.app(scope, receive, send)

    async def _log_request(self, request: Request):
        """Log the request to audit log"""
        try:
            # Extract trigger_id from URL
            path_parts = str(request.url.path).split("/")
            trigger_id = None

            if "triggers" in path_parts:
                trigger_idx = path_parts.index("triggers")
                if trigger_idx + 1 < len(path_parts):
                    trigger_id = path_parts[trigger_idx + 1]

            # Determine action from method and path
            action = self._determine_action(request.method, str(request.url.path))

            # Get user_id (from auth - for now use system)
            user_id = "system"  # TODO: Get from authenticated user

            # Get request body (if available)
            body = await request.body()
            details = {}

            if body:
                try:
                    details = json.loads(body.decode())
                except:
                    details = {"raw_body": body.decode()}

            # Log to audit service
            from ..services.audit_service import AuditService
            from ..database import get_database

            db = get_database()
            if db and trigger_id:
                audit_service = AuditService(db)
                await audit_service.create_audit_log(
                    user_id=user_id,
                    action=action,
                    trigger_id=trigger_id,
                    details=details
                )

        except Exception as e:
            logger.error(f"Failed to log audit entry: {e}")
            # Don't fail the request if logging fails

    def _determine_action(self, method: str, path: str) -> str:
        """Determine action type from HTTP method and path"""
        if "publish" in path:
            return "published"
        elif "apis" in path and method == "POST":
            return "api_added"
        elif "apis" in path and method == "DELETE":
            return "api_removed"
        elif "prompt" in path or "config" in path:
            if method == "POST":
                return "created"
            elif method in ["PUT", "PATCH"]:
                return "prompt_edited"
        elif method == "POST":
            return "created"
        elif method in ["PUT", "PATCH"]:
            return "updated"
        elif method == "DELETE":
            return "deleted"

        return "unknown"
```

**Integration in backend/app/main.py**:

```python
from fastapi import FastAPI
from .middleware.audit import AuditMiddleware

app = FastAPI(title="News CMS API", version="1.0.0")

# Add audit middleware
app.add_middleware(AuditMiddleware)
```

### Audit Service Specification

[Source: architecture.md - Epic 5 - Audit Logging]

**File: backend/app/services/audit_service.py** (New)

Complete audit service with diff computation:

```python
from typing import Dict, List, Optional, Any
from datetime import datetime
from motor.motor_asyncio import AsyncIOMotorDatabase
import logging
import json

logger = logging.getLogger(__name__)

class AuditService:
    """Service for creating and managing audit logs"""

    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db

    async def create_audit_log(
        self,
        user_id: str,
        action: str,
        trigger_id: str,
        details: Dict
    ) -> str:
        """
        Create audit log entry

        Args:
            user_id: User performing the action
            action: Action type (created, updated, published, etc.)
            trigger_id: Trigger ID affected
            details: Additional details about the action

        Returns:
            Audit log ID
        """
        audit_entry = {
            "user_id": user_id,
            "action": action,
            "trigger_id": trigger_id,
            "timestamp": datetime.utcnow(),
            "details": details
        }

        result = await self.db.audit_log.insert_one(audit_entry)

        logger.info(
            f"Audit log created: action={action}, trigger={trigger_id}, "
            f"user={user_id}, id={result.inserted_id}"
        )

        return str(result.inserted_id)

    async def get_audit_logs(
        self,
        trigger_id: Optional[str] = None,
        user_id: Optional[str] = None,
        action: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        limit: int = 100,
        skip: int = 0
    ) -> List[Dict]:
        """
        Query audit logs with filtering and pagination

        Args:
            trigger_id: Filter by trigger ID
            user_id: Filter by user ID
            action: Filter by action type
            start_date: Filter by start date
            end_date: Filter by end date
            limit: Max number of results
            skip: Number of results to skip (for pagination)

        Returns:
            List of audit log entries
        """
        query = {}

        if trigger_id:
            query["trigger_id"] = trigger_id

        if user_id:
            query["user_id"] = user_id

        if action:
            query["action"] = action

        if start_date or end_date:
            query["timestamp"] = {}
            if start_date:
                query["timestamp"]["$gte"] = start_date
            if end_date:
                query["timestamp"]["$lte"] = end_date

        cursor = self.db.audit_log.find(query).sort(
            "timestamp", -1
        ).skip(skip).limit(limit)

        logs = await cursor.to_list(length=limit)

        # Convert ObjectId to string
        for log in logs:
            log["_id"] = str(log["_id"])

        return logs

    async def get_audit_log_count(
        self,
        trigger_id: Optional[str] = None,
        user_id: Optional[str] = None,
        action: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> int:
        """Get total count of audit logs matching filters"""
        query = {}

        if trigger_id:
            query["trigger_id"] = trigger_id
        if user_id:
            query["user_id"] = user_id
        if action:
            query["action"] = action
        if start_date or end_date:
            query["timestamp"] = {}
            if start_date:
                query["timestamp"]["$gte"] = start_date
            if end_date:
                query["timestamp"]["$lte"] = end_date

        return await self.db.audit_log.count_documents(query)

    @staticmethod
    def compute_diff(old_value: Any, new_value: Any) -> Dict:
        """
        Compute diff between old and new values

        Args:
            old_value: Previous value
            new_value: New value

        Returns:
            Diff structure with changes
        """
        if old_value == new_value:
            return {"changed": False}

        diff = {
            "changed": True,
            "old": old_value,
            "new": new_value
        }

        # If both are dicts, compute detailed diff
        if isinstance(old_value, dict) and isinstance(new_value, dict):
            added_keys = set(new_value.keys()) - set(old_value.keys())
            removed_keys = set(old_value.keys()) - set(new_value.keys())
            common_keys = set(old_value.keys()) & set(new_value.keys())

            changed_keys = {
                k for k in common_keys
                if old_value[k] != new_value[k]
            }

            diff["added_keys"] = list(added_keys)
            diff["removed_keys"] = list(removed_keys)
            diff["changed_keys"] = list(changed_keys)

        return diff
```

### Audit Endpoints Specification

[Source: architecture.md - Epic 5 - Audit Logging]

**File: backend/app/routers/audit.py** (New)

Complete audit log endpoints with filtering and export:

```python
from fastapi import APIRouter, HTTPException, Depends, Query
from fastapi.responses import StreamingResponse
from datetime import datetime
from typing import Optional
from ..database import get_database
from ..services.audit_service import AuditService
import logging
import csv
import json
import io

router = APIRouter(prefix="/api/audit", tags=["audit"])
logger = logging.getLogger(__name__)

@router.get("/logs")
async def get_audit_logs(
    trigger_id: Optional[str] = Query(None),
    user_id: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    start_date: Optional[str] = Query(None),
    end_date: Optional[str] = Query(None),
    limit: int = Query(100, le=1000),
    skip: int = Query(0),
    db = Depends(get_database)
):
    """
    Get audit logs with filtering and pagination.
    Supports filtering by trigger, user, action, and date range.
    """
    service = AuditService(db)

    try:
        # Parse dates if provided
        start_dt = datetime.fromisoformat(start_date) if start_date else None
        end_dt = datetime.fromisoformat(end_date) if end_date else None

        logs = await service.get_audit_logs(
            trigger_id=trigger_id,
            user_id=user_id,
            action=action,
            start_date=start_dt,
            end_date=end_dt,
            limit=limit,
            skip=skip
        )

        total = await service.get_audit_log_count(
            trigger_id=trigger_id,
            user_id=user_id,
            action=action,
            start_date=start_dt,
            end_date=end_dt
        )

        return {
            "success": True,
            "logs": logs,
            "total": total,
            "limit": limit,
            "skip": skip
        }

    except Exception as e:
        logger.error(f"Failed to retrieve audit logs: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/logs/{log_id}")
async def get_audit_log(
    log_id: str,
    db = Depends(get_database)
):
    """Get single audit log entry by ID"""
    try:
        from bson.objectid import ObjectId

        log = await db.audit_log.find_one({"_id": ObjectId(log_id)})

        if not log:
            raise HTTPException(status_code=404, detail="Audit log not found")

        log["_id"] = str(log["_id"])

        return {
            "success": True,
            "log": log
        }

    except Exception as e:
        logger.error(f"Failed to retrieve audit log: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/export/csv")
async def export_audit_logs_csv(
    trigger_id: Optional[str] = Query(None),
    user_id: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    start_date: Optional[str] = Query(None),
    end_date: Optional[str] = Query(None),
    db = Depends(get_database)
):
    """
    Export audit logs to CSV format.
    Applies same filters as get_audit_logs endpoint.
    """
    service = AuditService(db)

    try:
        # Parse dates if provided
        start_dt = datetime.fromisoformat(start_date) if start_date else None
        end_dt = datetime.fromisoformat(end_date) if end_date else None

        logs = await service.get_audit_logs(
            trigger_id=trigger_id,
            user_id=user_id,
            action=action,
            start_date=start_dt,
            end_date=end_dt,
            limit=10000  # High limit for export
        )

        # Create CSV
        output = io.StringIO()
        writer = csv.writer(output)

        # Header
        writer.writerow([
            "ID", "Timestamp", "User ID", "Trigger ID",
            "Action", "Details"
        ])

        # Data rows
        for log in logs:
            writer.writerow([
                log["_id"],
                log["timestamp"].isoformat(),
                log["user_id"],
                log["trigger_id"],
                log["action"],
                json.dumps(log.get("details", {}))
            ])

        output.seek(0)

        return StreamingResponse(
            iter([output.getvalue()]),
            media_type="text/csv",
            headers={
                "Content-Disposition": f"attachment; filename=audit_logs_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
            }
        )

    except Exception as e:
        logger.error(f"Failed to export audit logs to CSV: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/export/json")
async def export_audit_logs_json(
    trigger_id: Optional[str] = Query(None),
    user_id: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    start_date: Optional[str] = Query(None),
    end_date: Optional[str] = Query(None),
    db = Depends(get_database)
):
    """
    Export audit logs to JSON format.
    Applies same filters as get_audit_logs endpoint.
    """
    service = AuditService(db)

    try:
        # Parse dates if provided
        start_dt = datetime.fromisoformat(start_date) if start_date else None
        end_dt = datetime.fromisoformat(end_date) if end_date else None

        logs = await service.get_audit_logs(
            trigger_id=trigger_id,
            user_id=user_id,
            action=action,
            start_date=start_dt,
            end_date=end_dt,
            limit=10000  # High limit for export
        )

        # Convert timestamps to ISO format for JSON
        for log in logs:
            log["timestamp"] = log["timestamp"].isoformat()

        json_content = json.dumps({"audit_logs": logs}, indent=2)

        return StreamingResponse(
            iter([json_content]),
            media_type="application/json",
            headers={
                "Content-Disposition": f"attachment; filename=audit_logs_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
            }
        )

    except Exception as e:
        logger.error(f"Failed to export audit logs to JSON: {e}")
        raise HTTPException(status_code=400, detail=str(e))
```

### Frontend Component Specifications

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/components/audit/AuditLogTable.tsx** (New)

Complete audit log table with filtering:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Table, Card, Badge, Button, Collapse, Spinner, Pagination } from 'react-bootstrap';
import AuditLogFilters from './AuditLogFilters';

interface AuditLog {
  _id: string;
  timestamp: string;
  user_id: string;
  trigger_id: string;
  action: string;
  details: Record<string, any>;
}

interface AuditLogTableProps {
  onExportCSV: () => void;
  onExportJSON: () => void;
}

export default function AuditLogTable({ onExportCSV, onExportJSON }: AuditLogTableProps) {
  const [logs, setLogs] = useState<AuditLog[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [expandedLogId, setExpandedLogId] = useState<string | null>(null);

  // Pagination
  const [total, setTotal] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const limit = 50;

  // Filters
  const [filters, setFilters] = useState({
    trigger_id: '',
    user_id: '',
    action: '',
    start_date: '',
    end_date: ''
  });

  useEffect(() => {
    fetchLogs();
  }, [currentPage, filters]);

  const fetchLogs = async () => {
    try {
      setLoading(true);
      setError(null);

      const params = new URLSearchParams({
        limit: limit.toString(),
        skip: ((currentPage - 1) * limit).toString()
      });

      // Add filters if set
      if (filters.trigger_id) params.append('trigger_id', filters.trigger_id);
      if (filters.user_id) params.append('user_id', filters.user_id);
      if (filters.action) params.append('action', filters.action);
      if (filters.start_date) params.append('start_date', filters.start_date);
      if (filters.end_date) params.append('end_date', filters.end_date);

      const response = await fetch(`/api/audit/logs?${params}`);

      if (!response.ok) {
        throw new Error('Failed to fetch audit logs');
      }

      const data = await response.json();
      setLogs(data.logs);
      setTotal(data.total);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch logs');
    } finally {
      setLoading(false);
    }
  };

  const handleFilterChange = (newFilters: typeof filters) => {
    setFilters(newFilters);
    setCurrentPage(1); // Reset to first page
  };

  const toggleDetails = (logId: string) => {
    setExpandedLogId(expandedLogId === logId ? null : logId);
  };

  const getActionBadge = (action: string) => {
    const variants: Record<string, string> = {
      created: 'success',
      updated: 'info',
      published: 'primary',
      deleted: 'danger',
      api_added: 'secondary',
      api_removed: 'warning',
      prompt_edited: 'info'
    };

    return (
      <Badge bg={variants[action] || 'secondary'}>
        {action.replace('_', ' ').toUpperCase()}
      </Badge>
    );
  };

  const formatTimestamp = (timestamp: string) => {
    return new Date(timestamp).toLocaleString();
  };

  const totalPages = Math.ceil(total / limit);

  return (
    <Card>
      <Card.Header>
        <div className="d-flex justify-content-between align-items-center">
          <h5 className="mb-0">Audit Logs ({total} total)</h5>
          <div>
            <Button variant="outline-primary" size="sm" className="me-2" onClick={onExportCSV}>
              Export CSV
            </Button>
            <Button variant="outline-primary" size="sm" onClick={onExportJSON}>
              Export JSON
            </Button>
          </div>
        </div>
      </Card.Header>

      <Card.Body>
        <AuditLogFilters filters={filters} onFilterChange={handleFilterChange} />

        {loading && (
          <div className="text-center py-4">
            <Spinner animation="border" />
          </div>
        )}

        {error && (
          <div className="alert alert-danger">{error}</div>
        )}

        {!loading && !error && logs.length === 0 && (
          <div className="text-center py-4 text-muted">
            No audit logs found matching the current filters.
          </div>
        )}

        {!loading && !error && logs.length > 0 && (
          <>
            <Table hover responsive>
              <thead>
                <tr>
                  <th>Timestamp</th>
                  <th>User</th>
                  <th>Trigger</th>
                  <th>Action</th>
                  <th>Details</th>
                </tr>
              </thead>
              <tbody>
                {logs.map((log) => (
                  <>
                    <tr key={log._id}>
                      <td>{formatTimestamp(log.timestamp)}</td>
                      <td>
                        <code>{log.user_id}</code>
                      </td>
                      <td>
                        <code>{log.trigger_id}</code>
                      </td>
                      <td>{getActionBadge(log.action)}</td>
                      <td>
                        <Button
                          variant="link"
                          size="sm"
                          onClick={() => toggleDetails(log._id)}
                        >
                          {expandedLogId === log._id ? 'Hide' : 'Show'} Details
                        </Button>
                      </td>
                    </tr>
                    <tr>
                      <td colSpan={5} className="p-0 border-0">
                        <Collapse in={expandedLogId === log._id}>
                          <div className="p-3 bg-light">
                            <strong>Details:</strong>
                            <pre className="mt-2 mb-0" style={{ fontSize: '0.85rem' }}>
                              {JSON.stringify(log.details, null, 2)}
                            </pre>
                          </div>
                        </Collapse>
                      </td>
                    </tr>
                  </>
                ))}
              </tbody>
            </Table>

            {totalPages > 1 && (
              <div className="d-flex justify-content-center mt-3">
                <Pagination>
                  <Pagination.First
                    onClick={() => setCurrentPage(1)}
                    disabled={currentPage === 1}
                  />
                  <Pagination.Prev
                    onClick={() => setCurrentPage(currentPage - 1)}
                    disabled={currentPage === 1}
                  />

                  {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                    const page = i + 1;
                    return (
                      <Pagination.Item
                        key={page}
                        active={page === currentPage}
                        onClick={() => setCurrentPage(page)}
                      >
                        {page}
                      </Pagination.Item>
                    );
                  })}

                  <Pagination.Next
                    onClick={() => setCurrentPage(currentPage + 1)}
                    disabled={currentPage === totalPages}
                  />
                  <Pagination.Last
                    onClick={() => setCurrentPage(totalPages)}
                    disabled={currentPage === totalPages}
                  />
                </Pagination>
              </div>
            )}
          </>
        )}
      </Card.Body>
    </Card>
  );
}
```

**File: frontend/src/components/audit/AuditLogFilters.tsx** (New)

Filter controls for audit logs:

```typescript
'use client';

import { Form, Row, Col, Button } from 'react-bootstrap';

interface Filters {
  trigger_id: string;
  user_id: string;
  action: string;
  start_date: string;
  end_date: string;
}

interface AuditLogFiltersProps {
  filters: Filters;
  onFilterChange: (filters: Filters) => void;
}

export default function AuditLogFilters({ filters, onFilterChange }: AuditLogFiltersProps) {
  const handleChange = (field: keyof Filters, value: string) => {
    onFilterChange({
      ...filters,
      [field]: value
    });
  };

  const handleReset = () => {
    onFilterChange({
      trigger_id: '',
      user_id: '',
      action: '',
      start_date: '',
      end_date: ''
    });
  };

  const actions = [
    'created',
    'updated',
    'published',
    'deleted',
    'api_added',
    'api_removed',
    'prompt_edited'
  ];

  return (
    <Form className="mb-4 p-3 bg-light rounded">
      <h6 className="mb-3">Filters</h6>
      <Row>
        <Col md={3}>
          <Form.Group className="mb-3">
            <Form.Label>Trigger ID</Form.Label>
            <Form.Control
              type="text"
              placeholder="Filter by trigger..."
              value={filters.trigger_id}
              onChange={(e) => handleChange('trigger_id', e.target.value)}
            />
          </Form.Group>
        </Col>
        <Col md={3}>
          <Form.Group className="mb-3">
            <Form.Label>User ID</Form.Label>
            <Form.Control
              type="text"
              placeholder="Filter by user..."
              value={filters.user_id}
              onChange={(e) => handleChange('user_id', e.target.value)}
            />
          </Form.Group>
        </Col>
        <Col md={3}>
          <Form.Group className="mb-3">
            <Form.Label>Action</Form.Label>
            <Form.Select
              value={filters.action}
              onChange={(e) => handleChange('action', e.target.value)}
            >
              <option value="">All Actions</option>
              {actions.map((action) => (
                <option key={action} value={action}>
                  {action.replace('_', ' ').toUpperCase()}
                </option>
              ))}
            </Form.Select>
          </Form.Group>
        </Col>
        <Col md={3}>
          <Form.Group className="mb-3">
            <Form.Label>Date Range</Form.Label>
            <div className="d-flex gap-2">
              <Form.Control
                type="date"
                value={filters.start_date}
                onChange={(e) => handleChange('start_date', e.target.value)}
              />
              <Form.Control
                type="date"
                value={filters.end_date}
                onChange={(e) => handleChange('end_date', e.target.value)}
              />
            </div>
          </Form.Group>
        </Col>
      </Row>
      <Button variant="secondary" size="sm" onClick={handleReset}>
        Reset Filters
      </Button>
    </Form>
  );
}
```

**File: frontend/src/app/audit/page.tsx** (New)

Audit log page:

```typescript
'use client';

import { Container, Row, Col, Breadcrumb } from 'react-bootstrap';
import AuditLogTable from '@/components/audit/AuditLogTable';

export default function AuditLogPage() {
  const handleExportCSV = async () => {
    try {
      const response = await fetch('/api/audit/export/csv');
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audit_logs_${new Date().toISOString()}.csv`;
      a.click();
    } catch (error) {
      console.error('Failed to export CSV:', error);
    }
  };

  const handleExportJSON = async () => {
    try {
      const response = await fetch('/api/audit/export/json');
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audit_logs_${new Date().toISOString()}.json`;
      a.click();
    } catch (error) {
      console.error('Failed to export JSON:', error);
    }
  };

  return (
    <Container fluid className="py-4">
      <Row>
        <Col>
          <Breadcrumb>
            <Breadcrumb.Item href="/">Dashboard</Breadcrumb.Item>
            <Breadcrumb.Item active>Audit Log</Breadcrumb.Item>
          </Breadcrumb>

          <h2 className="mb-4">Audit Log</h2>
          <p className="text-muted mb-4">
            Comprehensive audit trail of all configuration changes for compliance tracking.
            Logs are immutable and cannot be edited or deleted.
          </p>

          <AuditLogTable
            onExportCSV={handleExportCSV}
            onExportJSON={handleExportJSON}
          />
        </Col>
      </Row>
    </Container>
  );
}
```

### Implementation Notes

[Source: PRD - Epic 5: Configuration Publishing & Production Integration]

**Important Design Decisions**:

1. **Automatic Logging**: Middleware intercepts all write operations to configuration endpoints and automatically creates audit log entries.

2. **Immutable Logs**: Audit logs cannot be deleted or edited via UI. Only read and export operations allowed.

3. **Comprehensive Actions**: Logs capture all action types: created, updated, published, api_added, api_removed, prompt_edited, model_changed.

4. **JSON Diff Details**: Each log entry includes detailed JSON diff in the `details` field showing what changed.

5. **Filtering & Pagination**: UI supports filtering by trigger, user, action, date range with pagination for large result sets.

6. **Export Compliance**: Export to CSV/JSON for compliance reporting and external analysis.

7. **No Middleware Performance Impact**: Logging is asynchronous and errors in logging don't fail the main request.

8. **Expandable Details**: UI shows summary in table, expandable section shows full JSON details.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 5.3**:

**Unit Tests** (backend/tests/test_audit_service.py):

```python
import pytest
from app.services.audit_service import AuditService
from datetime import datetime

@pytest.mark.asyncio
async def test_create_audit_log(db):
    """Test creating audit log entry"""
    service = AuditService(db)

    log_id = await service.create_audit_log(
        user_id="user_001",
        action="published",
        trigger_id="trigger_001",
        details={"version": 2, "prompt_types": ["paid", "unpaid", "crawler"]}
    )

    assert log_id is not None

    # Verify log was created
    log = await db.audit_log.find_one({"trigger_id": "trigger_001"})
    assert log is not None
    assert log["action"] == "published"
    assert log["user_id"] == "user_001"

@pytest.mark.asyncio
async def test_get_audit_logs_with_filters(db):
    """Test querying audit logs with filters"""
    service = AuditService(db)

    # Create test logs
    await service.create_audit_log("user_001", "created", "trigger_001", {})
    await service.create_audit_log("user_002", "updated", "trigger_001", {})
    await service.create_audit_log("user_001", "published", "trigger_002", {})

    # Query by trigger
    logs = await service.get_audit_logs(trigger_id="trigger_001")
    assert len(logs) == 2

    # Query by user
    logs = await service.get_audit_logs(user_id="user_001")
    assert len(logs) == 2

    # Query by action
    logs = await service.get_audit_logs(action="published")
    assert len(logs) == 1

@pytest.mark.asyncio
async def test_get_audit_logs_pagination(db):
    """Test pagination of audit logs"""
    service = AuditService(db)

    # Create 10 test logs
    for i in range(10):
        await service.create_audit_log(
            "user_001", "created", f"trigger_{i:03d}", {}
        )

    # First page
    logs = await service.get_audit_logs(limit=5, skip=0)
    assert len(logs) == 5

    # Second page
    logs = await service.get_audit_logs(limit=5, skip=5)
    assert len(logs) == 5

@pytest.mark.asyncio
async def test_compute_diff(db):
    """Test diff computation"""
    service = AuditService(db)

    old_value = {"prompt": "old", "models": ["gpt-4"]}
    new_value = {"prompt": "new", "models": ["gpt-4", "claude-3"]}

    diff = service.compute_diff(old_value, new_value)

    assert diff["changed"] is True
    assert "changed_keys" in diff
    assert "prompt" in diff["changed_keys"]
```

**Integration Tests** (backend/tests/test_audit_endpoints.py):

```python
import pytest
from fastapi.testclient import TestClient

@pytest.mark.asyncio
async def test_get_audit_logs_endpoint(client: TestClient, db):
    """Test GET /api/audit/logs endpoint"""
    # Create test log
    await db.audit_log.insert_one({
        "user_id": "user_001",
        "action": "published",
        "trigger_id": "trigger_001",
        "timestamp": datetime.utcnow(),
        "details": {}
    })

    response = client.get("/api/audit/logs")
    assert response.status_code == 200

    data = response.json()
    assert "logs" in data
    assert "total" in data
    assert len(data["logs"]) > 0

@pytest.mark.asyncio
async def test_export_csv_endpoint(client: TestClient, db):
    """Test CSV export endpoint"""
    # Create test logs
    await db.audit_log.insert_one({
        "user_id": "user_001",
        "action": "published",
        "trigger_id": "trigger_001",
        "timestamp": datetime.utcnow(),
        "details": {}
    })

    response = client.get("/api/audit/export/csv")
    assert response.status_code == 200
    assert response.headers["content-type"] == "text/csv; charset=utf-8"

@pytest.mark.asyncio
async def test_export_json_endpoint(client: TestClient, db):
    """Test JSON export endpoint"""
    response = client.get("/api/audit/export/json")
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/json"
```

**Frontend Tests** (frontend/__tests__/components/audit/):

```typescript
// AuditLogTable.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import AuditLogTable from '@/components/audit/AuditLogTable';

describe('AuditLogTable Component', () => {
  beforeEach(() => {
    global.fetch = jest.fn();
  });

  test('renders audit logs table', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => ({
        logs: [
          {
            _id: '1',
            timestamp: '2025-10-29T10:00:00Z',
            user_id: 'user_001',
            trigger_id: 'trigger_001',
            action: 'published',
            details: {}
          }
        ],
        total: 1
      })
    });

    render(<AuditLogTable onExportCSV={jest.fn()} onExportJSON={jest.fn()} />);

    await waitFor(() => {
      expect(screen.getByText(/user_001/)).toBeInTheDocument();
      expect(screen.getByText(/PUBLISHED/)).toBeInTheDocument();
    });
  });

  test('expands log details on click', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => ({
        logs: [
          {
            _id: '1',
            timestamp: '2025-10-29T10:00:00Z',
            user_id: 'user_001',
            trigger_id: 'trigger_001',
            action: 'published',
            details: { version: 2 }
          }
        ],
        total: 1
      })
    });

    render(<AuditLogTable onExportCSV={jest.fn()} onExportJSON={jest.fn()} />);

    await waitFor(() => {
      const showButton = screen.getByText('Show Details');
      fireEvent.click(showButton);
    });

    await waitFor(() => {
      expect(screen.getByText(/version/)).toBeInTheDocument();
    });
  });

  test('no delete or edit buttons visible', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => ({
        logs: [
          {
            _id: '1',
            timestamp: '2025-10-29T10:00:00Z',
            user_id: 'user_001',
            trigger_id: 'trigger_001',
            action: 'published',
            details: {}
          }
        ],
        total: 1
      })
    });

    render(<AuditLogTable onExportCSV={jest.fn()} onExportJSON={jest.fn()} />);

    await waitFor(() => {
      expect(screen.queryByText(/delete/i)).not.toBeInTheDocument();
      expect(screen.queryByText(/edit/i)).not.toBeInTheDocument();
    });
  });
});
```

**Manual Verification**:
1. Middleware automatically logs configuration changes
2. Audit log page accessible from navigation
3. Table displays: timestamp, user, trigger, action, details
4. Filters work: trigger, user, action, date range
5. Pagination controls work for large result sets
6. Details expand/collapse on click
7. Export CSV downloads file with correct data
8. Export JSON downloads file with correct data
9. No delete or edit buttons visible (immutable logs)
10. Logs persist across application restarts
11. No console errors
12. Performance acceptable with 1000+ logs

**Coverage Target**: 70%+ for audit service and endpoints

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 5 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context, audit middleware, AuditService, comprehensive endpoints with export, AuditLogTable UI component, and testing standards | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
