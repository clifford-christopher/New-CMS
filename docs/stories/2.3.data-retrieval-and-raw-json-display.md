# Story 2.3: Data Retrieval and Data Mode Selection

## Status

✅ **Implemented** - Updated for Data Configuration Workflow v2.3 (November 2025)

## Story

**As a** content manager,
**I want** to select data mode (OLD/NEW/OLD_NEW) and fetch trigger data for a specific stockid,
**so that** I can choose between existing trigger data, newly generated structured data, or a combination of both.

**Workflow Context (v2.3)**:
- **Data Configuration Tab**: Fetch/generate data → After data loads, **section selection UI appears** → "Use This Data" button
- **Section Management Tab**: Receives selected sections → Reorder with drag-and-drop

## Acceptance Criteria

1. Data configuration page includes stockid input field (positive integer validation)
2. Data mode selection with radio buttons: OLD only | NEW only | OLD + NEW
3. Backend endpoint `GET /api/stocks/{stockid}/trigger-data?trigger_name={trigger_name}` fetches OLD data from news_triggers collection
4. Backend endpoint `GET /api/triggers/{trigger_name}/prompts` fetches existing prompts for pre-population
5. **Updated**: After data fetch/generation completes, section selection UI appears (see Story 2.5):
   - OLD mode: Shows data preview + "Use This Data" button (no selection needed)
   - NEW mode: Shows all 14 sections with checkboxes + "Use This Data (X sections)" button
   - OLD_NEW mode: Shows OLD preview + NEW sections with checkboxes + "Use This Data (OLD + X sections)" button
6. If NEW or OLD_NEW mode selected: "Generate Complete Report" button calls Story 2.4 (generates all 14 sections)
7. stockid parameter is required and validated (must be positive integer >0)
8. **Updated**: Frontend caches generated data by stockid in sessionStorage/localStorage to avoid regeneration
9. Response time meets NFR2: completes within 5 seconds for OLD data, 8-15 seconds for NEW generation
10. Frontend displays OLD data using OldDataDisplay component (collapsible JSON viewer with syntax highlighting)
11. Frontend displays NEW data using NewDataDisplay component (section cards with checkboxes, expand/collapse)
12. "Fetch Existing Prompts" button loads prompts from trigger_prompts collection for pre-population
13. Error handling: 404 if stockid not found, 400 if invalid stockid format, timeout for generation
14. Meets FR6, FR7, FR11: organized display with status indicators and section selection

## Tasks / Subtasks

- [ ] Task 1: Create Trigger Data API endpoint (AC: 3, 7, 8, 9, 12)
  - [ ] Create `GET /api/triggers/{trigger_name}/data?stockid={stockid}` endpoint in routers/triggers.py
  - [ ] Query news_triggers collection: `{"trigger_name": [trigger_name], "stockid": stockid}`
  - [ ] Return OLD data with metadata (last_updated, data_source)
  - [ ] Validate stockid parameter (positive integer, required)
  - [ ] Set no-cache headers (Cache-Control: no-cache)
  - [ ] Handle 404 error if stockid not found
  - [ ] Handle 400 error if stockid invalid format
  - [ ] Meet NFR2: complete within 5 seconds
- [ ] Task 2: Create Prompts API endpoint (AC: 4, 11)
  - [ ] Create `GET /api/triggers/{trigger_name}/prompts` endpoint
  - [ ] Query trigger_prompts collection
  - [ ] Return existing prompts (paid/unpaid/crawler) if configured
  - [ ] Return empty prompts object if none configured (not 404)
  - [ ] Allow 5-minute cache TTL (prompts are static until updated)
- [ ] Task 3: Create frontend data mode selection UI (AC: 1, 2, 5, 6)
  - [ ] Add stockid number input field with validation
  - [ ] Add radio buttons: OLD only | NEW only | OLD + NEW
  - [ ] If OLD selected: Show OLD data preview, hide section generation
  - [ ] If NEW or OLD_NEW selected: Enable "Generate Sections" button
  - [ ] Store data_mode selection in WorkflowContext
- [ ] Task 4: Create OLD data display component (AC: 10, 13)
  - [ ] Create OldDataDisplay component with collapsible JSON viewer
  - [ ] Implement JSON syntax highlighting (react-json-view)
  - [ ] Display data source label: "Existing Trigger Data (news_triggers)"
  - [ ] Add expand/collapse for nested objects
  - [ ] Show timestamp and stockid
- [ ] Task 5: Implement "Fetch Existing Prompts" functionality (AC: 11)
  - [ ] Add "Fetch Existing Prompts" button
  - [ ] Call `GET /api/triggers/{trigger_name}/prompts`
  - [ ] Pre-populate Monaco editors with existing prompts (Story 3.2)
  - [ ] Store in WorkflowContext for later use
- [ ] Task 6: Add error handling and validation (AC: 12)
  - [ ] Display 404 error: "No data found for trigger '{name}' with stockid {id}"
  - [ ] Display 400 error for invalid stockid format
  - [ ] Show warning if OLD mode selected but no data exists
  - [ ] Validate stockid is positive integer before API call
- [ ] Task 7: Write unit and integration tests
  - [ ] Test `GET /api/triggers/{trigger_name}/data?stockid={stockid}` endpoint
  - [ ] Test stockid validation (positive integer, required)
  - [ ] Test 404 error when stockid not found
  - [ ] Test 400 error with invalid stockid
  - [ ] Test prompts endpoint with existing and non-existent configs
  - [ ] Test data mode selection UI (radio buttons)
  - [ ] Test conditional UI display (OLD vs NEW/OLD_NEW modes)

## Dev Notes

### News CMS Workflow Updates

[Source: docs/NEWS-CMS-WORKFLOW-STORY-UPDATES.md - Story 2.3 Updates]

This story has been **significantly updated** for News CMS Workflow Feature:

**Major Changes**:
1. **stockid Parameter Required**: Changed from `POST /api/triggers/:id/data/fetch` to `GET /api/triggers/{trigger_name}/data?stockid={stockid}`
2. **Data Modes**: Added OLD/NEW/OLD_NEW selection (replaces generic API fetching)
3. **OLD Data Source**: Fetch from `news_triggers` collection (existing trigger data) instead of external APIs
4. **NEW Data Source**: Calls Story 2.4 (`generate_full_report.py`) for structured data generation
5. **No Caching**: Data changes during market hours, always fetch fresh
6. **Pre-population**: Added prompts fetch endpoint for pre-populating Monaco editors

**Data Mode Logic**:
- **OLD Mode**: Fetch existing data from `news_triggers.data`, display preview, skip section generation
- **NEW Mode**: Generate 14 sections via `generate_full_report.py` (Story 2.4), allow section selection
- **OLD_NEW Mode**: Fetch OLD data + Generate NEW sections, merge happens at generation time (Story 4.3)

**Removed Features** (from original story):
- Generic API adapters (EarningsAPIAdapter, PriceDataAPIAdapter) - replaced with single structured data service
- Parallel API fetching from multiple financial data sources
- Section-to-API mapping

**Key Architectural Decisions**:
- stockid must be positive integer (validated at API level with Pydantic)
- No caching for `news_triggers` data (market hours sensitivity 9:15 AM - 3:30 PM IST)
- Prompts endpoint can cache (5-min TTL) since prompts are static until manually updated

### Prerequisites from Previous Stories

[Source: Story 1.4 - Database Schema Updates]

Before starting this story, ensure the following stories are complete:
- **Story 1.4**: Database schema extended with isActive, model_config, data_config, prompts fields
- **Story 1.2**: MongoDB collections (news_triggers, trigger_prompts) exist with proper indexes
- **Story 1.3**: Basic UI Shell with navigation available
- WorkflowContext created for storing trigger_name, stockid, data_mode, OLD data, existing prompts

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization]

**Backend files to create** in `backend/app/`:
```
backend/app/
├── routers/
│   └── triggers.py                     # Trigger data and prompts endpoints (NEW)
├── models/
│   └── trigger.py                      # Pydantic models for TriggerDataResponse, PromptsResponse (NEW)
```

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── config/
│       ├── DataConfiguration.tsx       # Update: Add data mode selection, stockid input (MODIFY)
│       └── DataModeSelector.tsx        # Radio buttons for OLD/NEW/OLD_NEW (NEW)
├── lib/
│   └── api.ts                          # Update: Add getTriggerData, getTriggerPrompts API calls (MODIFY)
└── types/
    └── trigger.ts                      # TypeScript types for TriggerDataResponse, PromptsResponse (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Backend Stack**:
- **FastAPI**: Async endpoints for data retrieval
- **Motor**: Async MongoDB driver for querying news_triggers and trigger_prompts collections
- **Pydantic**: Data validation and response models

**Frontend Stack**:
- **Next.js**: 14+ with App Router
- **React-Bootstrap**: Form components (Radio, Form.Control for stockid input), Accordion, Card
- **TypeScript**: Type safety for TriggerDataResponse, PromptsResponse
- **WorkflowContext**: React Context for sharing data_mode and stockid across components

### Backend API Specification (Updated for News CMS Workflow)

[Source: docs/architecture/news-cms-workflow.md - API Endpoints Summary]

**NEW API Endpoints** (replacing deprecated POST endpoint):

#### 1. GET /api/triggers/{trigger_name}/data?stockid={stockid}

Fetches OLD data from news_triggers collection for specific stockid.

**File: backend/app/routers/triggers.py** (see Story 1.5 for complete implementation)

```python
from fastapi import APIRouter, Query, HTTPException, Depends
from pydantic import BaseModel, Field
from motor.motor_asyncio import AsyncIOMotorDatabase
from datetime import datetime
import time
import logging

router = APIRouter(prefix="/api/triggers", tags=["triggers"])
logger = logging.getLogger(__name__)

class TriggerDataResponse(BaseModel):
    """Response model for trigger data."""
    trigger_name: str
    stockid: int
    data: dict
    metadata: dict

@router.get("/{trigger_name}/data", response_model=TriggerDataResponse)
async def get_trigger_data(
    trigger_name: str,
    stockid: int = Query(..., gt=0, description="Stock ID (required)"),
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Fetch OLD data from news_triggers for specific stockid.

    Args:
        trigger_name: Trigger identifier (e.g., "earnings_result")
        stockid: Stock ID (positive integer, required)
        db: MongoDB database connection

    Returns:
        TriggerDataResponse with existing trigger data and metadata

    Raises:
        HTTPException 404: If trigger_name or stockid not found
        HTTPException 400: If stockid invalid format

    Note:
        - No caching (data changes during market hours)
        - Response time target: <5 seconds (NFR2)
    """
    start_time = time.time()

    # Query MongoDB for trigger data
    trigger_doc = await db.news_triggers.find_one({
        "trigger_name": [trigger_name],
        "stockid": stockid
    })

    if not trigger_doc:
        logger.warning(f"No data found for trigger '{trigger_name}' with stockid {stockid}")
        raise HTTPException(
            status_code=404,
            detail=f"No data found for trigger '{trigger_name}' with stockid {stockid}"
        )

    # Extract data field
    data = trigger_doc.get("data", {})

    # Build metadata
    metadata = {
        "last_updated": trigger_doc.get("updated_at", datetime.utcnow()).isoformat(),
        "data_source": "news_triggers",
        "response_time": round(time.time() - start_time, 3)
    }

    logger.info(f"Fetched trigger data: trigger={trigger_name}, stockid={stockid}")

    return TriggerDataResponse(
        trigger_name=trigger_name,
        stockid=stockid,
        data=data,
        metadata=metadata
    )
```

**Response Example**:

```json
{
  "trigger_name": "earnings_result",
  "stockid": 513374,
  "data": {
    "company_name": "TCS",
    "earnings_date": "2025-10-28",
    "revenue": "59000 crores",
    "profit": "12000 crores"
  },
  "metadata": {
    "last_updated": "2025-10-28T10:30:00Z",
    "data_source": "news_triggers",
    "response_time": 0.123
  }
}
```

#### 2. GET /api/triggers/{trigger_name}/prompts

Fetches existing prompts from trigger_prompts collection for pre-population.

**File: backend/app/routers/triggers.py** (same file as above)

```python
class PromptsResponse(BaseModel):
    """Response model for existing prompts."""
    trigger_name: str
    prompts: dict
    model_config: dict | None = None
    data_config: dict | None = None

@router.get("/{trigger_name}/prompts", response_model=PromptsResponse)
async def get_trigger_prompts(
    trigger_name: str,
    db: AsyncIOMotorDatabase = Depends(get_database)
):
    """
    Fetch existing prompts for trigger from trigger_prompts collection.

    Returns empty prompts if none configured (not 404).
    Can be cached (5-min TTL) since prompts are static until manually updated.
    """
    config_doc = await db.trigger_prompts.find_one({"trigger_name": trigger_name})

    if not config_doc:
        # Return empty prompts (not 404)
        return PromptsResponse(
            trigger_name=trigger_name,
            prompts={"paid": None, "unpaid": None, "crawler": None}
        )

    prompts = config_doc.get("prompts", {})

    return PromptsResponse(
        trigger_name=trigger_name,
        prompts={
            "paid": prompts.get("paid"),
            "unpaid": prompts.get("unpaid"),
            "crawler": prompts.get("crawler")
        },
        model_config=config_doc.get("model_config"),
        data_config=config_doc.get("data_config")
    )
```

### Frontend Component Specifications

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/components/config/DataConfiguration.tsx** (Update)

Add "Fetch Data" functionality to existing component:

```typescript
'use client';

import { useState } from 'react';
import { Card, Button, Alert, Form, Row, Col } from 'react-bootstrap';
import SectionSelection from './SectionSelection';
import RawDataDisplay from './RawDataDisplay';

interface DataConfigurationProps {
  triggerId: string;
  configuration: any;
  onConfigUpdate: (config: any) => void;
}

export default function DataConfiguration({
  triggerId,
  configuration,
  onConfigUpdate
}: DataConfigurationProps) {
  const [selectedSections, setSelectedSections] = useState(
    configuration?.data_sections || []
  );
  const [stockId, setStockId] = useState('AAPL');
  const [loading, setLoading] = useState(false);
  const [fetchLoading, setFetchLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [rawData, setRawData] = useState<any>(null);
  const [dataStatus, setDataStatus] = useState<any>(null);

  const handleSectionChange = async (sections: string[]) => {
    setSelectedSections(sections);

    try {
      setLoading(true);
      const response = await fetch(`/api/triggers/${triggerId}/config/sections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ section_ids: sections })
      });

      if (!response.ok) throw new Error('Failed to update sections');

      const data = await response.json();
      onConfigUpdate(data.configuration);
      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const validateStockId = (id: string): boolean => {
    // Basic stock ticker validation: 1-5 uppercase letters
    const tickerRegex = /^[A-Z]{1,5}$/;
    return tickerRegex.test(id);
  };

  const handleFetchData = async () => {
    if (!validateStockId(stockId)) {
      setError('Invalid stock ID format. Please enter a valid ticker symbol (e.g., AAPL).');
      return;
    }

    if (selectedSections.length === 0) {
      setError('Please select at least one data section.');
      return;
    }

    try {
      setFetchLoading(true);
      setError(null);

      const response = await fetch(`/api/triggers/${triggerId}/data/fetch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          stock_id: stockId,
          section_ids: selectedSections
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch data: ${response.statusText}`);
      }

      const data = await response.json();
      setRawData(data.raw_data);
      setDataStatus(data.status);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch data');
    } finally {
      setFetchLoading(false);
    }
  };

  return (
    <>
      <Card>
        <Card.Header>
          <h5>Data Configuration</h5>
        </Card.Header>
        <Card.Body>
          {error && <Alert variant="danger">{error}</Alert>}

          <Row className="mb-3">
            <Col md={6}>
              <Form.Group>
                <Form.Label>Stock ID (for testing)</Form.Label>
                <Form.Control
                  type="text"
                  value={stockId}
                  onChange={(e) => setStockId(e.target.value.toUpperCase())}
                  placeholder="e.g., AAPL"
                  maxLength={5}
                />
                <Form.Text className="text-muted">
                  Enter a valid stock ticker symbol (1-5 uppercase letters)
                </Form.Text>
              </Form.Group>
            </Col>
          </Row>

          <SectionSelection
            selectedSections={selectedSections}
            onChange={handleSectionChange}
            disabled={loading}
          />

          <div className="mt-3 d-flex gap-2">
            <Button
              variant="primary"
              onClick={handleFetchData}
              disabled={fetchLoading || selectedSections.length === 0}
            >
              {fetchLoading ? 'Fetching...' : 'Fetch Data'}
            </Button>

            {rawData && (
              <Button
                variant="outline-primary"
                onClick={handleFetchData}
                disabled={fetchLoading}
              >
                Refresh Data
              </Button>
            )}
          </div>
        </Card.Body>
      </Card>

      {/* Raw Data Display */}
      {rawData && dataStatus && (
        <RawDataDisplay
          rawData={rawData}
          status={dataStatus}
          stockId={stockId}
        />
      )}
    </>
  );
}
```

**File: frontend/src/components/config/RawDataDisplay.tsx** (New)

Complete component for displaying raw JSON with syntax highlighting:

```typescript
'use client';

import { useState } from 'react';
import { Card, Accordion, Badge, Row, Col } from 'react-bootstrap';
import ReactJson from 'react-json-view';

interface RawDataDisplayProps {
  rawData: Record<string, any>;
  status: Record<string, any>;
  stockId: string;
}

export default function RawDataDisplay({ rawData, status, stockId }: RawDataDisplayProps) {
  const [expandedSections, setExpandedSections] = useState<Set<string>>(new Set());

  const toggleSection = (sectionId: string) => {
    const newExpanded = new Set(expandedSections);
    if (newExpanded.has(sectionId)) {
      newExpanded.delete(sectionId);
    } else {
      newExpanded.add(sectionId);
    }
    setExpandedSections(newExpanded);
  };

  const getStatusBadge = (sectionStatus: any) => {
    if (sectionStatus.status === 'success') {
      return <Badge bg="success">Success</Badge>;
    } else if (sectionStatus.status === 'error') {
      return <Badge bg="danger">Error</Badge>;
    } else {
      return <Badge bg="secondary">{sectionStatus.status}</Badge>;
    }
  };

  const formatLatency = (latency: number | null) => {
    if (latency === null) return 'N/A';
    return `${latency.toFixed(2)}s`;
  };

  const sectionIds = Object.keys(rawData).sort();

  return (
    <Card className="mt-4">
      <Card.Header>
        <h5>Raw Data Display</h5>
        <small className="text-muted">Stock: {stockId}</small>
      </Card.Header>
      <Card.Body>
        <Accordion>
          {sectionIds.map((sectionId, index) => {
            const sectionStatus = status[sectionId];
            const sectionData = rawData[sectionId];

            return (
              <Accordion.Item eventKey={sectionId} key={sectionId}>
                <Accordion.Header onClick={() => toggleSection(sectionId)}>
                  <div className="d-flex justify-content-between align-items-center w-100">
                    <div>
                      <strong>Section {sectionId}</strong>
                      {' - '}
                      <span className="text-muted">{sectionStatus.api_name}</span>
                    </div>
                    <div className="d-flex gap-3 align-items-center me-3">
                      {getStatusBadge(sectionStatus)}
                      <small className="text-muted">
                        Latency: {formatLatency(sectionStatus.latency)}
                      </small>
                      <small className="text-muted">
                        {new Date(sectionStatus.timestamp).toLocaleTimeString()}
                      </small>
                    </div>
                  </div>
                </Accordion.Header>
                <Accordion.Body>
                  {sectionStatus.status === 'error' ? (
                    <div className="alert alert-danger">
                      <strong>Error:</strong> {sectionStatus.error}
                    </div>
                  ) : sectionData ? (
                    <ReactJson
                      src={sectionData}
                      theme="rjv-default"
                      collapsed={2}
                      displayDataTypes={false}
                      displayObjectSize={true}
                      enableClipboard={true}
                      name={false}
                    />
                  ) : (
                    <div className="text-muted">No data available</div>
                  )}
                </Accordion.Body>
              </Accordion.Item>
            );
          })}
        </Accordion>

        {sectionIds.length === 0 && (
          <div className="text-center text-muted py-4">
            No data to display. Click "Fetch Data" to retrieve data.
          </div>
        )}
      </Card.Body>
    </Card>
  );
}
```

### TypeScript Type Definitions

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/types/data.ts** (New)

```typescript
export interface FetchDataRequest {
  stock_id: string;
  section_ids: string[];
}

export interface SectionStatus {
  api_name: string;
  status: 'success' | 'error' | 'unknown';
  latency: number | null;
  timestamp: string;
  error?: string;
}

export interface FetchDataResponse {
  stock_id: string;
  raw_data: Record<string, any>;
  status: Record<string, SectionStatus>;
  timestamp: string;
}
```

### Environment Variables

[Source: architecture.md - Development and Deployment - Environment Variables]

No new environment variables needed. Uses existing from Story 2.2:
- `EARNINGS_API_KEY` - Earnings API key
- `PRICE_API_KEY` - Price API key
- `DATA_API_TIMEOUT` - API timeout (default: 5.0 seconds for NFR2)

### Implementation Notes

[Source: PRD - Non-Functional Requirements]

**Important Design Decisions**:

1. **Parallel API Fetching**: Uses `asyncio.gather()` to fetch data from all APIs simultaneously, meeting NFR2 (5 seconds per API).

2. **Error Isolation**: Failed API calls don't block successful ones. Each section displays independently.

3. **Stock ID Validation**: Client-side validation prevents invalid requests (1-5 uppercase letters regex).

4. **Refresh Functionality**: "Refresh Data" button appears after initial fetch, reuses stored stock ID.

5. **Collapsible Panels**: React-Bootstrap Accordion for clean organization, one panel per section.

6. **JSON Syntax Highlighting**: Uses `react-json-view` library for formatted, expandable JSON display.

7. **Status Indicators**: Color-coded badges (success=green, error=red) with latency and timestamp.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 2.3**:

**Unit Tests** (backend/tests/test_data_service.py):

```python
import pytest
from unittest.mock import AsyncMock, patch
from app.services.data_service import DataService
from app.data_adapters.registry import AdapterRegistry

@pytest.mark.asyncio
async def test_fetch_all_data_success(db):
    """Test successful parallel data fetching"""
    service = DataService(db)

    # Mock adapter responses
    mock_result = {
        "status": "success",
        "data": {"earnings": {"eps": 1.50}},
        "metadata": {"latency": 0.5, "timestamp": "2025-10-29"}
    }

    with patch.object(AdapterRegistry, 'get_adapter') as mock_get_adapter:
        mock_adapter = AsyncMock()
        mock_adapter.fetch_data = AsyncMock(return_value=mock_result)
        mock_get_adapter.return_value = mock_adapter

        result = await service.fetch_all_data(
            trigger_id="trigger_001",
            stock_id="AAPL",
            section_ids=["1", "2"]
        )

        assert result["stock_id"] == "AAPL"
        assert "raw_data" in result
        assert "status" in result
        assert result["status"]["1"]["status"] == "success"

@pytest.mark.asyncio
async def test_fetch_all_data_partial_failure(db):
    """Test that successful APIs complete even if one fails"""
    service = DataService(db)

    # Mock one success, one failure
    success_result = {
        "status": "success",
        "data": {"price": 150.00},
        "metadata": {"latency": 0.3}
    }

    with patch.object(AdapterRegistry, 'get_adapter') as mock_get_adapter:
        mock_adapter = AsyncMock()

        # First call succeeds, second call raises exception
        mock_adapter.fetch_data = AsyncMock(
            side_effect=[success_result, Exception("Timeout")]
        )
        mock_get_adapter.return_value = mock_adapter

        result = await service.fetch_all_data(
            trigger_id="trigger_001",
            stock_id="AAPL",
            section_ids=["1", "2"]
        )

        # Section 1 should succeed
        assert result["status"]["1"]["status"] == "success"
        # Section 2 should fail
        assert result["status"]["2"]["status"] == "error"
        assert "Timeout" in result["status"]["2"]["error"]

@pytest.mark.asyncio
async def test_fetch_data_endpoint(client):
    """Test POST /api/triggers/:id/data/fetch endpoint"""
    response = await client.post(
        "/api/triggers/trigger_001/data/fetch",
        json={
            "stock_id": "AAPL",
            "section_ids": ["1", "2", "3"]
        }
    )

    assert response.status_code == 200
    data = response.json()
    assert data["stock_id"] == "AAPL"
    assert "raw_data" in data
    assert "status" in data

@pytest.mark.asyncio
async def test_fetch_data_invalid_trigger(client):
    """Test fetch with non-existent trigger"""
    response = await client.post(
        "/api/triggers/invalid_trigger/data/fetch",
        json={
            "stock_id": "AAPL",
            "section_ids": ["1"]
        }
    )

    assert response.status_code == 404

@pytest.mark.asyncio
async def test_fetch_data_timeout(db):
    """Test that API calls respect 5 second timeout (NFR2)"""
    import time
    service = DataService(db)

    with patch.object(AdapterRegistry, 'get_adapter') as mock_get_adapter:
        mock_adapter = AsyncMock()

        # Simulate slow API call
        async def slow_fetch(*args, **kwargs):
            await asyncio.sleep(6)  # Exceeds 5 second timeout
            return {"status": "success", "data": {}}

        mock_adapter.fetch_data = slow_fetch
        mock_get_adapter.return_value = mock_adapter

        start = time.time()
        result = await service.fetch_all_data(
            trigger_id="trigger_001",
            stock_id="AAPL",
            section_ids=["1"]
        )
        elapsed = time.time() - start

        # Should timeout within 5 seconds
        assert elapsed < 6
        assert result["status"]["1"]["status"] == "error"
```

**Integration Tests** (backend/tests/integration/test_data_fetch.py):

```python
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.integration
@pytest.mark.asyncio
async def test_full_data_fetch_workflow():
    """Test complete data fetch workflow end-to-end"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        # 1. Configure sections
        response = await client.post(
            "/api/triggers/trigger_001/config/sections",
            json={"section_ids": ["1", "2", "3"]}
        )
        assert response.status_code == 200

        # 2. Fetch data
        response = await client.post(
            "/api/triggers/trigger_001/data/fetch",
            json={
                "stock_id": "AAPL",
                "section_ids": ["1", "2", "3"]
            }
        )
        assert response.status_code == 200
        data = response.json()

        # 3. Verify response structure
        assert "raw_data" in data
        assert "status" in data
        assert len(data["raw_data"]) == 3

        # 4. Verify each section has status
        for section_id in ["1", "2", "3"]:
            assert section_id in data["status"]
            assert "api_name" in data["status"][section_id]
            assert "status" in data["status"][section_id]
```

**Frontend Unit Tests** (frontend/__tests__/components/config/):

```typescript
// RawDataDisplay.test.tsx
import { render, screen } from '@testing-library/react';
import RawDataDisplay from '@/components/config/RawDataDisplay';

describe('RawDataDisplay Component', () => {
  const mockRawData = {
    "1": { earnings: { eps: 1.50 } },
    "2": { price: { current: 150.00 } }
  };

  const mockStatus = {
    "1": {
      api_name: "earnings_api",
      status: "success",
      latency: 0.5,
      timestamp: "2025-10-29T10:00:00Z"
    },
    "2": {
      api_name: "price_api",
      status: "success",
      latency: 0.3,
      timestamp: "2025-10-29T10:00:01Z"
    }
  };

  test('renders section panels with status badges', () => {
    render(
      <RawDataDisplay
        rawData={mockRawData}
        status={mockStatus}
        stockId="AAPL"
      />
    );

    expect(screen.getByText('Raw Data Display')).toBeInTheDocument();
    expect(screen.getByText('Stock: AAPL')).toBeInTheDocument();
    expect(screen.getByText('Section 1')).toBeInTheDocument();
    expect(screen.getByText('Success')).toBeInTheDocument();
  });

  test('displays error message for failed API calls', () => {
    const errorStatus = {
      "1": {
        api_name: "earnings_api",
        status: "error",
        latency: null,
        timestamp: "2025-10-29T10:00:00Z",
        error: "Timeout error"
      }
    };

    render(
      <RawDataDisplay
        rawData={{ "1": null }}
        status={errorStatus}
        stockId="AAPL"
      />
    );

    expect(screen.getByText(/Timeout error/i)).toBeInTheDocument();
    expect(screen.getByText('Error')).toBeInTheDocument();
  });

  test('displays latency and timestamp', () => {
    render(
      <RawDataDisplay
        rawData={mockRawData}
        status={mockStatus}
        stockId="AAPL"
      />
    );

    expect(screen.getByText(/Latency: 0.50s/)).toBeInTheDocument();
  });

  test('displays empty state when no data', () => {
    render(
      <RawDataDisplay
        rawData={{}}
        status={{}}
        stockId="AAPL"
      />
    );

    expect(screen.getByText(/No data to display/i)).toBeInTheDocument();
  });
});
```

**Manual Verification Checklist**:
1. Configuration Workspace shows "Fetch Data" button
2. Stock ID input accepts valid ticker symbols (AAPL, GOOGL, etc.)
3. Stock ID validation rejects invalid formats (lowercase, numbers, >5 chars)
4. Loading indicator appears during data fetch
5. Raw JSON displays in collapsible Accordion panels
6. Each panel shows: API name, status badge, latency, timestamp
7. Success panels (green badge) show formatted JSON
8. Error panels (red badge) show error messages
9. Failed API calls don't block successful ones
10. "Refresh Data" button appears after initial fetch
11. Clicking "Refresh" re-fetches data with same stock ID
12. Data fetch completes within 5 seconds per API (NFR2)
13. JSON syntax highlighting works correctly
14. Expand/collapse functionality works for nested JSON objects
15. No console errors in browser

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 2 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |
| 2025-10-30 | 2.0 | **MAJOR UPDATE** for News CMS Workflow: Added stockid parameter, data modes (OLD/NEW/OLD_NEW), removed generic API adapters, added prompts endpoint | Dev Agent |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
