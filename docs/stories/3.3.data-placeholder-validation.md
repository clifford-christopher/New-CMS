# Story 3.3: Data Placeholder Validation (Per Prompt Type)

## Status

Draft

## Story

**As a** content manager,
**I want** real-time validation of data placeholders in my prompt for the selected tab,
**so that** I catch errors before generation and know which data fields are available for each prompt type.

## Acceptance Criteria

1. Prompt editor parses placeholders in real-time for the currently active tab (e.g., `{{section_name}}`, `{data.field}`)
2. Invalid placeholders (referencing non-existent sections or fields) underlined in red with hover tooltip error message
3. Valid placeholders show green checkmark or no error indicator
4. Autocomplete suggestions appear when typing `{{` showing available section names and fields (same for all types since data is shared)
5. Validation runs on every keystroke (debounced to avoid performance issues) for active tab only
6. Validation error summary panel displays list of all invalid placeholders found in current tab's prompt
7. Clicking error in summary highlights corresponding placeholder in editor
8. Meets FR13: real-time validation of placeholder references per prompt type
9. Helper documentation or info icon explains placeholder syntax and available data fields
10. Tab indicator shows validation status (warning icon if errors exist in that tab's prompt)

## Tasks / Subtasks

- [ ] Task 1: Create ValidationContext provider for placeholder validation state (AC: 1, 5)
  - [ ] Create frontend/src/contexts/ValidationContext.tsx
  - [ ] Track valid and invalid placeholders per prompt type
  - [ ] Debounced validation logic on keystroke
  - [ ] Store validation errors with line numbers and placeholder text
- [ ] Task 2: Implement placeholder parsing and validation (AC: 1, 2, 3)
  - [ ] Create utility function to extract placeholders from prompt text
  - [ ] Validate against available sections from DataContext
  - [ ] Validate against available data fields (nested object traversal)
  - [ ] Mark invalid placeholders with error decorations in Monaco
- [ ] Task 3: Create ValidationSummary component (AC: 6, 7)
  - [ ] Display list of all invalid placeholders per prompt type
  - [ ] Show line numbers and error descriptions
  - [ ] Link errors to editor positions (click to highlight)
  - [ ] Highlight corresponding placeholder in editor on error selection
- [ ] Task 4: Implement Monaco decorations and inline errors (AC: 2)
  - [ ] Add red underline to invalid placeholders using Monaco decorations API
  - [ ] Show green checkmark or no indicator for valid placeholders
  - [ ] Implement hover tooltips with error messages
  - [ ] Update decorations on every keystroke (debounced)
- [ ] Task 5: Implement autocomplete suggestions (AC: 4)
  - [ ] Integrate Monaco IntelliSense for autocomplete
  - [ ] Provide suggestions when typing `{{` or `{data.`
  - [ ] Show available section names and nested field paths
  - [ ] Filter suggestions as user types
- [ ] Task 6: Add helper documentation (AC: 9)
  - [ ] Create info icon/button in validation panel
  - [ ] Show available sections and their fields in a reference panel
  - [ ] Explain placeholder syntax with examples
  - [ ] Link to PRD documentation
- [ ] Task 7: Add tab indicators for validation status (AC: 10)
  - [ ] Show warning icon on tab if that prompt type has validation errors
  - [ ] Update tab headers dynamically as validation changes
  - [ ] Color-code tabs (red for errors, green for valid)
- [ ] Task 8: Create backend validation endpoint (Optional for MVP)
  - [ ] Optional: POST /api/triggers/:id/validate-prompt endpoint
  - [ ] Server-side validation for pre-publish checks
- [ ] Task 9: Write unit and integration tests
  - [ ] Test placeholder extraction regex and parsing
  - [ ] Test validation logic for valid/invalid placeholders
  - [ ] Test autocomplete suggestions generation
  - [ ] Test error highlighting and decoration updates
  - [ ] Test integration with Monaco Editor

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 3.2 - Completion]

Before starting this story, ensure Story 3.2 is complete:
- PromptEditor component renders with Monaco Editor
- PromptContext manages prompt templates for all types
- Prompt content is tracked and auto-saved
- DataContext provides structured data with sections

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── config/
│       ├── ValidationSummary.tsx          # Validation error panel (NEW)
│       ├── PlaceholderDocumentation.tsx   # Helper reference panel (NEW)
│       ├── PromptEditor.tsx               # Add decorations (MODIFY)
│       ├── PromptTabs.tsx                 # Add warning indicators (MODIFY)
│       └── ConfigurationWorkspace.tsx     # Integrate ValidationSummary (MODIFY)
├── contexts/
│   ├── ValidationContext.tsx              # Validation state management (NEW)
│   ├── PromptContext.tsx                  # Existing prompt context
│   └── DataContext.tsx                    # Existing data context
├── lib/
│   └── placeholderUtils.ts                # Placeholder parsing and validation (NEW)
└── types/
    └── validation.ts                      # TypeScript types for validation (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **Monaco Editor**: Decorations API for inline error indicators
- **React**: For ValidationContext and ValidationSummary component
- **React Context API**: ValidationContext for validation state
- **Regex**: Placeholder pattern matching (`{{...}}` and `{data.path}`)
- **use-debounce**: For debounced validation on keystroke

### Placeholder Pattern and Validation Rules

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Supported Placeholder Formats**:
- `{{section_name}}`: Reference a data section by name (e.g., `{{earnings_summary}}`)
- `{{section_1}}`: Reference a section by numeric ID (e.g., `{{section_1}}`)
- `{data.field.nested}`: Reference nested data field (e.g., `{data.earnings.summary}`)

**Validation Rules**:
1. **Valid Placeholder**: References an existing section in `structuredData.sections`
2. **Valid Field Reference**: References a valid nested path in the data object
3. **Invalid Placeholder**: References non-existent section or field
4. **Autocomplete**: Suggest all section keys and first-level field paths

### React Context for Validation

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/ValidationContext.tsx** (New)

Complete validation state management:

```typescript
'use client';

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import { useDebouncedCallback } from 'use-debounce';
import { useData } from './DataContext';
import { usePrompt } from './PromptContext';
import { validatePlaceholders } from '@/lib/placeholderUtils';

type PromptType = 'paid' | 'unpaid' | 'crawler';

interface ValidationError {
  placeholder: string;
  line: number;
  column: number;
  message: string;
  position: { start: number; end: number };
}

interface ValidationResult {
  errors: ValidationError[];
  validPlaceholders: string[];
  hasErrors: boolean;
}

interface ValidationContextType {
  validation: Record<PromptType, ValidationResult>;
  validatePrompt: (type: PromptType, content: string) => Promise<void>;
  getErrorsForLine: (type: PromptType, lineNumber: number) => ValidationError[];
  highlightedPosition: { type: PromptType; placeholder: string } | null;
  setHighlightedPosition: (pos: { type: PromptType; placeholder: string } | null) => void;
  isValidating: boolean;
}

const ValidationContext = createContext<ValidationContextType | undefined>(undefined);

export function ValidationProvider({ children }: { children: ReactNode }) {
  const { structuredData } = useData();
  const { activeTab } = usePrompt();
  const [validation, setValidation] = useState<Record<PromptType, ValidationResult>>({
    paid: { errors: [], validPlaceholders: [], hasErrors: false },
    unpaid: { errors: [], validPlaceholders: [], hasErrors: false },
    crawler: { errors: [], validPlaceholders: [], hasErrors: false }
  });
  const [isValidating, setIsValidating] = useState(false);
  const [highlightedPosition, setHighlightedPosition] = useState<{ type: PromptType; placeholder: string } | null>(null);

  const validatePrompt = useCallback(async (type: PromptType, content: string) => {
    setIsValidating(true);
    try {
      if (!structuredData) {
        setValidation(prev => ({
          ...prev,
          [type]: {
            errors: [],
            validPlaceholders: [],
            hasErrors: false
          }
        }));
        return;
      }

      const result = validatePlaceholders(content, structuredData.sections);
      setValidation(prev => ({
        ...prev,
        [type]: result
      }));
    } finally {
      setIsValidating(false);
    }
  }, [structuredData]);

  // Debounced validation function
  const debouncedValidate = useDebouncedCallback(
    async (type: PromptType, content: string) => {
      await validatePrompt(type, content);
    },
    500
  );

  const getErrorsForLine = useCallback((type: PromptType, lineNumber: number) => {
    return validation[type].errors.filter(err => err.line === lineNumber);
  }, [validation]);

  const value: ValidationContextType = {
    validation,
    validatePrompt,
    getErrorsForLine,
    highlightedPosition,
    setHighlightedPosition,
    isValidating
  };

  return <ValidationContext.Provider value={value}>{children}</ValidationContext.Provider>;
}

export function useValidation() {
  const context = useContext(ValidationContext);
  if (context === undefined) {
    throw new Error('useValidation must be used within a ValidationProvider');
  }
  return context;
}
```

**File: frontend/src/lib/placeholderUtils.ts** (New)

Placeholder parsing and validation utility:

```typescript
interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface ValidationError {
  placeholder: string;
  line: number;
  column: number;
  message: string;
  position: { start: number; end: number };
}

interface ValidationResult {
  errors: ValidationError[];
  validPlaceholders: string[];
  hasErrors: boolean;
}

// Regex patterns for placeholder detection
const PLACEHOLDER_PATTERN = /\{\{([a-zA-Z_][a-zA-Z0-9_]*)\}\}|\{data\.([a-zA-Z_][a-zA-Z0-9_.]*)\}/g;

export function extractPlaceholders(content: string): Array<{ text: string; type: 'section' | 'field'; start: number; end: number }> {
  const placeholders = [];
  let match;

  // Reset regex
  PLACEHOLDER_PATTERN.lastIndex = 0;

  while ((match = PLACEHOLDER_PATTERN.exec(content)) !== null) {
    const fullMatch = match[0];
    const sectionMatch = match[1];
    const fieldMatch = match[2];

    placeholders.push({
      text: fullMatch,
      type: sectionMatch ? 'section' : 'field',
      name: sectionMatch || fieldMatch,
      start: match.index,
      end: match.index + fullMatch.length
    });
  }

  return placeholders;
}

export function getAvailablePlaceholders(sections: Record<string, SectionData>): Array<{ label: string; kind: string; detail: string }> {
  const suggestions = [];

  // Add section placeholders
  Object.entries(sections).forEach(([sectionId, section]) => {
    suggestions.push({
      label: `{{${section.section_name}}}`,
      kind: 'section',
      detail: `Section: ${section.section_name}`
    });

    // Add field suggestions if data available
    if (section.data_available && typeof section.data === 'object') {
      Object.keys(section.data).forEach(key => {
        suggestions.push({
          label: `{data.${key}`,
          kind: 'field',
          detail: `Field: ${key}`
        });
      });
    }
  });

  return suggestions;
}

export function validatePlaceholders(content: string, sections: Record<string, SectionData>): ValidationResult {
  const errors: ValidationError[] = [];
  const validPlaceholders: Set<string> = new Set();
  const lines = content.split('\n');
  let position = 0;

  placeholders = extractPlaceholders(content);

  placeholders.forEach(placeholder => {
    const lineNumber = content.substring(0, placeholder.start).split('\n').length;
    const lineStart = content.lastIndexOf('\n', placeholder.start) + 1;
    const column = placeholder.start - lineStart;

    let isValid = false;

    if (placeholder.type === 'section') {
      // Check if section exists
      const sectionExists = Object.values(sections).some(
        s => s.section_name === placeholder.name || s.section_id === placeholder.name
      );
      isValid = sectionExists;
    } else {
      // Check if field path exists (nested object traversal)
      const fieldPath = placeholder.name.split('.');
      let current = sections; // Simplified - would check in actual data
      isValid = fieldPath.length > 0; // Placeholder - proper validation in implementation
    }

    if (!isValid) {
      errors.push({
        placeholder: placeholder.text,
        line: lineNumber,
        column,
        message: `Invalid placeholder: ${placeholder.text}. Check section/field name.`,
        position: { start: placeholder.start, end: placeholder.end }
      });
    } else {
      validPlaceholders.add(placeholder.text);
    }
  });

  return {
    errors,
    validPlaceholders: Array.from(validPlaceholders),
    hasErrors: errors.length > 0
  };
}
```

### Frontend Component Specifications

**File: frontend/src/components/config/ValidationSummary.tsx** (New)

Validation error summary panel:

```typescript
'use client';

import { Card, Alert, Badge, Button, ListGroup } from 'react-bootstrap';
import { useValidation } from '@/contexts/ValidationContext';
import { usePrompt } from '@/contexts/PromptContext';

export default function ValidationSummary() {
  const { validation, getErrorsForLine, setHighlightedPosition } = useValidation();
  const { activeTab, prompts } = usePrompt();

  const currentValidation = validation[activeTab];
  const currentPrompt = prompts[activeTab];

  if (!currentValidation.hasErrors) {
    return (
      <Card className="mt-4">
        <Card.Header>
          <h5 className="mb-0">Placeholder Validation</h5>
        </Card.Header>
        <Card.Body>
          <Alert variant="success" className="mb-0">
            <i className="bi bi-check-circle me-2"></i>
            No placeholder errors detected. All references are valid.
          </Alert>
        </Card.Body>
      </Card>
    );
  }

  return (
    <Card className="mt-4 border-danger">
      <Card.Header className="bg-danger bg-opacity-10">
        <h5 className="mb-0 text-danger">
          <i className="bi bi-exclamation-triangle me-2"></i>
          Placeholder Errors ({currentValidation.errors.length})
        </h5>
      </Card.Header>
      <Card.Body>
        <ListGroup variant="flush">
          {currentValidation.errors.map((error, idx) => (
            <ListGroup.Item
              key={idx}
              className="d-flex justify-content-between align-items-start cursor-pointer"
              onClick={() => setHighlightedPosition({ type: activeTab, placeholder: error.placeholder })}
              style={{ cursor: 'pointer', padding: '10px' }}
            >
              <div className="flex-grow-1">
                <div className="fw-bold text-danger">{error.placeholder}</div>
                <small className="text-muted">Line {error.line}, Col {error.column}</small>
                <div className="text-muted">{error.message}</div>
              </div>
              <Badge bg="danger" className="ms-2">Error</Badge>
            </ListGroup.Item>
          ))}
        </ListGroup>
      </Card.Body>
    </Card>
  );
}
```

**File: frontend/src/components/config/PlaceholderDocumentation.tsx** (New)

Helper reference for available placeholders:

```typescript
'use client';

import { Card, Button, ListGroup, Badge, Accordion } from 'react-bootstrap';
import { useData } from '@/contexts/DataContext';
import { useState } from 'react';

export default function PlaceholderDocumentation() {
  const { structuredData } = useData();
  const [showHelp, setShowHelp] = useState(false);

  if (!structuredData) {
    return null;
  }

  return (
    <>
      <Button
        variant="outline-info"
        size="sm"
        className="mt-2"
        onClick={() => setShowHelp(!showHelp)}
      >
        <i className="bi bi-question-circle me-1"></i>
        Available Placeholders
      </Button>

      {showHelp && (
        <Card className="mt-3 bg-light">
          <Card.Header>
            <h6 className="mb-0">Placeholder Reference</h6>
          </Card.Header>
          <Card.Body className="small">
            <div className="mb-3">
              <strong>Syntax Examples:</strong>
              <ul className="mb-0">
                <li><code>{`{{section_name}}`}</code> - Reference a data section</li>
                <li><code>{`{data.field.nested}`}</code> - Reference a nested data field</li>
              </ul>
            </div>

            <Accordion>
              {Object.values(structuredData.sections).map((section, idx) => (
                <Accordion.Item eventKey={idx.toString()} key={section.section_id}>
                  <Accordion.Header>
                    <strong>{section.section_name}</strong>
                    <Badge bg="secondary" className="ms-2">{section.section_id}</Badge>
                  </Accordion.Header>
                  <Accordion.Body className="p-2">
                    <code>{`{{${section.section_name}}}`}</code>
                    {section.data_available && (
                      <ListGroup className="mt-2" variant="flush">
                        {Object.keys(section.data || {}).map(key => (
                          <ListGroup.Item key={key} className="py-1">
                            <code className="text-info">{`{data.${key}}`}</code>
                          </ListGroup.Item>
                        ))}
                      </ListGroup>
                    )}
                  </Accordion.Body>
                </Accordion.Item>
              ))}
            </Accordion>
          </Card.Body>
        </Card>
      )}
    </>
  );
}
```

### Implementation Notes

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Important Design Decisions**:

1. **Debounced Validation**: Validation runs every 500ms (debounced) to avoid performance issues on rapid typing.

2. **Monaco Decorations**: Invalid placeholders marked with red wavy underline using Monaco Editor decorations API. Hover tooltips show error messages.

3. **Per-Type Validation**: Validation runs only for active tab, not all tabs. Reduces computation and improves performance.

4. **Autocomplete Integration**: Monaco IntelliSense activated when typing `{{` or `{data.` to suggest available sections/fields.

5. **Helper Documentation**: Reference panel shows all available sections and fields. Click to learn what can be referenced.

6. **Tab Indicators**: Warning icon (red) displayed on tab header if that prompt type has validation errors.

7. **Two-Way Linking**: Click error in summary to highlight in editor. Click placeholder in editor to see errors.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 3.3**:

**Unit Tests** (frontend/__tests__/lib/):

```typescript
// placeholderUtils.test.ts
import { extractPlaceholders, validatePlaceholders, getAvailablePlaceholders } from '@/lib/placeholderUtils';

describe('Placeholder Utilities', () => {
  describe('extractPlaceholders', () => {
    test('extracts section placeholders', () => {
      const content = 'This is {{earnings_summary}} data';
      const placeholders = extractPlaceholders(content);

      expect(placeholders).toHaveLength(1);
      expect(placeholders[0]).toMatchObject({
        text: '{{earnings_summary}}',
        type: 'section',
        name: 'earnings_summary'
      });
    });

    test('extracts field placeholders', () => {
      const content = 'Field value is {data.earnings.summary}';
      const placeholders = extractPlaceholders(content);

      expect(placeholders).toHaveLength(1);
      expect(placeholders[0]).toMatchObject({
        text: '{data.earnings.summary}',
        type: 'field',
        name: 'earnings.summary'
      });
    });

    test('extracts multiple placeholders', () => {
      const content = '{{section1}} and {data.field1} and {{section2}}';
      const placeholders = extractPlaceholders(content);
      expect(placeholders).toHaveLength(3);
    });

    test('ignores invalid placeholder formats', () => {
      const content = '{ {invalid}} and {data .field}';
      const placeholders = extractPlaceholders(content);
      expect(placeholders).toHaveLength(0);
    });
  });

  describe('validatePlaceholders', () => {
    const mockSections = {
      '1': {
        section_name: 'earnings_summary',
        section_id: '1',
        data: { summary: 'earnings data' },
        metadata: { parsed_at: '2025-01-01', data_available: true }
      }
    };

    test('validates existing section placeholder', () => {
      const content = '{{earnings_summary}}';
      const result = validatePlaceholders(content, mockSections);

      expect(result.hasErrors).toBe(false);
      expect(result.validPlaceholders).toContain('{{earnings_summary}}');
    });

    test('detects invalid section placeholder', () => {
      const content = '{{non_existent}}';
      const result = validatePlaceholders(content, mockSections);

      expect(result.hasErrors).toBe(true);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].placeholder).toBe('{{non_existent}}');
    });

    test('provides line and column numbers for errors', () => {
      const content = 'Line 1\nLine 2 {{invalid}} placeholder';
      const result = validatePlaceholders(content, mockSections);

      expect(result.errors[0].line).toBe(2);
      expect(result.errors[0].column).toBeGreaterThan(0);
    });
  });

  describe('getAvailablePlaceholders', () => {
    test('returns suggestions for sections and fields', () => {
      const sections = {
        '1': {
          section_name: 'earnings',
          section_id: '1',
          data: { summary: 'test', details: 'test' },
          metadata: { parsed_at: '2025-01-01', data_available: true }
        }
      };

      const suggestions = getAvailablePlaceholders(sections);
      expect(suggestions.length).toBeGreaterThan(0);
      expect(suggestions).toContainEqual(
        expect.objectContaining({ label: '{{earnings}}' })
      );
    });
  });
});
```

**Component Tests** (frontend/__tests__/components/config/):

```typescript
// ValidationSummary.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import ValidationSummary from '@/components/config/ValidationSummary';
import { ValidationProvider } from '@/contexts/ValidationContext';
import { PromptProvider } from '@/contexts/PromptContext';
import { DataProvider } from '@/contexts/DataContext';

describe('ValidationSummary Component', () => {
  const renderWithContext = (component: React.ReactElement) => {
    return render(
      <DataProvider>
        <PromptProvider>
          <ValidationProvider>
            {component}
          </ValidationProvider>
        </PromptProvider>
      </DataProvider>
    );
  };

  test('displays success when no errors', () => {
    renderWithContext(<ValidationSummary />);
    expect(screen.getByText(/No placeholder errors detected/)).toBeInTheDocument();
  });

  test('displays errors when validation fails', () => {
    renderWithContext(<ValidationSummary />);
    // Would need to set validation context with errors
    // expect(screen.getByText(/Placeholder Errors/)).toBeInTheDocument();
  });

  test('highlights placeholder when error clicked', () => {
    renderWithContext(<ValidationSummary />);
    // Click error and verify highlighting
  });
});
```

**Manual Verification Checklist**:
1. Placeholder extraction works for `{{section}}` and `{data.field}` formats
2. Invalid placeholders detected and underlined in red
3. Valid placeholders show no error indicator
4. Hover shows tooltip with error message
5. Validation summary panel lists all errors with line numbers
6. Click error highlights corresponding placeholder in editor
7. Autocomplete appears when typing `{{` or `{data.`
8. Tab header shows warning icon if errors exist
9. Helper documentation shows available sections and fields
10. Validation debounces properly (not on every keystroke)
11. Per-prompt-type validation (errors don't carry between tabs)
12. No console errors in browser

**Coverage Target**: 75%+ for placeholder validation logic

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 3 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context, dev notes, and testing standards | BMAD Agent |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
