# Story 2.5: 14-Section Selection with Drag-Drop Reordering

## Status

Draft

## Version

2.0 (News CMS Workflow Feature Integration)

## Story

**As a** content manager,
**I want** to select from 14 structured sections and reorder them via drag-drop,
**so that** I can customize which data sections are included and their order for news generation.

## Acceptance Criteria

1. Display 14 section checkboxes (only if data_mode is NEW or OLD_NEW from Story 2.3)
2. Section titles: Company Information, Income Statement (Quarterly), Income Statement (Annual), Balance Sheet, Cash Flow, Ratios, Valuation, Shareholding, Stock Performance, Technical Analysis, Quality Assessment, Financial Trend, Proprietary Score, Peer Comparison
3. All sections selected by default, user can uncheck to exclude
4. Drag-drop reordering using React DnD library with visual feedback
5. Numbered list showing current order (1, 2, 3...) updates during drag
6. "Undo Reordering" button to reset to default order
7. If data_mode is OLD: Hide section selection, show OLD data preview only
8. Each section card displays: section number, title, checkbox, drag handle icon
9. "Preview Merged Data" button (if OLD_NEW mode) calls `POST /api/data/merge` to show OLD + NEW combined
10. Save selected sections and section_order to WorkflowContext (data_config object)
11. Meets FR9: clear section labels and data structure preview
12. Section selection persists across navigation (stored in WorkflowContext)

## Tasks / Subtasks

- [ ] Task 1: Create StructuredDataDisplay component (AC: 1, 2, 3)
  - [ ] Create frontend/src/components/config/StructuredDataDisplay.tsx
  - [ ] Display sections in Bootstrap Card layout
  - [ ] Format section content (paragraphs, lists, tables)
  - [ ] Show section name as card header
- [ ] Task 2: Implement collapsible sections (AC: 4)
  - [ ] Use Bootstrap Accordion for collapsible sections
  - [ ] Add expand/collapse all functionality
  - [ ] Track expanded state per section
  - [ ] Persist expanded state in component state
- [ ] Task 3: Add visual mapping indicators (AC: 5, 9)
  - [ ] Display source API for each section
  - [ ] Show section ID and name mapping
  - [ ] Add visual badges for API sources
  - [ ] Link sections to raw data panels
- [ ] Task 4: Handle empty sections (AC: 7)
  - [ ] Detect sections with no data
  - [ ] Display placeholder message
  - [ ] Show "No data available" state
  - [ ] Style empty sections differently
- [ ] Task 5: Implement preview functionality (AC: 8)
  - [ ] Add "Preview Final Data Structure" button
  - [ ] Create preview modal with JSON display
  - [ ] Show complete structured data as it will be passed to LLM
  - [ ] Add copy to clipboard functionality
- [ ] Task 6: Create React Context for data persistence (AC: 10)
  - [ ] Create DataContext for storing structured data
  - [ ] Provide structured data to entire Config Workspace
  - [ ] Allow access from prompt editing components
  - [ ] Persist data across component re-renders
- [ ] Task 7: Integrate with parsing workflow (AC: 1)
  - [ ] Update DataConfiguration to trigger parsing
  - [ ] Display StructuredDataDisplay after parse completes
  - [ ] Handle parse errors gracefully
  - [ ] Show loading state during parsing
- [ ] Task 8: Write unit and integration tests
  - [ ] Test StructuredDataDisplay component rendering
  - [ ] Test collapsible sections functionality
  - [ ] Test empty section handling
  - [ ] Test preview modal
  - [ ] Test DataContext provider

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 2.3 v2.0, Story 2.4 v2.0 - Completion]

Before starting this story, ensure the following stories are complete:
- **Story 2.3 v2.0**: `GET /api/triggers/{trigger_name}/data?stockid={stockid}` returns OLD data
- **Story 2.3 v2.0**: Data mode selection (OLD/NEW/OLD_NEW) implemented
- **Story 2.3 v2.0**: stockid input field functional
- **Story 2.4 v2.0**: `POST /api/data/structured/generate` creates async job, returns job_id
- **Story 2.4 v2.0**: `GET /api/data/structured/jobs/{job_id}` polls job status
- **Story 2.4 v2.0**: Job completion returns 14 sections parsed from generate_full_report.py
- **WorkflowContext**: Stores data_mode, stockid, sections, section_order

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── config/
│       ├── DataConfiguration.tsx       # Update: Add parse button and display (MODIFY)
│       ├── StructuredDataDisplay.tsx   # Structured section display (NEW)
│       ├── SectionCard.tsx             # Individual section card component (NEW)
│       └── PreviewModal.tsx            # JSON preview modal (NEW)
├── contexts/
│   └── DataContext.tsx                 # Data persistence context (NEW)
└── types/
    └── structured_data.ts              # TypeScript types for structured data (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **React**: Component-based UI
- **React-Bootstrap**: Card, Accordion, Badge, Modal components
- **React Context API**: State management for structured data
- **TypeScript**: Type safety for structured data models
- **react-json-view**: JSON preview with syntax highlighting

### React Context for Data Persistence

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/DataContext.tsx** (New)

Complete context provider for data persistence:

```typescript
'use client';

import React, { createContext, useContext, useState, ReactNode } from 'react';

interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface StructuredData {
  sections: Record<string, SectionData>;
  metadata: {
    total_sections: number;
    parsed_at: string;
  };
}

interface DataContextType {
  rawData: Record<string, any> | null;
  structuredData: StructuredData | null;
  dataStatus: Record<string, any> | null;
  stockId: string | null;
  setRawData: (data: Record<string, any> | null) => void;
  setStructuredData: (data: StructuredData | null) => void;
  setDataStatus: (status: Record<string, any> | null) => void;
  setStockId: (id: string | null) => void;
  clearData: () => void;
}

const DataContext = createContext<DataContextType | undefined>(undefined);

export function DataProvider({ children }: { children: ReactNode }) {
  const [rawData, setRawData] = useState<Record<string, any> | null>(null);
  const [structuredData, setStructuredData] = useState<StructuredData | null>(null);
  const [dataStatus, setDataStatus] = useState<Record<string, any> | null>(null);
  const [stockId, setStockId] = useState<string | null>(null);

  const clearData = () => {
    setRawData(null);
    setStructuredData(null);
    setDataStatus(null);
    setStockId(null);
  };

  const value: DataContextType = {
    rawData,
    structuredData,
    dataStatus,
    stockId,
    setRawData,
    setStructuredData,
    setDataStatus,
    setStockId,
    clearData,
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
}

export function useData() {
  const context = useContext(DataContext);
  if (context === undefined) {
    throw new Error('useData must be used within a DataProvider');
  }
  return context;
}
```

### Frontend Component Specifications

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/components/config/DataConfiguration.tsx** (Update)

Add parsing functionality and structured data display:

```typescript
'use client';

import { useState } from 'react';
import { Card, Button, Alert, Form, Row, Col } from 'react-bootstrap';
import SectionSelection from './SectionSelection';
import RawDataDisplay from './RawDataDisplay';
import StructuredDataDisplay from './StructuredDataDisplay';
import { useData } from '@/contexts/DataContext';

interface DataConfigurationProps {
  triggerId: string;
  configuration: any;
  onConfigUpdate: (config: any) => void;
}

export default function DataConfiguration({
  triggerId,
  configuration,
  onConfigUpdate
}: DataConfigurationProps) {
  const {
    rawData,
    structuredData,
    dataStatus,
    stockId,
    setRawData,
    setStructuredData,
    setDataStatus,
    setStockId
  } = useData();

  const [selectedSections, setSelectedSections] = useState(
    configuration?.data_sections || []
  );
  const [localStockId, setLocalStockId] = useState('AAPL');
  const [loading, setLoading] = useState(false);
  const [fetchLoading, setFetchLoading] = useState(false);
  const [parseLoading, setParseLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // ... (keep existing handleSectionChange and validateStockId functions)

  const handleFetchData = async () => {
    if (!validateStockId(localStockId)) {
      setError('Invalid stock ID format. Please enter a valid ticker symbol (e.g., AAPL).');
      return;
    }

    if (selectedSections.length === 0) {
      setError('Please select at least one data section.');
      return;
    }

    try {
      setFetchLoading(true);
      setError(null);

      const response = await fetch(`/api/triggers/${triggerId}/data/fetch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          stock_id: localStockId,
          section_ids: selectedSections
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch data: ${response.statusText}`);
      }

      const data = await response.json();
      setRawData(data.raw_data);
      setDataStatus(data.status);
      setStockId(localStockId);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch data');
    } finally {
      setFetchLoading(false);
    }
  };

  const handleParseData = async () => {
    if (!rawData) {
      setError('No raw data to parse. Please fetch data first.');
      return;
    }

    try {
      setParseLoading(true);
      setError(null);

      const response = await fetch(`/api/triggers/${triggerId}/data/parse`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ raw_data: rawData })
      });

      if (!response.ok) {
        throw new Error(`Failed to parse data: ${response.statusText}`);
      }

      const data = await response.json();

      if (data.errors && data.errors.length > 0) {
        setError(`Parser errors: ${data.errors.map(e => e.message).join(', ')}`);
      }

      setStructuredData(data.structured_data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to parse data');
    } finally {
      setParseLoading(false);
    }
  };

  return (
    <>
      <Card>
        <Card.Header>
          <h5>Data Configuration</h5>
        </Card.Header>
        <Card.Body>
          {error && <Alert variant="danger">{error}</Alert>}

          <Row className="mb-3">
            <Col md={6}>
              <Form.Group>
                <Form.Label>Stock ID (for testing)</Form.Label>
                <Form.Control
                  type="text"
                  value={localStockId}
                  onChange={(e) => setLocalStockId(e.target.value.toUpperCase())}
                  placeholder="e.g., AAPL"
                  maxLength={5}
                />
              </Form.Group>
            </Col>
          </Row>

          <SectionSelection
            selectedSections={selectedSections}
            onChange={handleSectionChange}
            disabled={loading}
          />

          <div className="mt-3 d-flex gap-2">
            <Button
              variant="primary"
              onClick={handleFetchData}
              disabled={fetchLoading || selectedSections.length === 0}
            >
              {fetchLoading ? 'Fetching...' : 'Fetch Data'}
            </Button>

            {rawData && (
              <>
                <Button
                  variant="outline-primary"
                  onClick={handleFetchData}
                  disabled={fetchLoading}
                >
                  Refresh Data
                </Button>
                <Button
                  variant="success"
                  onClick={handleParseData}
                  disabled={parseLoading}
                >
                  {parseLoading ? 'Parsing...' : 'Parse Data'}
                </Button>
              </>
            )}
          </div>
        </Card.Body>
      </Card>

      {/* Raw Data Display */}
      {rawData && dataStatus && (
        <RawDataDisplay
          rawData={rawData}
          status={dataStatus}
          stockId={stockId || ''}
        />
      )}

      {/* Structured Data Display */}
      {structuredData && (
        <StructuredDataDisplay
          structuredData={structuredData}
          stockId={stockId || ''}
        />
      )}
    </>
  );
}
```

**File: frontend/src/components/config/StructuredDataDisplay.tsx** (New)

Complete structured data display component:

```typescript
'use client';

import { useState } from 'react';
import { Card, Accordion, Button, Badge, Row, Col } from 'react-bootstrap';
import SectionCard from './SectionCard';
import PreviewModal from './PreviewModal';

interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface StructuredData {
  sections: Record<string, SectionData>;
  metadata: {
    total_sections: number;
    parsed_at: string;
  };
}

interface StructuredDataDisplayProps {
  structuredData: StructuredData;
  stockId: string;
}

export default function StructuredDataDisplay({
  structuredData,
  stockId
}: StructuredDataDisplayProps) {
  const [expandedSections, setExpandedSections] = useState<Set<string>>(
    new Set(Object.keys(structuredData.sections))
  );
  const [showPreview, setShowPreview] = useState(false);

  const toggleSection = (sectionId: string) => {
    const newExpanded = new Set(expandedSections);
    if (newExpanded.has(sectionId)) {
      newExpanded.delete(sectionId);
    } else {
      newExpanded.add(sectionId);
    }
    setExpandedSections(newExpanded);
  };

  const expandAll = () => {
    setExpandedSections(new Set(Object.keys(structuredData.sections)));
  };

  const collapseAll = () => {
    setExpandedSections(new Set());
  };

  const sectionIds = Object.keys(structuredData.sections).sort((a, b) => {
    return parseInt(a) - parseInt(b);
  });

  // Section ID to API mapping (same as backend)
  const sectionToApiMap: Record<string, string> = {
    "1": "Earnings API", "2": "Earnings API", "3": "Price API", "4": "Price API",
    "5": "Earnings API", "6": "Price API", "7": "Earnings API", "8": "Price API",
    "9": "Earnings API", "10": "Price API", "11": "Earnings API", "12": "Price API",
    "13": "Earnings API", "14": "Price API"
  };

  return (
    <>
      <Card className="mt-4">
        <Card.Header className="d-flex justify-content-between align-items-center">
          <div>
            <h5 className="mb-0">Structured Data</h5>
            <small className="text-muted">
              Stock: {stockId} | {structuredData.metadata.total_sections} sections
            </small>
          </div>
          <div className="d-flex gap-2">
            <Button variant="outline-secondary" size="sm" onClick={expandAll}>
              Expand All
            </Button>
            <Button variant="outline-secondary" size="sm" onClick={collapseAll}>
              Collapse All
            </Button>
            <Button
              variant="primary"
              size="sm"
              onClick={() => setShowPreview(true)}
            >
              Preview Final Data Structure
            </Button>
          </div>
        </Card.Header>
        <Card.Body>
          {sectionIds.length === 0 ? (
            <div className="text-center text-muted py-5">
              <h5>No Structured Data Available</h5>
              <p>Parse the raw data to generate structured sections.</p>
            </div>
          ) : (
            <Accordion activeKey={Array.from(expandedSections)}>
              {sectionIds.map((sectionId) => {
                const section = structuredData.sections[sectionId];
                const sourceApi = sectionToApiMap[sectionId] || "Unknown API";
                const isExpanded = expandedSections.has(sectionId);

                return (
                  <SectionCard
                    key={sectionId}
                    sectionId={sectionId}
                    section={section}
                    sourceApi={sourceApi}
                    isExpanded={isExpanded}
                    onToggle={() => toggleSection(sectionId)}
                  />
                );
              })}
            </Accordion>
          )}
        </Card.Body>
      </Card>

      <PreviewModal
        show={showPreview}
        onHide={() => setShowPreview(false)}
        structuredData={structuredData}
        stockId={stockId}
      />
    </>
  );
}
```

**File: frontend/src/components/config/SectionCard.tsx** (New)

Individual section card with formatted content:

```typescript
'use client';

import { Accordion, Badge, Card } from 'react-bootstrap';

interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface SectionCardProps {
  sectionId: string;
  section: SectionData;
  sourceApi: string;
  isExpanded: boolean;
  onToggle: () => void;
}

export default function SectionCard({
  sectionId,
  section,
  sourceApi,
  isExpanded,
  onToggle
}: SectionCardProps) {
  const formatSectionContent = (data: any) => {
    if (!data) {
      return (
        <div className="alert alert-secondary">
          No data available for this section
        </div>
      );
    }

    // If data has a summary field
    if (data.summary) {
      return (
        <div>
          <p className="fw-bold">Summary:</p>
          <p>{data.summary}</p>

          {data.raw_content && (
            <>
              <p className="fw-bold mt-3">Details:</p>
              <pre className="bg-light p-3 rounded">
                {JSON.stringify(data.raw_content, null, 2)}
              </pre>
            </>
          )}

          {data.data_points !== undefined && (
            <small className="text-muted">
              Data points: {data.data_points}
            </small>
          )}
        </div>
      );
    }

    // Default: render as formatted JSON
    return (
      <pre className="bg-light p-3 rounded">
        {JSON.stringify(data, null, 2)}
      </pre>
    );
  };

  return (
    <Accordion.Item eventKey={sectionId}>
      <Accordion.Header onClick={onToggle}>
        <div className="d-flex justify-content-between align-items-center w-100">
          <div>
            <strong>Section {sectionId}: {section.section_name}</strong>
          </div>
          <div className="d-flex gap-2 align-items-center me-3">
            <Badge bg="info">{sourceApi}</Badge>
            {section.metadata.data_available ? (
              <Badge bg="success">Data Available</Badge>
            ) : (
              <Badge bg="secondary">No Data</Badge>
            )}
            <small className="text-muted">
              {new Date(section.metadata.parsed_at).toLocaleTimeString()}
            </small>
          </div>
        </div>
      </Accordion.Header>
      <Accordion.Body>
        {formatSectionContent(section.data)}
      </Accordion.Body>
    </Accordion.Item>
  );
}
```

**File: frontend/src/components/config/PreviewModal.tsx** (New)

Modal for previewing final data structure:

```typescript
'use client';

import { Modal, Button } from 'react-bootstrap';
import ReactJson from 'react-json-view';

interface StructuredData {
  sections: Record<string, any>;
  metadata: {
    total_sections: number;
    parsed_at: string;
  };
}

interface PreviewModalProps {
  show: boolean;
  onHide: () => void;
  structuredData: StructuredData;
  stockId: string;
}

export default function PreviewModal({
  show,
  onHide,
  structuredData,
  stockId
}: PreviewModalProps) {
  const handleCopyToClipboard = () => {
    const dataStr = JSON.stringify(structuredData, null, 2);
    navigator.clipboard.writeText(dataStr);
    alert('Copied to clipboard!');
  };

  return (
    <Modal show={show} onHide={onHide} size="xl" centered>
      <Modal.Header closeButton>
        <Modal.Title>Final Data Structure Preview</Modal.Title>
      </Modal.Header>
      <Modal.Body style={{ maxHeight: '70vh', overflowY: 'auto' }}>
        <div className="mb-3">
          <p className="mb-1">
            <strong>Stock:</strong> {stockId}
          </p>
          <p className="mb-1">
            <strong>Total Sections:</strong> {structuredData.metadata.total_sections}
          </p>
          <p className="mb-1">
            <strong>Parsed At:</strong>{' '}
            {new Date(structuredData.metadata.parsed_at).toLocaleString()}
          </p>
          <p className="text-muted small">
            This is the exact data structure that will be passed to the LLM for prompt generation.
          </p>
        </div>

        <ReactJson
          src={structuredData}
          theme="rjv-default"
          collapsed={2}
          displayDataTypes={false}
          displayObjectSize={true}
          enableClipboard={true}
          name="structuredData"
        />
      </Modal.Body>
      <Modal.Footer>
        <Button variant="outline-secondary" onClick={handleCopyToClipboard}>
          Copy to Clipboard
        </Button>
        <Button variant="secondary" onClick={onHide}>
          Close
        </Button>
      </Modal.Footer>
    </Modal>
  );
}
```

### TypeScript Type Definitions

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/types/structured_data.ts** (New)

```typescript
export interface SectionMetadata {
  parsed_at: string;
  data_available: boolean;
}

export interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: SectionMetadata;
}

export interface StructuredDataMetadata {
  total_sections: number;
  parsed_at: string;
}

export interface StructuredData {
  sections: Record<string, SectionData>;
  metadata: StructuredDataMetadata;
}

export interface ParseDataResponse {
  structured_data: StructuredData;
  errors: Array<{
    error_type: string;
    message: string;
    timestamp: string;
  }>;
}
```

### Configuration Workspace Layout Update

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/app/config/[triggerId]/page.tsx** (Update)

Wrap with DataProvider:

```typescript
'use client';

import { useParams } from 'next/navigation';
import { useEffect, useState } from 'react';
import { Container, Row, Col } from 'react-bootstrap';
import TriggerContextBar from '@/components/config/TriggerContextBar';
import DataConfiguration from '@/components/config/DataConfiguration';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import { DataProvider } from '@/contexts/DataContext';

export default function ConfigurationWorkspace() {
  const { triggerId } = useParams();
  const [trigger, setTrigger] = useState(null);
  const [configuration, setConfiguration] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadTriggerConfig() {
      try {
        const response = await fetch(`/api/triggers/${triggerId}/config`);
        const data = await response.json();
        setTrigger(data.trigger);
        setConfiguration(data.configuration);
      } catch (error) {
        console.error('Failed to load trigger configuration:', error);
      } finally {
        setLoading(false);
      }
    }

    loadTriggerConfig();
  }, [triggerId]);

  if (loading) {
    return <LoadingSpinner size="lg" message="Loading configuration..." />;
  }

  return (
    <DataProvider>
      <Container fluid className="py-4">
        {/* Breadcrumb */}
        <nav aria-label="breadcrumb" className="mb-3">
          <ol className="breadcrumb">
            <li className="breadcrumb-item"><a href="/">Dashboard</a></li>
            <li className="breadcrumb-item active">{trigger?.name}</li>
          </ol>
        </nav>

        {/* Trigger Context Bar */}
        <TriggerContextBar trigger={trigger} />

        {/* Configuration Panels */}
        <Row className="mt-4">
          <Col lg={12}>
            <DataConfiguration
              triggerId={triggerId as string}
              configuration={configuration}
              onConfigUpdate={setConfiguration}
            />
          </Col>
        </Row>
      </Container>
    </DataProvider>
  );
}
```

### Environment Variables

No new environment variables needed for this story.

### Implementation Notes

**Important Design Decisions**:

1. **React Context**: DataContext provides structured data to entire Configuration Workspace, accessible by prompt editing components in Epic 3.

2. **Collapsible Sections**: Bootstrap Accordion allows users to focus on specific sections. Expand/Collapse All buttons for convenience.

3. **Visual Mapping**: Each section shows source API badge (e.g., "Earnings API") to clarify data origins.

4. **Empty Section Handling**: Sections with no data display "No data available" placeholder instead of blank space.

5. **Preview Modal**: "Preview Final Data Structure" button shows complete JSON as it will be passed to LLM for prompt generation.

6. **Section Numbering**: Sections numbered by ID (1-14) for easy referencing in prompts.

7. **Content Formatting**: Section content formatted intelligently (summary + details if available, otherwise formatted JSON).

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 2.5**:

**Unit Tests** (frontend/__tests__/components/config/):

```typescript
// StructuredDataDisplay.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import StructuredDataDisplay from '@/components/config/StructuredDataDisplay';

describe('StructuredDataDisplay Component', () => {
  const mockStructuredData = {
    sections: {
      "1": {
        section_name: "Earnings Summary",
        section_id: "1",
        data: {
          summary: "Earnings data for AAPL",
          raw_content: { eps: 1.50 },
          data_points: 1
        },
        metadata: {
          parsed_at: "2025-10-29T10:00:00Z",
          data_available: true
        }
      },
      "2": {
        section_name: "Revenue Breakdown",
        section_id: "2",
        data: {
          summary: "Revenue data for AAPL",
          raw_content: { total: 100000000 },
          data_points: 1
        },
        metadata: {
          parsed_at: "2025-10-29T10:00:01Z",
          data_available: true
        }
      }
    },
    metadata: {
      total_sections: 2,
      parsed_at: "2025-10-29T10:00:01Z"
    }
  };

  test('renders structured data with section cards', () => {
    render(
      <StructuredDataDisplay
        structuredData={mockStructuredData}
        stockId="AAPL"
      />
    );

    expect(screen.getByText('Structured Data')).toBeInTheDocument();
    expect(screen.getByText(/Stock: AAPL/)).toBeInTheDocument();
    expect(screen.getByText(/2 sections/)).toBeInTheDocument();
    expect(screen.getByText('Section 1: Earnings Summary')).toBeInTheDocument();
    expect(screen.getByText('Section 2: Revenue Breakdown')).toBeInTheDocument();
  });

  test('expand/collapse all functionality works', () => {
    render(
      <StructuredDataDisplay
        structuredData={mockStructuredData}
        stockId="AAPL"
      />
    );

    const collapseButton = screen.getByText('Collapse All');
    fireEvent.click(collapseButton);

    // Sections should be collapsed
    // (Test would need to check Accordion state)

    const expandButton = screen.getByText('Expand All');
    fireEvent.click(expandButton);

    // Sections should be expanded
  });

  test('displays source API badges', () => {
    render(
      <StructuredDataDisplay
        structuredData={mockStructuredData}
        stockId="AAPL"
      />
    );

    expect(screen.getAllByText('Earnings API').length).toBeGreaterThan(0);
  });

  test('shows preview modal on button click', () => {
    render(
      <StructuredDataDisplay
        structuredData={mockStructuredData}
        stockId="AAPL"
      />
    );

    const previewButton = screen.getByText('Preview Final Data Structure');
    fireEvent.click(previewButton);

    expect(screen.getByText('Final Data Structure Preview')).toBeInTheDocument();
  });

  test('displays empty state when no sections', () => {
    const emptyData = {
      sections: {},
      metadata: { total_sections: 0, parsed_at: "2025-10-29" }
    };

    render(
      <StructuredDataDisplay
        structuredData={emptyData}
        stockId="AAPL"
      />
    );

    expect(screen.getByText('No Structured Data Available')).toBeInTheDocument();
  });
});

// SectionCard.test.tsx
import { render, screen } from '@testing-library/react';
import SectionCard from '@/components/config/SectionCard';

describe('SectionCard Component', () => {
  const mockSection = {
    section_name: "Earnings Summary",
    section_id: "1",
    data: {
      summary: "Earnings data for AAPL",
      raw_content: { eps: 1.50 },
      data_points: 1
    },
    metadata: {
      parsed_at: "2025-10-29T10:00:00Z",
      data_available: true
    }
  };

  test('renders section with content', () => {
    render(
      <SectionCard
        sectionId="1"
        section={mockSection}
        sourceApi="Earnings API"
        isExpanded={true}
        onToggle={() => {}}
      />
    );

    expect(screen.getByText(/Section 1: Earnings Summary/)).toBeInTheDocument();
    expect(screen.getByText('Earnings API')).toBeInTheDocument();
    expect(screen.getByText('Data Available')).toBeInTheDocument();
  });

  test('displays empty state for section with no data', () => {
    const emptySection = {
      ...mockSection,
      data: null,
      metadata: { ...mockSection.metadata, data_available: false }
    };

    render(
      <SectionCard
        sectionId="1"
        section={emptySection}
        sourceApi="Earnings API"
        isExpanded={true}
        onToggle={() => {}}
      />
    );

    expect(screen.getByText('No Data')).toBeInTheDocument();
  });

  test('formats section content correctly', () => {
    render(
      <SectionCard
        sectionId="1"
        section={mockSection}
        sourceApi="Earnings API"
        isExpanded={true}
        onToggle={() => {}}
      />
    );

    expect(screen.getByText(/Summary:/)).toBeInTheDocument();
    expect(screen.getByText(/Earnings data for AAPL/)).toBeInTheDocument();
    expect(screen.getByText(/Data points: 1/)).toBeInTheDocument();
  });
});

// DataContext.test.tsx
import { renderHook, act } from '@testing-library/react';
import { DataProvider, useData } from '@/contexts/DataContext';

describe('DataContext', () => {
  test('provides data state and setters', () => {
    const wrapper = ({ children }) => <DataProvider>{children}</DataProvider>;
    const { result } = renderHook(() => useData(), { wrapper });

    expect(result.current.rawData).toBeNull();
    expect(result.current.structuredData).toBeNull();
    expect(result.current.stockId).toBeNull();

    act(() => {
      result.current.setStockId('AAPL');
    });

    expect(result.current.stockId).toBe('AAPL');
  });

  test('clearData resets all state', () => {
    const wrapper = ({ children }) => <DataProvider>{children}</DataProvider>;
    const { result } = renderHook(() => useData(), { wrapper });

    act(() => {
      result.current.setStockId('AAPL');
      result.current.setRawData({ "1": { data: "test" } });
      result.current.clearData();
    });

    expect(result.current.stockId).toBeNull();
    expect(result.current.rawData).toBeNull();
  });

  test('throws error when used outside provider', () => {
    expect(() => {
      renderHook(() => useData());
    }).toThrow('useData must be used within a DataProvider');
  });
});
```

**Integration Tests**:

```typescript
// Full workflow test
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import ConfigurationWorkspace from '@/app/config/[triggerId]/page';

describe('Complete Data Workflow', () => {
  test('fetch, parse, and display structured data', async () => {
    // Mock API responses
    global.fetch = jest.fn()
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          trigger: { name: 'Test Trigger' },
          configuration: { data_sections: ['1', '2'] }
        })
      })
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          raw_data: { "1": { data: "test" } },
          status: { "1": { status: "success" } }
        })
      })
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          structured_data: {
            sections: {
              "1": {
                section_name: "Earnings Summary",
                section_id: "1",
                data: { summary: "Test data" },
                metadata: { parsed_at: "2025-10-29", data_available: true }
              }
            },
            metadata: { total_sections: 1, parsed_at: "2025-10-29" }
          },
          errors: []
        })
      });

    render(<ConfigurationWorkspace />);

    // Wait for page load
    await waitFor(() => {
      expect(screen.getByText('Test Trigger')).toBeInTheDocument();
    });

    // Click Fetch Data
    const fetchButton = screen.getByText('Fetch Data');
    fireEvent.click(fetchButton);

    // Wait for raw data display
    await waitFor(() => {
      expect(screen.getByText('Raw Data Display')).toBeInTheDocument();
    });

    // Click Parse Data
    const parseButton = screen.getByText('Parse Data');
    fireEvent.click(parseButton);

    // Wait for structured data display
    await waitFor(() => {
      expect(screen.getByText('Structured Data')).toBeInTheDocument();
      expect(screen.getByText('Section 1: Earnings Summary')).toBeInTheDocument();
    });
  });
});
```

**Manual Verification Checklist**:
1. StructuredDataDisplay component appears after parsing
2. Sections displayed in Bootstrap Cards with correct names
3. Section headers show: section number, name, and source API
4. Each section shows "Data Available" or "No Data" badge
5. Collapsible sections work (expand/collapse individual sections)
6. "Expand All" button expands all sections
7. "Collapse All" button collapses all sections
8. Section content formatted correctly (summary + details)
9. Empty sections display "No data available" placeholder
10. "Preview Final Data Structure" button opens modal
11. Modal shows complete JSON with syntax highlighting
12. Modal "Copy to Clipboard" button works
13. DataContext persists data across component re-renders
14. No console errors in browser
15. Responsive layout works on desktop and tablet

## News CMS Workflow Updates

This story integrates with the News CMS Workflow Feature (Epic 6). Key alignments:

### Integration Points:
- **Data Mode Conditional UI**: Show 14 sections ONLY if data_mode is NEW or OLD_NEW (from Story 2.3 v2.0)
- **Async Job Integration**: Poll job status from Story 2.4 v2.0 until completed, then display 14 sections
- **WorkflowContext Storage**: Save selected sections and section_order for use in Story 2.6 (data merging) and Story 4.3 (news generation)
- **14 Specific Sections**: Company Information, Income Statement (Quarterly), Income Statement (Annual), Balance Sheet, Cash Flow, Ratios, Valuation, Shareholding, Stock Performance, Technical Analysis, Quality Assessment, Financial Trend, Proprietary Score, Peer Comparison
- **Drag-Drop with React DnD**: section_order parameter passed to backend for section reordering

### Dependencies:
- Story 2.3 v2.0 for data_mode selection and stockid input
- Story 2.4 v2.0 for async structured data generation
- WorkflowContext for sharing data_config across components

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 2 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |
| 2025-10-30 | 2.0 | Aligned with News CMS Workflow Feature - updated prerequisites for Story 2.3 v2.0 and Story 2.4 v2.0, documented 14-section integration, data mode conditional UI | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
