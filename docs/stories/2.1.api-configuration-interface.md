# Story 2.1: API Configuration Interface

## Status

âœ… **Implemented** - Updated for Data Configuration Workflow v2.3 (November 2025)

## Story

**As a** content manager,
**I want** to add and remove data APIs from a trigger's configuration,
**so that** I can control which data sources are used for news generation.

**Note**: This story is part of the Data Configuration phase. As of v2.3, the workflow is:
1. **Data Configuration Tab**: Fetch/generate data â†’ SELECT sections with checkboxes â†’ "Use This Data" button
2. **Section Management Tab**: REORDER selected sections with drag-and-drop

## Acceptance Criteria

1. Configuration Workspace page loads trigger details from `GET /api/triggers/:id/config` (includes currently configured APIs)
1a. **New**: Data Configuration tab includes section selection UI after data fetch/generation (see Story 2.5)
2. "Data Sources" panel displays list of currently configured APIs with remove button for each
3. "Add API" dropdown or modal shows predefined list of available data APIs (from backend registry or database)
4. Clicking "Add API" sends `POST /api/triggers/:id/config/apis` with API identifier, updates UI optimistically
5. Clicking "Remove" button sends `DELETE /api/triggers/:id/config/apis/:apiId`, updates UI
6. Backend validates that required APIs are present before allowing removal (FR5)
7. Changes auto-save to MongoDB Configuration collection
8. Toast notification confirms successful add/remove operations
9. Error handling prevents adding duplicate APIs and displays clear error message

## Tasks / Subtasks

- [ ] Task 1: Create Configuration Workspace page and routing (AC: 1)
  - [ ] Create frontend/src/app/config/[triggerId]/page.tsx
  - [ ] Implement GET /api/triggers/:id/config API call
  - [ ] Display trigger context information (name, description, status)
  - [ ] Create layout with collapsible panels
- [ ] Task 2: Build Data Sources panel UI (AC: 2, 3)
  - [ ] Create DataConfiguration.tsx component
  - [ ] Display list of currently configured APIs
  - [ ] Add remove button for each API
  - [ ] Implement "Add API" dropdown/modal
  - [ ] Show available APIs from registry
- [ ] Task 3: Implement POST API endpoint for adding APIs (AC: 4, 6, 7)
  - [ ] Create POST /api/triggers/:id/config/apis endpoint
  - [ ] Validate API identifier exists in registry
  - [ ] Prevent duplicate API additions
  - [ ] Save changes to MongoDB Configuration collection
  - [ ] Return updated configuration
- [ ] Task 4: Implement DELETE API endpoint for removing APIs (AC: 5, 6, 7)
  - [ ] Create DELETE /api/triggers/:id/config/apis/:apiId endpoint
  - [ ] Validate required APIs are not removed
  - [ ] Remove API from configuration
  - [ ] Save changes to MongoDB
  - [ ] Return updated configuration
- [ ] Task 5: Implement frontend API integration (AC: 4, 5, 8, 9)
  - [ ] Create API client methods for add/remove
  - [ ] Implement optimistic UI updates
  - [ ] Display toast notifications for success
  - [ ] Handle error states (duplicate APIs, required API removal)
  - [ ] Revert optimistic updates on failure
- [ ] Task 6: Write unit and integration tests
  - [ ] Test DataConfiguration component rendering
  - [ ] Test add API endpoint validation
  - [ ] Test remove API endpoint validation
  - [ ] Test error handling for duplicate APIs
  - [ ] Test required API validation

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 1.4 - Completion]

Before starting this story, ensure Story 1.4 is complete:
- Trigger dashboard displays list of triggers
- Dropdown trigger selector works
- Trigger selection navigates to /config/:triggerId
- GET /api/triggers endpoint exists
- MongoDB contains seed trigger data

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ config/
â”‚       â””â”€â”€ [triggerId]/
â”‚           â””â”€â”€ page.tsx                # Configuration Workspace main page (NEW)
â”œâ”€â”€ components/
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ TriggerContextBar.tsx       # Stock ID input + prompt type selection (NEW)
â”‚       â”œâ”€â”€ DataConfiguration.tsx       # API/Section configuration panel (NEW)
â”‚       â””â”€â”€ SectionSelection.tsx        # Multi-select dropdown component (NEW)
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ api.ts                          # API client (extend existing)
â””â”€â”€ types/
    â””â”€â”€ configuration.ts                # TypeScript types (NEW)
```

**Backend files to create/modify** in `backend/app/`:
```
backend/app/
â”œâ”€â”€ routers/
â”‚   â””â”€â”€ configuration.py                # Configuration CRUD endpoints (NEW)
â”œâ”€â”€ services/
â”‚   â””â”€â”€ configuration_service.py        # Configuration business logic (NEW)
â””â”€â”€ data_adapters/
    â”œâ”€â”€ registry.py                     # API adapter registry (NEW - Story 2.2)
    â””â”€â”€ base.py                         # Base adapter class (NEW - Story 2.2)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **Next.js**: 14+ with App Router - Dynamic routing for /config/[triggerId]
- **React-Bootstrap**: For panels, buttons, dropdowns, modals
- **TypeScript**: Type definitions for Configuration model
- **Axios or Fetch**: HTTP client for API calls

**Backend Stack**:
- **FastAPI**: REST API endpoints
- **Pydantic**: v2 - Configuration model validation
- **Motor**: Async MongoDB operations
- **Python**: 3.11+ - Async/await for database operations

### Data Models

[Source: architecture.md - Data Models and APIs - Planned Data Models]

**Configuration Model** (backend/app/models/configuration.py):
```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import List, Dict, Optional

class PromptConfig(BaseModel):
    template: str
    version_history: List[Dict]
    last_test_generation: Optional[Dict] = None

class Configuration(BaseModel):
    id: str = Field(alias="_id")
    trigger_id: str
    version: int

    # SHARED across all prompt types
    data_sections: List[str]            # Selected section IDs (e.g., ["1", "2", "3"])
    section_order: List[str]            # Order of sections
    model_config: Dict                  # {selected_models, temperature, max_tokens}

    # SEPARATE per prompt type
    prompts: Dict[str, PromptConfig]    # {"paid": PromptConfig, "unpaid": PromptConfig, "crawler": PromptConfig}

    # Metadata
    created_by: str
    created_at: datetime
    updated_at: datetime
    published_at: Optional[datetime] = None
    is_active: bool = False
```

**Note**: For Story 2.1, we're creating the Configuration Workspace page. The actual API configuration uses a **section selection dropdown** pattern (14 hardcoded sections), not individual API add/remove. This story sets up the infrastructure.

### API Specifications

[Source: architecture.md - Data Models and APIs - Epic 2 - Data Pipeline APIs]

**Get Trigger Configuration**:
```
GET /api/triggers/:id/config
Response: {
  "trigger_id": "trigger_001",
  "data_sections": ["1", "2", "3"],
  "section_order": ["1", "2", "3"],
  "prompts": {
    "paid": {
      "template": "...",
      "version_history": [],
      "last_test_generation": null
    }
  },
  "model_config": {},
  "version": 1,
  "is_active": false,
  "created_at": "2025-10-29T10:00:00Z",
  "updated_at": "2025-10-29T10:00:00Z"
}
```

**Update Section Configuration**:
```
POST /api/triggers/:id/config/sections
Body: {
  "section_ids": ["1", "2", "3", "5", "7"]
}
Response: {
  "success": true,
  "configuration": { /* updated config */ }
}
```

### Frontend Component Specifications

[Source: front-end-spec.md - Component Library & Design System]

**File: frontend/src/app/config/[triggerId]/page.tsx**

Configuration Workspace main page with collapsible panels:

```typescript
'use client';

import { useParams } from 'next/navigation';
import { useEffect, useState } from 'react';
import { Container, Row, Col, Spinner } from 'react-bootstrap';
import TriggerContextBar from '@/components/config/TriggerContextBar';
import DataConfiguration from '@/components/config/DataConfiguration';
import LoadingSpinner from '@/components/common/LoadingSpinner';

export default function ConfigurationWorkspace() {
  const { triggerId } = useParams();
  const [trigger, setTrigger] = useState(null);
  const [configuration, setConfiguration] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadTriggerConfig() {
      try {
        const response = await fetch(`/api/triggers/${triggerId}/config`);
        const data = await response.json();
        setTrigger(data.trigger);
        setConfiguration(data.configuration);
      } catch (error) {
        console.error('Failed to load trigger configuration:', error);
      } finally {
        setLoading(false);
      }
    }

    loadTriggerConfig();
  }, [triggerId]);

  if (loading) {
    return <LoadingSpinner size="lg" message="Loading configuration..." />;
  }

  return (
    <Container fluid className="py-4">
      {/* Breadcrumb navigation */}
      <nav aria-label="breadcrumb" className="mb-3">
        <ol className="breadcrumb">
          <li className="breadcrumb-item"><a href="/">Dashboard</a></li>
          <li className="breadcrumb-item active">{trigger?.name}</li>
        </ol>
      </nav>

      {/* Trigger Context Bar */}
      <TriggerContextBar trigger={trigger} />

      {/* Configuration Panels */}
      <Row className="mt-4">
        <Col lg={12}>
          <DataConfiguration
            triggerId={triggerId}
            configuration={configuration}
            onConfigUpdate={setConfiguration}
          />
        </Col>
      </Row>
    </Container>
  );
}
```

**File: frontend/src/components/config/TriggerContextBar.tsx**

Context bar with stock ID input and prompt type selection:

```typescript
'use client';

import { useState } from 'react';
import { Card, Form, Row, Col, Badge } from 'react-bootstrap';

interface TriggerContextBarProps {
  trigger: any;
}

export default function TriggerContextBar({ trigger }: TriggerContextBarProps) {
  const [stockId, setStockId] = useState('AAPL');
  const [selectedTypes, setSelectedTypes] = useState({
    paid: true,
    unpaid: false,
    crawler: false
  });

  const handleTypeChange = (type: string) => {
    setSelectedTypes(prev => ({
      ...prev,
      [type]: !prev[type]
    }));
  };

  return (
    <Card className="border-primary">
      <Card.Body>
        <Row className="align-items-center">
          <Col md={3}>
            <h5 className="mb-0">{trigger?.name}</h5>
            <Badge bg="secondary">{trigger?.status}</Badge>
          </Col>
          <Col md={3}>
            <Form.Group>
              <Form.Label>Stock ID (for testing)</Form.Label>
              <Form.Control
                type="text"
                value={stockId}
                onChange={(e) => setStockId(e.target.value)}
                placeholder="e.g., AAPL"
              />
            </Form.Group>
          </Col>
          <Col md={6}>
            <Form.Label>Prompt Types</Form.Label>
            <div className="d-flex gap-3">
              <Form.Check
                type="checkbox"
                label="ðŸ’° Paid"
                checked={selectedTypes.paid}
                onChange={() => handleTypeChange('paid')}
              />
              <Form.Check
                type="checkbox"
                label="ðŸ†“ Unpaid"
                checked={selectedTypes.unpaid}
                onChange={() => handleTypeChange('unpaid')}
              />
              <Form.Check
                type="checkbox"
                label="ðŸ•·ï¸ Crawler"
                checked={selectedTypes.crawler}
                onChange={() => handleTypeChange('crawler')}
              />
            </div>
          </Col>
        </Row>
      </Card.Body>
    </Card>
  );
}
```

**File: frontend/src/components/config/DataConfiguration.tsx**

Data configuration panel with section selection:

```typescript
'use client';

import { useState } from 'react';
import { Card, Button, Alert } from 'react-bootstrap';
import SectionSelection from './SectionSelection';

interface DataConfigurationProps {
  triggerId: string;
  configuration: any;
  onConfigUpdate: (config: any) => void;
}

export default function DataConfiguration({
  triggerId,
  configuration,
  onConfigUpdate
}: DataConfigurationProps) {
  const [selectedSections, setSelectedSections] = useState(
    configuration?.data_sections || []
  );
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSectionChange = async (sections: string[]) => {
    setSelectedSections(sections);

    try {
      setLoading(true);
      const response = await fetch(`/api/triggers/${triggerId}/config/sections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ section_ids: sections })
      });

      if (!response.ok) throw new Error('Failed to update sections');

      const data = await response.json();
      onConfigUpdate(data.configuration);
      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card>
      <Card.Header>
        <h5>Data Configuration</h5>
      </Card.Header>
      <Card.Body>
        {error && <Alert variant="danger">{error}</Alert>}

        <SectionSelection
          selectedSections={selectedSections}
          onChange={handleSectionChange}
          disabled={loading}
        />

        <Button
          variant="primary"
          className="mt-3"
          disabled={selectedSections.length === 0}
        >
          Use This Data
        </Button>
      </Card.Body>
    </Card>
  );
}
```

### Backend API Implementation

[Source: architecture.md - Source Tree and Module Organization - Backend Module Structure]

**File: backend/app/routers/configuration.py**

```python
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from ..database import get_database
from ..models.configuration import Configuration
from ..services.configuration_service import ConfigurationService
import logging

router = APIRouter(prefix="/api/triggers/{trigger_id}/config", tags=["configuration"])
logger = logging.getLogger(__name__)

@router.get("")
async def get_trigger_configuration(trigger_id: str, db = Depends(get_database)):
    """
    Get current configuration for a trigger
    Returns trigger info and configuration
    """
    service = ConfigurationService(db)

    try:
        trigger = await db.triggers.find_one({"_id": trigger_id})
        if not trigger:
            raise HTTPException(status_code=404, detail="Trigger not found")

        config = await service.get_configuration(trigger_id)

        return {
            "trigger": trigger,
            "configuration": config
        }
    except Exception as e:
        logger.error(f"Failed to get configuration: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/sections")
async def update_sections(
    trigger_id: str,
    section_ids: List[str],
    db = Depends(get_database)
):
    """
    Update selected data sections for trigger
    """
    service = ConfigurationService(db)

    try:
        config = await service.update_sections(trigger_id, section_ids)
        return {
            "success": True,
            "configuration": config
        }
    except Exception as e:
        logger.error(f"Failed to update sections: {e}")
        raise HTTPException(status_code=400, detail=str(e))
```

**File: backend/app/services/configuration_service.py**

```python
from datetime import datetime
from typing import List, Dict, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase

class ConfigurationService:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db

    async def get_configuration(self, trigger_id: str) -> Optional[Dict]:
        """Get current configuration for trigger, create default if not exists"""
        config = await self.db.configurations.find_one({
            "trigger_id": trigger_id,
            "is_active": False  # Draft configuration
        })

        if not config:
            # Create default configuration
            config = {
                "_id": f"config_{trigger_id}_{int(datetime.utcnow().timestamp())}",
                "trigger_id": trigger_id,
                "version": 1,
                "data_sections": ["1", "2", "3", "5", "7"],  # Backend default selections
                "section_order": ["1", "2", "3", "5", "7"],
                "model_config": {},
                "prompts": {
                    "paid": {
                        "template": "",
                        "version_history": [],
                        "last_test_generation": None
                    }
                },
                "created_by": "system",
                "created_at": datetime.utcnow(),
                "updated_at": datetime.utcnow(),
                "is_active": False
            }
            await self.db.configurations.insert_one(config)

        return config

    async def update_sections(self, trigger_id: str, section_ids: List[str]) -> Dict:
        """Update selected data sections"""
        config = await self.get_configuration(trigger_id)

        # Update sections and section order
        update_data = {
            "$set": {
                "data_sections": section_ids,
                "section_order": section_ids,
                "updated_at": datetime.utcnow()
            }
        }

        await self.db.configurations.update_one(
            {"_id": config["_id"]},
            update_data
        )

        # Return updated configuration
        return await self.db.configurations.find_one({"_id": config["_id"]})
```

### Environment Variables

[Source: architecture.md - Development and Deployment - Environment Variables]

No new environment variables needed for this story. Uses existing:
- `MONGODB_URI` - MongoDB connection string
- `MONGODB_DB_NAME` - Database name

### Implementation Notes

[Source: front-end-spec.md - Component Library - Data Configuration Panel]

**Important Design Decisions**:

1. **Section Selection Pattern**: Uses multi-select dropdown with checkboxes for 14 hardcoded data sections, NOT individual API add/remove. This simplifies the UX.

2. **Backend Default Selections**: Backend provides default section IDs (["1", "2", "3", "5", "7"]) when configuration is first created.

3. **Auto-Save**: Section changes auto-save to MongoDB immediately (no manual save button).

4. **Prompt Type Selection**: Paid prompt always visible and checked by default. Unpaid and crawler are optional checkboxes.

5. **Optimistic Updates**: Frontend updates immediately, reverts on error.

6. **Toast Notifications**: Use React-Bootstrap Toast component for success/error messages.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 2.1**:

**Unit Tests** (frontend/__tests__/components/config/):

```typescript
// DataConfiguration.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import DataConfiguration from '@/components/config/DataConfiguration';

describe('DataConfiguration Component', () => {
  const mockConfig = {
    data_sections: ["1", "2", "3"],
    section_order: ["1", "2", "3"]
  };

  test('renders section selection dropdown', () => {
    render(
      <DataConfiguration
        triggerId="trigger_001"
        configuration={mockConfig}
        onConfigUpdate={jest.fn()}
      />
    );

    expect(screen.getByText('Data Configuration')).toBeInTheDocument();
  });

  test('updates sections on selection change', async () => {
    const mockUpdate = jest.fn();
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true, configuration: mockConfig })
      })
    );

    render(
      <DataConfiguration
        triggerId="trigger_001"
        configuration={mockConfig}
        onConfigUpdate={mockUpdate}
      />
    );

    // Simulate section change
    fireEvent.click(screen.getByText('Section 5'));

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/triggers/trigger_001/config/sections',
        expect.objectContaining({ method: 'POST' })
      );
    });
  });

  test('displays error message on update failure', async () => {
    global.fetch = jest.fn(() =>
      Promise.reject(new Error('Failed to update sections'))
    );

    render(
      <DataConfiguration
        triggerId="trigger_001"
        configuration={mockConfig}
        onConfigUpdate={jest.fn()}
      />
    );

    fireEvent.click(screen.getByText('Section 5'));

    await waitFor(() => {
      expect(screen.getByText(/Failed to update sections/i)).toBeInTheDocument();
    });
  });
});
```

**Integration Tests** (backend/tests/test_configuration.py):

```python
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_get_trigger_configuration(client: AsyncClient):
    """Test GET /api/triggers/:id/config endpoint"""
    response = await client.get("/api/triggers/trigger_001/config")
    assert response.status_code == 200
    data = response.json()
    assert "trigger" in data
    assert "configuration" in data
    assert data["configuration"]["trigger_id"] == "trigger_001"

@pytest.mark.asyncio
async def test_update_sections(client: AsyncClient):
    """Test POST /api/triggers/:id/config/sections endpoint"""
    response = await client.post(
        "/api/triggers/trigger_001/config/sections",
        json={"section_ids": ["1", "2", "3", "5", "7"]}
    )
    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert data["configuration"]["data_sections"] == ["1", "2", "3", "5", "7"]

@pytest.mark.asyncio
async def test_update_sections_with_invalid_trigger(client: AsyncClient):
    """Test section update with non-existent trigger"""
    response = await client.post(
        "/api/triggers/invalid_trigger/config/sections",
        json={"section_ids": ["1", "2"]}
    )
    assert response.status_code == 404

@pytest.mark.asyncio
async def test_configuration_auto_creation(client: AsyncClient, db):
    """Test that configuration is auto-created if not exists"""
    # Delete existing configuration
    await db.configurations.delete_many({"trigger_id": "trigger_001"})

    # Get configuration should create default
    response = await client.get("/api/triggers/trigger_001/config")
    assert response.status_code == 200
    data = response.json()
    assert data["configuration"]["data_sections"] == ["1", "2", "3", "5", "7"]
```

**Manual Verification**:
1. Navigate to /config/trigger_001 shows Configuration Workspace
2. Trigger Context Bar displays trigger name and stock ID input
3. Data Configuration panel shows section selection dropdown
4. Selecting/deselecting sections updates UI immediately
5. Section changes persist to database (verify in MongoDB)
6. Toast notification appears on successful update
7. Error message displays if API call fails
8. "Use This Data" button is enabled when sections selected
9. Breadcrumb navigation works correctly
10. Page responsive at desktop and tablet breakpoints

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 2 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
