# Story 3.4: Prompt Preview with Data Substitution (Per Prompt Type)

## Status

Draft

## Story

**As a** content manager,
**I want** to preview my prompt with actual data substituted for placeholders for the selected prompt type,
**so that** I can see exactly what will be sent to the LLM before generating.

## Acceptance Criteria

1. "Preview Prompt" button triggers substitution of placeholders with actual structured data for currently active tab
2. Preview displayed in read-only panel (Bootstrap Card or Modal) showing final prompt text for selected prompt type
3. Placeholders replaced with real values from current structured data state (shared across all types)
4. Sections included in order defined by section reordering (shared across all types)
5. Missing data (placeholder references non-existent value) shown with placeholder in red or warning marker
6. Preview updates automatically when data, section order, or tab selection changes
7. Meets FR15: preview of final prompt with actual data substituted per prompt type
8. Preview displays estimated token count for LLM (approximate calculation based on character count)
9. "Copy to Clipboard" button allows copying previewed prompt for external testing
10. Preview includes metadata: stock ID, trigger name, prompt type (paid/unpaid/crawler), timestamp
11. Modal shows tabs to preview all checked prompt types if desired

## Tasks / Subtasks

- [ ] Task 1: Create PreviewContext provider for preview state management (AC: 6)
  - [ ] Create frontend/src/contexts/PreviewContext.tsx
  - [ ] Track preview modal visibility and active tab
  - [ ] Store substituted prompt content per prompt type
  - [ ] Store metadata (stock_id, trigger_name, timestamp)
- [ ] Task 2: Implement data substitution engine (AC: 1, 2, 3, 4)
  - [ ] Create utility function to replace placeholders with actual data
  - [ ] Handle missing data (show placeholder in red or warning marker)
  - [ ] Respect section order from DataContext
  - [ ] Apply to currently active prompt type only
- [ ] Task 3: Create PreviewModal component (AC: 2, 7, 8, 10)
  - [ ] Create frontend/src/components/config/PreviewModal.tsx
  - [ ] Display read-only preview of final prompt
  - [ ] Show estimated token count (character count / 4)
  - [ ] Include metadata: stock ID, trigger name, prompt type, timestamp
  - [ ] Add "Copy to Clipboard" button
- [ ] Task 4: Add tabbed preview for multiple types (AC: 11)
  - [ ] Show tabs in modal for all checked prompt types
  - [ ] Allow switching between prompt type previews without closing modal
  - [ ] Each tab shows substituted prompt for that type
- [ ] Task 5: Implement auto-update on data/order/tab changes (AC: 6)
  - [ ] Re-run substitution when DataContext changes
  - [ ] Re-run substitution when section order changes
  - [ ] Re-run substitution when active tab changes
  - [ ] Update preview automatically (no manual refresh needed)
- [ ] Task 6: Create "Preview Prompt" button in editor (AC: 1)
  - [ ] Add button to PromptEditor component
  - [ ] Button opens PreviewModal with substituted content
  - [ ] Show loading state during substitution
  - [ ] Handle substitution errors gracefully
- [ ] Task 7: Integrate with ValidationContext (AC: 5)
  - [ ] Show validation warnings in preview
  - [ ] Highlight missing data with red markers
  - [ ] Display actionable error messages for missing placeholders
- [ ] Task 8: Write unit and integration tests
  - [ ] Test placeholder substitution with various data types
  - [ ] Test missing data handling
  - [ ] Test token count estimation accuracy
  - [ ] Test clipboard copy functionality
  - [ ] Test multi-type preview switching

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 3.3 - Completion]

Before starting this story, ensure Story 3.3 is complete:
- ValidationContext and validation logic implemented
- Placeholder extraction and validation working
- Invalid placeholder detection and marking
- ValidationSummary component displaying errors
- DataContext provides structured data with section order

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ config/
â”‚       â”œâ”€â”€ PreviewModal.tsx                # Preview panel (NEW)
â”‚       â”œâ”€â”€ PromptEditor.tsx                # Add Preview button (MODIFY)
â”‚       â”œâ”€â”€ ConfigurationWorkspace.tsx      # Integrate PreviewModal (MODIFY)
â”‚       â””â”€â”€ PromptTabs.tsx                  # Update if needed for preview tabs
â”œâ”€â”€ contexts/
â”‚   â”œâ”€â”€ PreviewContext.tsx                  # Preview state management (NEW)
â”‚   â”œâ”€â”€ ValidationContext.tsx               # Existing validation context
â”‚   â”œâ”€â”€ PromptContext.tsx                   # Existing prompt context
â”‚   â””â”€â”€ DataContext.tsx                     # Existing data context
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ dataSubstitution.ts                 # Data substitution engine (NEW)
â””â”€â”€ types/
    â””â”€â”€ preview.ts                          # TypeScript types for preview (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **React Bootstrap**: Modal and tabs components
- **React Context API**: PreviewContext for preview state
- **Clipboard API**: For copy-to-clipboard functionality
- **React hooks**: useEffect for auto-update on dependency changes

### Data Substitution Algorithm

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Process**:
1. Parse prompt to extract all placeholders (`{{section}}` and `{data.field}`)
2. For each placeholder:
   - If section reference: Look up section data in structuredData
   - If field reference: Navigate nested object path in data
   - Replace with actual value if found
   - If not found: Keep placeholder with red warning marker
3. Respect section order (reorder data according to sectionOrder)
4. Return substituted text with metadata (valid/invalid placeholders)

**Example**:
```
Prompt: "The stock {{ticker}} has {{earnings_summary}} data and {data.price.current}"
Data: {
  ticker: "AAPL",
  earnings_summary: "Strong Q3 earnings",
  price: { current: "$150.25" }
}
Result: "The stock AAPL has Strong Q3 earnings data and $150.25"
```

### React Context for Preview State

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/PreviewContext.tsx** (New)

Complete preview state management:

```typescript
'use client';

import React, { createContext, useContext, useState, useCallback, useEffect, ReactNode } from 'react';
import { usePrompt } from './PromptContext';
import { useData } from './DataContext';
import { useValidation } from './ValidationContext';
import { substitutePlaceholders } from '@/lib/dataSubstitution';

type PromptType = 'paid' | 'unpaid' | 'crawler';

interface PreviewContent {
  prompt: string;
  substitutedPrompt: string;
  validPlaceholders: string[];
  missingPlaceholders: string[];
  estimatedTokens: number;
  characterCount: number;
}

interface PreviewMetadata {
  stockId: string | null;
  triggerName: string;
  promptType: PromptType;
  timestamp: Date;
}

interface PreviewContextType {
  isModalOpen: boolean;
  openModal: () => void;
  closeModal: () => void;
  previewContent: Record<PromptType, PreviewContent>;
  previewMetadata: PreviewMetadata | null;
  activePreviewTab: PromptType;
  setActivePreviewTab: (type: PromptType) => void;
  isGenerating: boolean;
  error: string | null;
}

const PreviewContext = createContext<PreviewContextType | undefined>(undefined);

export function PreviewProvider({ children }: { children: ReactNode }) {
  const { prompts, activeTab, checkedTypes } = usePrompt();
  const { structuredData, sectionOrder, stockId } = useData();
  const { validation } = useValidation();

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [activePreviewTab, setActivePreviewTab] = useState<PromptType>('paid');
  const [previewContent, setPreviewContent] = useState<Record<PromptType, PreviewContent>>({
    paid: {
      prompt: '',
      substitutedPrompt: '',
      validPlaceholders: [],
      missingPlaceholders: [],
      estimatedTokens: 0,
      characterCount: 0
    },
    unpaid: {
      prompt: '',
      substitutedPrompt: '',
      validPlaceholders: [],
      missingPlaceholders: [],
      estimatedTokens: 0,
      characterCount: 0
    },
    crawler: {
      prompt: '',
      substitutedPrompt: '',
      validPlaceholders: [],
      missingPlaceholders: [],
      estimatedTokens: 0,
      characterCount: 0
    }
  });
  const [previewMetadata, setPreviewMetadata] = useState<PreviewMetadata | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Generate preview content when modal opens or dependencies change
  useEffect(() => {
    if (!isModalOpen || !structuredData) return;

    setIsGenerating(true);
    setError(null);

    try {
      // Generate preview for all checked types
      const updatedPreview: Record<PromptType, PreviewContent> = { ...previewContent };

      (['paid', 'unpaid', 'crawler'] as PromptType[]).forEach(type => {
        if (!checkedTypes.has(type)) return;

        const promptText = prompts[type].content;
        const result = substitutePlaceholders(promptText, structuredData, sectionOrder);

        const characterCount = result.substitutedPrompt.length;
        const estimatedTokens = Math.ceil(characterCount / 4); // Rough approximation

        updatedPreview[type] = {
          prompt: promptText,
          substitutedPrompt: result.substitutedPrompt,
          validPlaceholders: result.validPlaceholders,
          missingPlaceholders: result.missingPlaceholders,
          estimatedTokens,
          characterCount
        };
      });

      setPreviewContent(updatedPreview);
      setPreviewMetadata({
        stockId: stockId || 'Not specified',
        triggerName: 'Trigger Name', // TODO: Get from context
        promptType: activeTab,
        timestamp: new Date()
      });

      // Set initial preview tab to active tab
      setActivePreviewTab(activeTab);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to generate preview');
    } finally {
      setIsGenerating(false);
    }
  }, [isModalOpen, structuredData, sectionOrder, prompts, checkedTypes, activeTab, stockId]);

  const openModal = useCallback(() => {
    setIsModalOpen(true);
  }, []);

  const closeModal = useCallback(() => {
    setIsModalOpen(false);
  }, []);

  const value: PreviewContextType = {
    isModalOpen,
    openModal,
    closeModal,
    previewContent,
    previewMetadata,
    activePreviewTab,
    setActivePreviewTab,
    isGenerating,
    error
  };

  return <PreviewContext.Provider value={value}>{children}</PreviewContext.Provider>;
}

export function usePreview() {
  const context = useContext(PreviewContext);
  if (context === undefined) {
    throw new Error('usePreview must be used within a PreviewProvider');
  }
  return context;
}
```

**File: frontend/src/lib/dataSubstitution.ts** (New)

Data substitution engine:

```typescript
interface SectionData {
  section_name: string;
  section_id: string;
  data: any;
  metadata: {
    parsed_at: string;
    data_available: boolean;
  };
}

interface SubstitutionResult {
  substitutedPrompt: string;
  validPlaceholders: string[];
  missingPlaceholders: string[];
}

const PLACEHOLDER_PATTERN = /\{\{([a-zA-Z_][a-zA-Z0-9_]*)\}\}|\{data\.([a-zA-Z_][a-zA-Z0-9_.]*)\}/g;

export function substitutePlaceholders(
  prompt: string,
  structuredData: Record<string, SectionData>,
  sectionOrder: string[]
): SubstitutionResult {
  const validPlaceholders: Set<string> = new Set();
  const missingPlaceholders: Set<string> = new Set();
  let substitutedPrompt = prompt;

  // Sort data by section order
  const orderedSections: Record<string, SectionData> = {};
  sectionOrder.forEach(sectionId => {
    if (structuredData[sectionId]) {
      orderedSections[sectionId] = structuredData[sectionId];
    }
  });

  const replacements: Array<{ placeholder: string; value: string; start: number; end: number }> = [];
  let match;

  // Reset regex
  PLACEHOLDER_PATTERN.lastIndex = 0;

  while ((match = PLACEHOLDER_PATTERN.exec(prompt)) !== null) {
    const fullMatch = match[0];
    const sectionMatch = match[1];
    const fieldMatch = match[2];
    let replacementValue = '';
    let found = false;

    if (sectionMatch) {
      // Section reference: {{section_name}}
      const section = Object.values(orderedSections).find(
        s => s.section_name === sectionMatch || s.section_id === sectionMatch
      );

      if (section && section.data) {
        replacementValue = JSON.stringify(section.data, null, 2);
        validPlaceholders.add(fullMatch);
        found = true;
      } else {
        missingPlaceholders.add(fullMatch);
      }
    } else if (fieldMatch) {
      // Field reference: {data.field.nested}
      const fieldPath = fieldMatch.split('.');
      let current: any = structuredData;

      for (const key of fieldPath) {
        if (current && typeof current === 'object' && key in current) {
          current = current[key];
        } else {
          current = undefined;
          break;
        }
      }

      if (current !== undefined) {
        replacementValue = String(current);
        validPlaceholders.add(fullMatch);
        found = true;
      } else {
        missingPlaceholders.add(fullMatch);
      }
    }

    if (found) {
      replacements.push({
        placeholder: fullMatch,
        value: replacementValue,
        start: match.index,
        end: match.index + fullMatch.length
      });
    }
  }

  // Apply replacements in reverse order to maintain correct indices
  replacements.reverse().forEach(replacement => {
    substitutedPrompt =
      substitutedPrompt.slice(0, replacement.start) +
      replacement.value +
      substitutedPrompt.slice(replacement.end);
  });

  // Mark missing placeholders with red highlight (wrap in HTML comment for visual feedback)
  missingPlaceholders.forEach(placeholder => {
    substitutedPrompt = substitutedPrompt.replace(
      new RegExp(placeholder, 'g'),
      `[MISSING: ${placeholder}]`
    );
  });

  return {
    substitutedPrompt,
    validPlaceholders: Array.from(validPlaceholders),
    missingPlaceholders: Array.from(missingPlaceholders)
  };
}

export function estimateTokenCount(text: string): number {
  // Rough approximation: 1 token â‰ˆ 4 characters
  // More accurate methods would use tokenizer library (e.g., js-tiktoken)
  return Math.ceil(text.length / 4);
}
```

### Frontend Component Specifications

**File: frontend/src/components/config/PreviewModal.tsx** (New)

Preview modal with tabbed interface:

```typescript
'use client';

import { Modal, Button, Tab, Tabs, Alert, Badge, Form } from 'react-bootstrap';
import { usePreview } from '@/contexts/PreviewContext';
import { usePrompt } from '@/contexts/PromptContext';
import { useState } from 'react';

type PromptType = 'paid' | 'unpaid' | 'crawler';

export default function PreviewModal() {
  const {
    isModalOpen,
    closeModal,
    previewContent,
    previewMetadata,
    activePreviewTab,
    setActivePreviewTab,
    isGenerating,
    error,
  } = usePreview();

  const { checkedTypes } = usePrompt();
  const [copiedTab, setCopiedTab] = useState<PromptType | null>(null);

  const TAB_CONFIG: Record<PromptType, { icon: string; label: string; color: string }> = {
    paid: { icon: 'ðŸ’°', label: 'Paid', color: '#0d6efd' },
    unpaid: { icon: 'ðŸ†“', label: 'Unpaid', color: '#198754' },
    crawler: { icon: 'ðŸ•·ï¸', label: 'Crawler', color: '#fd7e14' }
  };

  const handleCopyToClipboard = async () => {
    const content = previewContent[activePreviewTab].substitutedPrompt;
    try {
      await navigator.clipboard.writeText(content);
      setCopiedTab(activePreviewTab);
      setTimeout(() => setCopiedTab(null), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  const visibleTabs = (['paid', 'unpaid', 'crawler'] as PromptType[]).filter(type =>
    checkedTypes.has(type)
  );

  return (
    <Modal show={isModalOpen} onHide={closeModal} size="lg" scrollable>
      <Modal.Header closeButton>
        <div>
          <Modal.Title>Preview Final Prompt</Modal.Title>
          {previewMetadata && (
            <small className="text-muted d-block mt-1">
              {previewMetadata.triggerName} | Stock: {previewMetadata.stockId} |{' '}
              {previewMetadata.timestamp.toLocaleTimeString()}
            </small>
          )}
        </div>
      </Modal.Header>

      <Modal.Body>
        {error && <Alert variant="danger">{error}</Alert>}

        {isGenerating && (
          <Alert variant="info">
            <i className="bi bi-hourglass-split me-2"></i>
            Generating preview...
          </Alert>
        )}

        {!isGenerating && (
          <>
            {/* Tab Navigation */}
            <Tabs
              activeKey={activePreviewTab}
              onSelect={(tab) => setActivePreviewTab(tab as PromptType)}
              className="mb-3"
            >
              {visibleTabs.map(type => {
                const config = TAB_CONFIG[type];
                const content = previewContent[type];
                const hasMissing = content.missingPlaceholders.length > 0;

                return (
                  <Tab
                    key={type}
                    eventKey={type}
                    title={
                      <>
                        <span className="me-2">{config.icon}</span>
                        {config.label}
                        {hasMissing && (
                          <Badge bg="warning" text="dark" className="ms-2">
                            {content.missingPlaceholders.length} missing
                          </Badge>
                        )}
                      </>
                    }
                  >
                    {/* Preview Content */}
                    <div className="bg-light p-3 rounded mb-3 border" style={{ minHeight: '300px' }}>
                      <Form.Control
                        as="textarea"
                        value={content.substitutedPrompt}
                        readOnly
                        rows={10}
                        style={{ fontFamily: 'monospace', fontSize: '0.9rem' }}
                      />
                    </div>

                    {/* Metadata */}
                    <div className="bg-light p-3 rounded border-top">
                      <div className="row">
                        <div className="col-md-4">
                          <small className="text-muted">
                            <i className="bi bi-lightning me-1"></i>
                            <strong>{content.estimatedTokens.toLocaleString()}</strong> tokens (est.)
                          </small>
                        </div>
                        <div className="col-md-4">
                          <small className="text-muted">
                            <i className="bi bi-fonts me-1"></i>
                            <strong>{content.characterCount.toLocaleString()}</strong> characters
                          </small>
                        </div>
                        <div className="col-md-4 text-end">
                          <Badge bg="secondary">
                            {config.icon} {config.label}
                          </Badge>
                        </div>
                      </div>
                    </div>

                    {/* Warnings */}
                    {content.missingPlaceholders.length > 0 && (
                      <Alert variant="warning" className="mt-3">
                        <strong>Missing Data:</strong>
                        <ul className="mb-0 mt-2">
                          {content.missingPlaceholders.map((placeholder, idx) => (
                            <li key={idx}>
                              <code>{placeholder}</code> - Not found in data
                            </li>
                          ))}
                        </ul>
                      </Alert>
                    )}
                  </Tab>
                );
              })}
            </Tabs>
          </>
        )}
      </Modal.Body>

      <Modal.Footer>
        <Button variant="secondary" onClick={closeModal}>
          Close
        </Button>
        <Button
          variant="outline-primary"
          onClick={handleCopyToClipboard}
          disabled={isGenerating}
        >
          <i className={`bi ${copiedTab === activePreviewTab ? 'bi-check' : 'bi-clipboard'} me-2`}></i>
          {copiedTab === activePreviewTab ? 'Copied!' : 'Copy to Clipboard'}
        </Button>
      </Modal.Footer>
    </Modal>
  );
}
```

### Implementation Notes

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Important Design Decisions**:

1. **Automatic Preview Update**: Preview regenerates whenever data, section order, or active tab changes. No manual refresh button needed.

2. **Missing Data Handling**: Placeholders with missing data wrapped in `[MISSING: placeholder]` markers. Shown in red in warning alert.

3. **Token Count Estimation**: Uses rough approximation (4 chars â‰ˆ 1 token). Can be improved later with js-tiktoken library.

4. **Multi-Type Preview**: Modal shows tabs for all checked prompt types. Can switch between types without closing modal.

5. **Metadata Display**: Shows stock ID, trigger name, timestamp, token count, character count for context.

6. **Copy to Clipboard**: Allows quick copying of substituted prompt for external testing or documentation.

7. **Sectio Order Respect**: Data appears in final prompt according to section_order from DataContext.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 3.4**:

**Unit Tests** (frontend/__tests__/lib/):

```typescript
// dataSubstitution.test.ts
import { substitutePlaceholders, estimateTokenCount } from '@/lib/dataSubstitution';

describe('Data Substitution Engine', () => {
  const mockStructuredData = {
    '1': {
      section_name: 'earnings',
      section_id: '1',
      data: { summary: 'Strong earnings', growth: '15%' },
      metadata: { parsed_at: '2025-01-01', data_available: true }
    },
    '2': {
      section_name: 'price',
      section_id: '2',
      data: { current: '$150.25', change: '+2.5%' },
      metadata: { parsed_at: '2025-01-01', data_available: true }
    }
  };

  describe('substitutePlaceholders', () => {
    test('substitutes section references', () => {
      const prompt = 'Latest {{earnings}} report: strong';
      const result = substitutePlaceholders(prompt, mockStructuredData, ['1', '2']);

      expect(result.substitutedPrompt).toContain('Strong earnings');
      expect(result.validPlaceholders).toContain('{{earnings}}');
    });

    test('substitutes field references', () => {
      const prompt = 'Stock price is {data.current}';
      const result = substitutePlaceholders(prompt, mockStructuredData, ['2']);

      expect(result.substitutedPrompt).toContain('$150.25');
      expect(result.validPlaceholders).toContain('{data.current}');
    });

    test('detects missing placeholders', () => {
      const prompt = 'Missing {{nonexistent}} reference';
      const result = substitutePlaceholders(prompt, mockStructuredData, ['1']);

      expect(result.missingPlaceholders).toContain('{{nonexistent}}');
      expect(result.substitutedPrompt).toContain('[MISSING');
    });

    test('respects section order', () => {
      const prompt = '{{price}} then {{earnings}}';
      const result = substitutePlaceholders(prompt, mockStructuredData, ['2', '1']);

      // Data should be substituted correctly
      expect(result.validPlaceholders.length).toBe(2);
    });
  });

  describe('estimateTokenCount', () => {
    test('estimates tokens roughly', () => {
      const text = 'a'.repeat(100);
      const tokens = estimateTokenCount(text);

      expect(tokens).toBe(25); // 100 / 4
    });

    test('rounds up', () => {
      const text = 'a'.repeat(101);
      const tokens = estimateTokenCount(text);

      expect(tokens).toBe(26); // Ceil(101 / 4)
    });
  });
});
```

**Component Tests** (frontend/__tests__/components/config/):

```typescript
// PreviewModal.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import PreviewModal from '@/components/config/PreviewModal';
import { PreviewProvider } from '@/contexts/PreviewContext';
import { PromptProvider } from '@/contexts/PromptContext';
import { DataProvider } from '@/contexts/DataContext';
import { ValidationProvider } from '@/contexts/ValidationContext';

describe('PreviewModal Component', () => {
  const renderWithContext = (component: React.ReactElement) => {
    return render(
      <DataProvider>
        <PromptProvider>
          <ValidationProvider>
            <PreviewProvider>
              {component}
            </PreviewProvider>
          </ValidationProvider>
        </PromptProvider>
      </DataProvider>
    );
  };

  test('displays preview modal when opened', () => {
    renderWithContext(<PreviewModal />);
    // Would need to trigger openModal from context
    // expect(screen.getByText('Preview Final Prompt')).toBeInTheDocument();
  });

  test('copies to clipboard', async () => {
    // Mock clipboard API
    Object.assign(navigator, {
      clipboard: {
        writeText: jest.fn(() => Promise.resolve())
      }
    });

    renderWithContext(<PreviewModal />);
    // Find and click copy button
    // expect(navigator.clipboard.writeText).toHaveBeenCalled();
  });

  test('displays metadata correctly', () => {
    renderWithContext(<PreviewModal />);
    // Verify metadata display (stock ID, trigger name, timestamp)
  });

  test('shows missing placeholders warning', () => {
    renderWithContext(<PreviewModal />);
    // Trigger with missing placeholders
    // expect(screen.getByText(/Missing Data/)).toBeInTheDocument();
  });
});
```

**Manual Verification Checklist**:
1. Preview button in PromptEditor opens modal
2. Modal displays substituted prompt for active prompt type
3. Missing data shown with red markers and warning alert
4. Token count estimate displayed and accurate
5. Character count displayed correctly
6. Metadata (stock ID, trigger name, timestamp) shown
7. Tabs display for all checked prompt types
8. Tab switching shows correct preview for each type
9. Copy to Clipboard button works
10. Preview updates when data/section order/tab changes
11. No console errors in browser
12. Modal scrollable for long prompts

**Coverage Target**: 75%+ for data substitution logic

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 3 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context, dev notes, and testing standards | BMAD Agent |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
