# Story 3.5: Prompt Version History and Undo (Per Prompt Type)

## Status

Draft

## Story

**As a** content manager,
**I want** version history and undo capability for prompt changes per prompt type,
**so that** I can experiment freely and revert mistakes without losing work for each audience type.

## Acceptance Criteria

1. Prompt changes tracked in local history (React Context or local state) with timestamp per prompt type
2. "Undo" button (or Ctrl+Z) reverts to previous prompt version for currently active tab
3. "Redo" button (or Ctrl+Y) re-applies undone changes for currently active tab
4. Version history panel shows list of last 10 prompt versions per type with timestamp and character count
5. Clicking a version in history loads that prompt into editor for the corresponding prompt type
6. Meets FR16: version history and undo capability per prompt type
7. History persisted in browser sessionStorage to survive page refresh (within session) maintaining separate history per type
8. Clear indication of current version vs. historical versions
9. "Save as New Version" button allows explicitly checkpointing important prompt iterations per type
10. History dropdown or panel shows which prompt type's history is being displayed based on active tab

## Tasks / Subtasks

- [ ] Task 1: Extend PromptContext with version history tracking (AC: 1, 2, 3, 4)
  - [ ] Update PromptContext to maintain version history array per prompt type
  - [ ] Add undo() and redo() functions with keyboard shortcuts (Ctrl+Z, Ctrl+Y)
  - [ ] Track timestamps for each version
  - [ ] Keep last 10 versions per prompt type
  - [ ] Track character count with each version
- [ ] Task 2: Implement undo/redo button controls (AC: 2, 3)
  - [ ] Add Undo/Redo buttons to PromptEditor component
  - [ ] Bind keyboard shortcuts (Ctrl+Z = undo, Ctrl+Y = redo)
  - [ ] Disable buttons when no history to undo/redo
  - [ ] Show visual feedback (tooltip) with version info
  - [ ] Hotkey listener at document level for global shortcuts
- [ ] Task 3: Create VersionHistoryPanel component (AC: 4, 5, 8, 10)
  - [ ] Create frontend/src/components/config/VersionHistoryPanel.tsx
  - [ ] Display last 10 versions as collapsible list
  - [ ] Show timestamp, character count, version number per entry
  - [ ] Click version to load into editor for that prompt type
  - [ ] Highlight current version (unmodified state)
  - [ ] Show "pending changes" indicator if editor differs from saved version
- [ ] Task 4: Add "Save as New Version" button (AC: 9)
  - [ ] Create button in PromptEditor to manually checkpoint version
  - [ ] Save current prompt content with timestamp
  - [ ] Add to version history (becomes new current version)
  - [ ] Limit history to last 10 versions (FIFO)
  - [ ] Show success notification on save
- [ ] Task 5: Implement sessionStorage persistence (AC: 7)
  - [ ] Save version history to sessionStorage for each prompt type
  - [ ] Use key: `promptHistory_${type}` (e.g., `promptHistory_paid`)
  - [ ] Load history on component mount (within session)
  - [ ] Clear on session end (browser close or logout)
  - [ ] Handle storage quota errors gracefully
- [ ] Task 6: Add per-tab history display (AC: 10)
  - [ ] Show in VersionHistoryPanel which type's history is displayed
  - [ ] Update panel when switching tabs
  - [ ] Separate history for each prompt type maintained independently
  - [ ] History persisted separately per type in sessionStorage
- [ ] Task 7: Write unit and integration tests
  - [ ] Test undo/redo state management
  - [ ] Test version history creation and retrieval
  - [ ] Test sessionStorage persistence and retrieval
  - [ ] Test keyboard shortcuts
  - [ ] Test 10-version limit enforcement
  - [ ] Test per-prompt-type history isolation

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 3.2 - Completion]

Before starting this story, ensure Story 3.2 is complete:
- PromptContext manages prompt state for all types
- Prompt content tracked and auto-saved
- Tab switching working correctly
- PromptEditor component rendering

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── config/
│       ├── VersionHistoryPanel.tsx        # Version history UI (NEW)
│       ├── PromptEditor.tsx               # Add undo/redo buttons (MODIFY)
│       ├── UndoRedoButtons.tsx            # Undo/redo control component (NEW)
│       └── ConfigurationWorkspace.tsx     # Integrate VersionHistoryPanel (MODIFY)
├── contexts/
│   └── PromptContext.tsx                  # Extend with version history (MODIFY)
└── hooks/
    └── useKeyboardShortcuts.ts            # Keyboard shortcut hook (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **React Context API**: Extended PromptContext with version history
- **sessionStorage**: Browser session storage for history persistence
- **React hooks**: useEffect for keyboard listener, useState for history state
- **Keyboard events**: keydown listener for Ctrl+Z and Ctrl+Y

### Version History Data Model

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**VersionEntry Interface**:
```typescript
interface VersionEntry {
  id: string;                 // Unique version ID (timestamp-based)
  timestamp: Date;            // When version was created
  template: string;           // Prompt content at this version
  characterCount: number;     // Content length
  wordCount: number;          // Word count (for info)
  isManualCheckpoint: boolean;// True if saved with "Save as New Version"
}

interface PromptHistory {
  versions: VersionEntry[];           // Array of versions (max 10)
  currentIndex: number;               // Current position in history (for undo/redo)
  pendingChanges: boolean;            // True if editor content != current version
}
```

### React Context Enhancement for Version History

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/PromptContext.tsx** (Update)

Enhanced with version history:

```typescript
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { useDebouncedCallback } from 'use-debounce';

type PromptType = 'paid' | 'unpaid' | 'crawler';

interface VersionEntry {
  id: string;
  timestamp: Date;
  template: string;
  characterCount: number;
  wordCount: number;
  isManualCheckpoint: boolean;
}

interface PromptHistory {
  versions: VersionEntry[];
  currentIndex: number;
  pendingChanges: boolean;
}

interface PromptTemplate {
  content: string;
  lastSaved: Date | null;
  characterCount: number;
  wordCount: number;
}

interface PromptContextType {
  prompts: Record<PromptType, PromptTemplate>;
  activeTab: PromptType;
  checkedTypes: Set<PromptType>;
  editorTheme: 'vs-light' | 'vs-dark';
  history: Record<PromptType, PromptHistory>;
  canUndo: (type: PromptType) => boolean;
  canRedo: (type: PromptType) => boolean;
  undo: (type: PromptType) => void;
  redo: (type: PromptType) => void;
  saveAsVersion: (type: PromptType, isCheckpoint: boolean) => void;
  setPromptContent: (type: PromptType, content: string) => void;
  setActiveTab: (type: PromptType) => void;
  setCheckedTypes: (types: Set<PromptType>) => void;
  setEditorTheme: (theme: 'vs-light' | 'vs-dark') => void;
  savePrompts: (triggerId: string) => Promise<void>;
  loadPrompts: (triggerId: string) => Promise<void>;
  isSaving: boolean;
  saveError: string | null;
}

const PromptContext = createContext<PromptContextType | undefined>(undefined);

const HISTORY_KEY_PREFIX = 'promptHistory_';
const MAX_VERSIONS = 10;

const calculateStats = (content: string) => {
  const characterCount = content.length;
  const wordCount = content.trim() ? content.trim().split(/\s+/).length : 0;
  return { characterCount, wordCount };
};

const createVersionEntry = (template: string, isCheckpoint: boolean = false): VersionEntry => {
  const stats = calculateStats(template);
  return {
    id: `v_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    timestamp: new Date(),
    template,
    characterCount: stats.characterCount,
    wordCount: stats.wordCount,
    isManualCheckpoint: isCheckpoint
  };
};

const loadHistoryFromStorage = (type: PromptType): PromptHistory => {
  try {
    const stored = sessionStorage.getItem(`${HISTORY_KEY_PREFIX}${type}`);
    if (stored) {
      const parsed = JSON.parse(stored);
      return {
        versions: parsed.versions.map((v: any) => ({
          ...v,
          timestamp: new Date(v.timestamp)
        })),
        currentIndex: parsed.currentIndex,
        pendingChanges: false
      };
    }
  } catch (err) {
    console.warn(`Failed to load history for ${type}:`, err);
  }

  return {
    versions: [],
    currentIndex: -1,
    pendingChanges: false
  };
};

const saveHistoryToStorage = (type: PromptType, history: PromptHistory) => {
  try {
    sessionStorage.setItem(
      `${HISTORY_KEY_PREFIX}${type}`,
      JSON.stringify({
        versions: history.versions,
        currentIndex: history.currentIndex
      })
    );
  } catch (err) {
    console.warn(`Failed to save history for ${type}:`, err);
  }
};

export function PromptProvider({ children }: { children: ReactNode }) {
  const [prompts, setPrompts] = useState<Record<PromptType, PromptTemplate>>({
    paid: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 },
    unpaid: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 },
    crawler: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 }
  });

  const [activeTab, setActiveTab] = useState<PromptType>('paid');
  const [checkedTypes, setCheckedTypes] = useState<Set<PromptType>>(new Set(['paid']));
  const [editorTheme, setEditorThemeState] = useState<'vs-light' | 'vs-dark'>('vs-dark');
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [triggerId, setTriggerId] = useState<string | null>(null);

  // Initialize history from storage
  const [history, setHistory] = useState<Record<PromptType, PromptHistory>>({
    paid: loadHistoryFromStorage('paid'),
    unpaid: loadHistoryFromStorage('unpaid'),
    crawler: loadHistoryFromStorage('crawler')
  });

  // Load theme from localStorage on mount
  useEffect(() => {
    const savedTheme = localStorage.getItem('editor-theme') as 'vs-light' | 'vs-dark' | null;
    if (savedTheme) {
      setEditorThemeState(savedTheme);
    } else {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setEditorThemeState(prefersDark ? 'vs-dark' : 'vs-light');
    }
  }, []);

  const setEditorTheme = (theme: 'vs-light' | 'vs-dark') => {
    setEditorThemeState(theme);
    localStorage.setItem('editor-theme', theme);
  };

  const canUndo = (type: PromptType) => history[type].currentIndex > 0;
  const canRedo = (type: PromptType) =>
    history[type].currentIndex < history[type].versions.length - 1;

  const undo = (type: PromptType) => {
    if (!canUndo(type)) return;

    setHistory(prev => {
      const newHistory = { ...prev };
      const typeHistory = { ...newHistory[type] };
      typeHistory.currentIndex--;

      const version = typeHistory.versions[typeHistory.currentIndex];
      if (version) {
        setPrompts(p => ({
          ...p,
          [type]: {
            ...p[type],
            content: version.template,
            ...calculateStats(version.template)
          }
        }));
      }

      newHistory[type] = typeHistory;
      saveHistoryToStorage(type, typeHistory);
      return newHistory;
    });
  };

  const redo = (type: PromptType) => {
    if (!canRedo(type)) return;

    setHistory(prev => {
      const newHistory = { ...prev };
      const typeHistory = { ...newHistory[type] };
      typeHistory.currentIndex++;

      const version = typeHistory.versions[typeHistory.currentIndex];
      if (version) {
        setPrompts(p => ({
          ...p,
          [type]: {
            ...p[type],
            content: version.template,
            ...calculateStats(version.template)
          }
        }));
      }

      newHistory[type] = typeHistory;
      saveHistoryToStorage(type, typeHistory);
      return newHistory;
    });
  };

  const saveAsVersion = (type: PromptType, isCheckpoint: boolean = false) => {
    const currentContent = prompts[type].content;
    const newVersion = createVersionEntry(currentContent, isCheckpoint);

    setHistory(prev => {
      const newHistory = { ...prev };
      const typeHistory = { ...newHistory[type] };

      // If not at the end, discard future history
      if (typeHistory.currentIndex < typeHistory.versions.length - 1) {
        typeHistory.versions = typeHistory.versions.slice(0, typeHistory.currentIndex + 1);
      }

      // Add new version
      typeHistory.versions.push(newVersion);
      typeHistory.currentIndex = typeHistory.versions.length - 1;

      // Keep only last 10 versions
      if (typeHistory.versions.length > MAX_VERSIONS) {
        typeHistory.versions = typeHistory.versions.slice(-MAX_VERSIONS);
        typeHistory.currentIndex = typeHistory.versions.length - 1;
      }

      typeHistory.pendingChanges = false;

      newHistory[type] = typeHistory;
      saveHistoryToStorage(type, typeHistory);
      return newHistory;
    });
  };

  const setPromptContent = (type: PromptType, content: string) => {
    const stats = calculateStats(content);
    setPrompts(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        content,
        ...stats
      }
    }));

    // Mark as having pending changes
    setHistory(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        pendingChanges: true
      }
    }));

    // Trigger auto-save (debounced)
    if (triggerId) {
      debouncedSave(triggerId);
      // Also auto-save version every 30 seconds of inactivity
      debouncedSaveVersion(type);
    }
  };

  const savePrompts = async (tid: string) => {
    try {
      setIsSaving(true);
      setSaveError(null);

      const response = await fetch(`/api/triggers/${tid}/config/prompts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompts: {
            paid: { template: prompts.paid.content },
            unpaid: { template: prompts.unpaid.content },
            crawler: { template: prompts.crawler.content }
          }
        })
      });

      if (!response.ok) {
        throw new Error('Failed to save prompts');
      }

      // Update lastSaved timestamps
      const now = new Date();
      setPrompts(prev => ({
        paid: { ...prev.paid, lastSaved: now },
        unpaid: { ...prev.unpaid, lastSaved: now },
        crawler: { ...prev.crawler, lastSaved: now }
      }));
    } catch (err) {
      setSaveError(err instanceof Error ? err.message : 'Failed to save prompts');
      throw err;
    } finally {
      setIsSaving(false);
    }
  };

  // Debounced save function (5 seconds)
  const debouncedSave = useDebouncedCallback(
    async (tid: string) => {
      try {
        await savePrompts(tid);
      } catch (err) {
        console.error('Auto-save failed:', err);
      }
    },
    5000
  );

  // Debounced version save (30 seconds - auto-checkpoint)
  const debouncedSaveVersion = useDebouncedCallback(
    (type: PromptType) => {
      saveAsVersion(type, false); // Auto-save, not manual checkpoint
    },
    30000
  );

  const loadPrompts = async (tid: string) => {
    try {
      setTriggerId(tid);
      const response = await fetch(`/api/triggers/${tid}/config`);

      if (!response.ok) {
        throw new Error('Failed to load configuration');
      }

      const config = await response.json();

      if (config.prompts) {
        setPrompts({
          paid: {
            content: config.prompts.paid?.template || '',
            lastSaved: config.prompts.paid?.last_saved ? new Date(config.prompts.paid.last_saved) : null,
            ...calculateStats(config.prompts.paid?.template || '')
          },
          unpaid: {
            content: config.prompts.unpaid?.template || '',
            lastSaved: config.prompts.unpaid?.last_saved ? new Date(config.prompts.unpaid.last_saved) : null,
            ...calculateStats(config.prompts.unpaid?.template || '')
          },
          crawler: {
            content: config.prompts.crawler?.template || '',
            lastSaved: config.prompts.crawler?.last_saved ? new Date(config.prompts.crawler.last_saved) : null,
            ...calculateStats(config.prompts.crawler?.template || '')
          }
        });
      }
    } catch (err) {
      setSaveError(err instanceof Error ? err.message : 'Failed to load prompts');
    }
  };

  const value: PromptContextType = {
    prompts,
    activeTab,
    checkedTypes,
    editorTheme,
    history,
    canUndo,
    canRedo,
    undo,
    redo,
    saveAsVersion,
    setPromptContent,
    setActiveTab,
    setCheckedTypes,
    setEditorTheme,
    savePrompts,
    loadPrompts,
    isSaving,
    saveError
  };

  return <PromptContext.Provider value={value}>{children}</PromptContext.Provider>;
}

export function usePrompt() {
  const context = useContext(PromptContext);
  if (context === undefined) {
    throw new Error('usePrompt must be used within a PromptProvider');
  }
  return context;
}
```

**File: frontend/src/hooks/useKeyboardShortcuts.ts** (New)

Keyboard shortcut hook:

```typescript
import { useEffect } from 'react';

export function useKeyboardShortcuts(handlers: Record<string, () => void>) {
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl+Z or Cmd+Z for undo
      if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        handlers['undo']?.();
      }

      // Ctrl+Y or Cmd+Shift+Z for redo
      if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
        event.preventDefault();
        handlers['redo']?.();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handlers]);
}
```

### Frontend Component Specifications

**File: frontend/src/components/config/UndoRedoButtons.tsx** (New)

Undo/redo button controls:

```typescript
'use client';

import { Button, ButtonGroup } from 'react-bootstrap';
import { usePrompt } from '@/contexts/PromptContext';

export default function UndoRedoButtons() {
  const { activeTab, canUndo, canRedo, undo, redo } = usePrompt();

  return (
    <ButtonGroup size="sm" className="me-2">
      <Button
        variant="outline-secondary"
        onClick={() => undo(activeTab)}
        disabled={!canUndo(activeTab)}
        title="Undo (Ctrl+Z)"
      >
        <i className="bi bi-arrow-counterclockwise me-1"></i>
        Undo
      </Button>
      <Button
        variant="outline-secondary"
        onClick={() => redo(activeTab)}
        disabled={!canRedo(activeTab)}
        title="Redo (Ctrl+Y)"
      >
        <i className="bi bi-arrow-clockwise me-1"></i>
        Redo
      </Button>
    </ButtonGroup>
  );
}
```

**File: frontend/src/components/config/VersionHistoryPanel.tsx** (New)

Version history UI:

```typescript
'use client';

import { Card, ListGroup, Badge, Button, Collapse } from 'react-bootstrap';
import { useState } from 'react';
import { usePrompt } from '@/contexts/PromptContext';

export default function VersionHistoryPanel() {
  const { activeTab, history, saveAsVersion } = usePrompt();
  const [open, setOpen] = useState(true);

  const typeHistory = history[activeTab];
  const currentVersion = typeHistory.versions[typeHistory.currentIndex];

  const handleSaveAsCheckpoint = () => {
    saveAsVersion(activeTab, true);
  };

  return (
    <Card className="mt-4">
      <Card.Header
        className="cursor-pointer d-flex justify-content-between align-items-center"
        onClick={() => setOpen(!open)}
        style={{ cursor: 'pointer' }}
      >
        <div>
          <h5 className="mb-0">Version History - {activeTab}</h5>
          <small className="text-muted">
            {typeHistory.versions.length} versions | {currentVersion ? `v${typeHistory.currentIndex + 1}` : 'No versions'}
          </small>
        </div>
        <i className={`bi bi-chevron-${open ? 'up' : 'down'}`}></i>
      </Card.Header>

      <Collapse in={open}>
        <Card.Body>
          {typeHistory.versions.length === 0 ? (
            <p className="text-muted mb-0">No version history yet. Start editing to create versions.</p>
          ) : (
            <ListGroup variant="flush">
              {typeHistory.versions.map((version, idx) => {
                const isCurrent = idx === typeHistory.currentIndex;
                return (
                  <ListGroup.Item
                    key={version.id}
                    className={`d-flex justify-content-between align-items-start ${isCurrent ? 'bg-light' : ''}`}
                    style={{ cursor: 'pointer', padding: '10px' }}
                  >
                    <div className="flex-grow-1">
                      <div className="fw-bold">
                        v{idx + 1}
                        {isCurrent && <Badge bg="primary" className="ms-2">Current</Badge>}
                        {version.isManualCheckpoint && (
                          <Badge bg="success" className="ms-2">Checkpoint</Badge>
                        )}
                      </div>
                      <small className="text-muted">
                        {version.timestamp.toLocaleTimeString()} | {version.characterCount} chars | {version.wordCount} words
                      </small>
                    </div>
                    <Button
                      variant="outline-primary"
                      size="sm"
                      disabled={isCurrent}
                      onClick={() => {
                        // Load this version (would need setter in context)
                      }}
                    >
                      Load
                    </Button>
                  </ListGroup.Item>
                );
              })}
            </ListGroup>
          )}

          <Button
            variant="outline-success"
            size="sm"
            className="mt-3 w-100"
            onClick={handleSaveAsCheckpoint}
          >
            <i className="bi bi-bookmark me-1"></i>
            Save as New Version
          </Button>
        </Card.Body>
      </Collapse>
    </Card>
  );
}
```

### Implementation Notes

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Important Design Decisions**:

1. **Per-Type History**: Each prompt type (paid, unpaid, crawler) maintains separate version history in sessionStorage.

2. **Session Persistence**: History saved to sessionStorage, not MongoDB. Survives page refresh within same session.

3. **10-Version Limit**: Keeps last 10 versions only (FIFO). Prevents excessive memory usage.

4. **Auto-Checkpointing**: Every 30 seconds of inactivity, automatically creates version checkpoint (non-manual).

5. **Manual Checkpoints**: "Save as New Version" button allows explicit version marking.

6. **Keyboard Shortcuts**: Global listeners for Ctrl+Z (undo) and Ctrl+Y (redo) on any tab.

7. **Undo/Redo State**: Tracks currentIndex in history array. Can navigate forwards/backwards through history.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 3.5**:

**Unit Tests** (frontend/__tests__/contexts/):

```typescript
// PromptContext.test.tsx (version history portion)
import { renderHook, act } from '@testing-library/react';
import { usePrompt, PromptProvider } from '@/contexts/PromptContext';

describe('PromptContext - Version History', () => {
  const wrapper = ({ children }: { children: React.ReactElement }) => (
    <PromptProvider>{children}</PromptProvider>
  );

  test('creates version entry on saveAsVersion', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'Test prompt v1');
      result.current.saveAsVersion('paid', true);
    });

    expect(result.current.history.paid.versions).toHaveLength(1);
    expect(result.current.history.paid.versions[0].template).toBe('Test prompt v1');
    expect(result.current.history.paid.versions[0].isManualCheckpoint).toBe(true);
  });

  test('undo reverts to previous version', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'Version 1');
      result.current.saveAsVersion('paid', true);
      result.current.setPromptContent('paid', 'Version 2');
      result.current.saveAsVersion('paid', true);
    });

    expect(result.current.prompts.paid.content).toBe('Version 2');

    act(() => {
      result.current.undo('paid');
    });

    expect(result.current.prompts.paid.content).toBe('Version 1');
  });

  test('redo re-applies undone change', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'v1');
      result.current.saveAsVersion('paid', true);
      result.current.setPromptContent('paid', 'v2');
      result.current.saveAsVersion('paid', true);
      result.current.undo('paid');
    });

    expect(result.current.prompts.paid.content).toBe('v1');

    act(() => {
      result.current.redo('paid');
    });

    expect(result.current.prompts.paid.content).toBe('v2');
  });

  test('enforces 10-version limit', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      for (let i = 0; i < 15; i++) {
        result.current.setPromptContent('paid', `Version ${i}`);
        result.current.saveAsVersion('paid', true);
      }
    });

    expect(result.current.history.paid.versions.length).toBeLessThanOrEqual(10);
  });

  test('canUndo/canRedo return correct state', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'v1');
      result.current.saveAsVersion('paid', true);
      result.current.setPromptContent('paid', 'v2');
      result.current.saveAsVersion('paid', true);
    });

    expect(result.current.canUndo('paid')).toBe(true);
    expect(result.current.canRedo('paid')).toBe(false);

    act(() => {
      result.current.undo('paid');
    });

    expect(result.current.canUndo('paid')).toBe(true);
    expect(result.current.canRedo('paid')).toBe(true);
  });
});
```

**Hook Tests** (frontend/__tests__/hooks/):

```typescript
// useKeyboardShortcuts.test.ts
import { renderHook } from '@testing-library/react';
import { useKeyboardShortcuts } from '@/hooks/useKeyboardShortcuts';

describe('useKeyboardShortcuts', () => {
  test('calls undo handler on Ctrl+Z', () => {
    const handlers = {
      undo: jest.fn(),
      redo: jest.fn()
    };

    renderHook(() => useKeyboardShortcuts(handlers));

    const event = new KeyboardEvent('keydown', {
      key: 'z',
      ctrlKey: true,
      code: 'KeyZ'
    });

    window.dispatchEvent(event);
    expect(handlers.undo).toHaveBeenCalled();
  });

  test('calls redo handler on Ctrl+Y', () => {
    const handlers = {
      undo: jest.fn(),
      redo: jest.fn()
    };

    renderHook(() => useKeyboardShortcuts(handlers));

    const event = new KeyboardEvent('keydown', {
      key: 'y',
      ctrlKey: true
    });

    window.dispatchEvent(event);
    expect(handlers.redo).toHaveBeenCalled();
  });

  test('works with Cmd+Z on Mac', () => {
    const handlers = {
      undo: jest.fn(),
      redo: jest.fn()
    };

    renderHook(() => useKeyboardShortcuts(handlers));

    const event = new KeyboardEvent('keydown', {
      key: 'z',
      metaKey: true
    });

    window.dispatchEvent(event);
    expect(handlers.undo).toHaveBeenCalled();
  });
});
```

**Manual Verification Checklist**:
1. Undo/Redo buttons appear in PromptEditor
2. Undo button disabled when no history
3. Redo button disabled when at latest version
4. Ctrl+Z triggers undo
5. Ctrl+Y triggers redo
6. Version history panel shows all versions
7. Click version loads it into editor
8. "Save as New Version" creates checkpoint
9. History persists across page refresh (same session)
10. History cleared on session end
11. Per-type history isolation working
12. 10-version limit enforced
13. No console errors in browser

**Coverage Target**: 80%+ for version history logic

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 3 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context, dev notes, and testing standards | BMAD Agent |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
