# Story 3.5: Prompt Undo/Redo (Per Prompt Type)

## Status

Implemented (Simplified)

## Story

**As a** content manager,
**I want** undo/redo capability for prompt changes per prompt type,
**so that** I can experiment freely and revert mistakes without losing work for each audience type.

## Implementation Notes

**Design Decision**: This story was simplified during implementation to avoid redundancy with Story 3.4b (Backend Version History). The final implementation includes:
- ✅ Undo/Redo buttons with keyboard shortcuts (Ctrl+Z, Ctrl+Y)
- ✅ Internal version tracking for undo/redo operations (hidden from UI)
- ✅ sessionStorage persistence for undo/redo history
- ❌ Visible version history panel (removed - use backend versions in PreviewModal instead)
- ❌ Auto-save version timer (removed to avoid version clutter)
- ❌ "Save as New Version" button (removed - use backend save for versions)

This approach provides:
- **Undo/Redo**: For immediate, short-term changes during editing
- **Backend Versions**: For long-term version history via PreviewModal (Story 3.4b)

Users get a clean, intuitive UX with no duplicate version displays.

## Acceptance Criteria (Simplified)

1. ✅ Prompt changes tracked in local history (sessionStorage) with timestamp per prompt type
2. ✅ "Undo" button (or Ctrl+Z) reverts to previous prompt version for currently active tab
3. ✅ "Redo" button (or Ctrl+Y) re-applies undone changes for currently active tab
4. ✅ Meets FR16: undo capability per prompt type
5. ✅ History persisted in browser sessionStorage to survive page refresh (within session) maintaining separate history per type
6. ✅ Keyboard shortcuts work globally (Ctrl+Z, Ctrl+Y, Cmd+Z, Cmd+Shift+Z)
7. ✅ Undo/Redo buttons disabled when no history available
8. ✅ Maintains up to 10 versions per prompt type in memory (FIFO)

**Removed from original scope** (to avoid redundancy with Story 3.4b):
- ❌ Visible version history panel
- ❌ Auto-save version timer
- ❌ "Save as New Version" button
- ❌ Version history UI display

## Tasks / Subtasks (Simplified)

- [x] Task 1: Create useKeyboardShortcuts hook
  - [x] Create frontend/src/hooks/useKeyboardShortcuts.ts
  - [x] Add keyboard event listeners for Ctrl+Z and Ctrl+Y
  - [x] Support both Ctrl and Cmd (Mac)
  - [x] Cleanup listeners on unmount
- [x] Task 2: Extend PromptContext with undo/redo tracking
  - [x] Update PromptContext to maintain version history array per prompt type
  - [x] Add undo() and redo() functions
  - [x] Track timestamps for each version
  - [x] Keep last 10 versions per prompt type (FIFO)
  - [x] Track character count with each version
  - [x] Auto-create versions on content change
- [x] Task 3: Implement undo/redo button controls
  - [x] Create frontend/src/components/config/UndoRedoButtons.tsx
  - [x] Add Undo/Redo buttons to PromptEditor component
  - [x] Disable buttons when no history to undo/redo
  - [x] Show tooltips with keyboard shortcuts
- [x] Task 4: Implement sessionStorage persistence
  - [x] Save version history to sessionStorage for each prompt type
  - [x] Use key: `promptHistory_${type}` (e.g., `promptHistory_paid`)
  - [x] Load history on component mount (within session)
  - [x] Handle storage errors gracefully
- [x] Task 5: Simplify implementation
  - [x] Remove auto-save version timer
  - [x] Remove VersionHistoryPanel component
  - [x] Remove saveAsVersion and loadVersion from public API
  - [x] Update documentation to reflect simplified design

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 3.2 - Completion]

Before starting this story, ensure Story 3.2 is complete:
- PromptContext manages prompt state for all types
- Prompt content tracked and auto-saved
- Tab switching working correctly
- PromptEditor component rendering

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**Frontend files to create/modify** in `frontend/src/`:
```
frontend/src/
├── components/
│   └── config/
│       ├── VersionHistoryPanel.tsx        # Version history UI (NEW)
│       ├── PromptEditor.tsx               # Add undo/redo buttons (MODIFY)
│       ├── UndoRedoButtons.tsx            # Undo/redo control component (NEW)
│       └── ConfigurationWorkspace.tsx     # Integrate VersionHistoryPanel (MODIFY)
├── contexts/
│   └── PromptContext.tsx                  # Extend with version history (MODIFY)
└── hooks/
    └── useKeyboardShortcuts.ts            # Keyboard shortcut hook (NEW)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Frontend Stack**:
- **React Context API**: Extended PromptContext with version history
- **sessionStorage**: Browser session storage for history persistence
- **React hooks**: useEffect for keyboard listener, useState for history state
- **Keyboard events**: keydown listener for Ctrl+Z and Ctrl+Y

### Version History Data Model

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**VersionEntry Interface**:
```typescript
interface VersionEntry {
  id: string;                 // Unique version ID (timestamp-based)
  timestamp: Date;            // When version was created
  template: string;           // Prompt content at this version
  characterCount: number;     // Content length
  wordCount: number;          // Word count (for info)
  isManualCheckpoint: boolean;// True if saved with "Save as New Version"
}

interface PromptHistory {
  versions: VersionEntry[];           // Array of versions (max 10)
  currentIndex: number;               // Current position in history (for undo/redo)
  pendingChanges: boolean;            // True if editor content != current version
}
```

### React Context Enhancement for Version History

[Source: architecture.md - Source Tree and Module Organization - React Context API]

**File: frontend/src/contexts/PromptContext.tsx** (Update)

Enhanced with version history:

```typescript
'use client';

import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { useDebouncedCallback } from 'use-debounce';

type PromptType = 'paid' | 'unpaid' | 'crawler';

interface VersionEntry {
  id: string;
  timestamp: Date;
  template: string;
  characterCount: number;
  wordCount: number;
  isManualCheckpoint: boolean;
}

interface PromptHistory {
  versions: VersionEntry[];
  currentIndex: number;
  pendingChanges: boolean;
}

interface PromptTemplate {
  content: string;
  lastSaved: Date | null;
  characterCount: number;
  wordCount: number;
}

interface PromptContextType {
  prompts: Record<PromptType, PromptTemplate>;
  activeTab: PromptType;
  checkedTypes: Set<PromptType>;
  editorTheme: 'vs-light' | 'vs-dark';
  history: Record<PromptType, PromptHistory>;
  canUndo: (type: PromptType) => boolean;
  canRedo: (type: PromptType) => boolean;
  undo: (type: PromptType) => void;
  redo: (type: PromptType) => void;
  saveAsVersion: (type: PromptType, isCheckpoint: boolean) => void;
  setPromptContent: (type: PromptType, content: string) => void;
  setActiveTab: (type: PromptType) => void;
  setCheckedTypes: (types: Set<PromptType>) => void;
  setEditorTheme: (theme: 'vs-light' | 'vs-dark') => void;
  savePrompts: (triggerId: string) => Promise<void>;
  loadPrompts: (triggerId: string) => Promise<void>;
  isSaving: boolean;
  saveError: string | null;
}

const PromptContext = createContext<PromptContextType | undefined>(undefined);

const HISTORY_KEY_PREFIX = 'promptHistory_';
const MAX_VERSIONS = 10;

const calculateStats = (content: string) => {
  const characterCount = content.length;
  const wordCount = content.trim() ? content.trim().split(/\s+/).length : 0;
  return { characterCount, wordCount };
};

const createVersionEntry = (template: string, isCheckpoint: boolean = false): VersionEntry => {
  const stats = calculateStats(template);
  return {
    id: `v_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    timestamp: new Date(),
    template,
    characterCount: stats.characterCount,
    wordCount: stats.wordCount,
    isManualCheckpoint: isCheckpoint
  };
};

const loadHistoryFromStorage = (type: PromptType): PromptHistory => {
  try {
    const stored = sessionStorage.getItem(`${HISTORY_KEY_PREFIX}${type}`);
    if (stored) {
      const parsed = JSON.parse(stored);
      return {
        versions: parsed.versions.map((v: any) => ({
          ...v,
          timestamp: new Date(v.timestamp)
        })),
        currentIndex: parsed.currentIndex,
        pendingChanges: false
      };
    }
  } catch (err) {
    console.warn(`Failed to load history for ${type}:`, err);
  }

  return {
    versions: [],
    currentIndex: -1,
    pendingChanges: false
  };
};

const saveHistoryToStorage = (type: PromptType, history: PromptHistory) => {
  try {
    sessionStorage.setItem(
      `${HISTORY_KEY_PREFIX}${type}`,
      JSON.stringify({
        versions: history.versions,
        currentIndex: history.currentIndex
      })
    );
  } catch (err) {
    console.warn(`Failed to save history for ${type}:`, err);
  }
};

export function PromptProvider({ children }: { children: ReactNode }) {
  const [prompts, setPrompts] = useState<Record<PromptType, PromptTemplate>>({
    paid: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 },
    unpaid: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 },
    crawler: { content: '', lastSaved: null, characterCount: 0, wordCount: 0 }
  });

  const [activeTab, setActiveTab] = useState<PromptType>('paid');
  const [checkedTypes, setCheckedTypes] = useState<Set<PromptType>>(new Set(['paid']));
  const [editorTheme, setEditorThemeState] = useState<'vs-light' | 'vs-dark'>('vs-dark');
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const [triggerId, setTriggerId] = useState<string | null>(null);

  // Initialize history from storage
  const [history, setHistory] = useState<Record<PromptType, PromptHistory>>({
    paid: loadHistoryFromStorage('paid'),
    unpaid: loadHistoryFromStorage('unpaid'),
    crawler: loadHistoryFromStorage('crawler')
  });

  // Load theme from localStorage on mount
  useEffect(() => {
    const savedTheme = localStorage.getItem('editor-theme') as 'vs-light' | 'vs-dark' | null;
    if (savedTheme) {
      setEditorThemeState(savedTheme);
    } else {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setEditorThemeState(prefersDark ? 'vs-dark' : 'vs-light');
    }
  }, []);

  const setEditorTheme = (theme: 'vs-light' | 'vs-dark') => {
    setEditorThemeState(theme);
    localStorage.setItem('editor-theme', theme);
  };

  const canUndo = (type: PromptType) => history[type].currentIndex > 0;
  const canRedo = (type: PromptType) =>
    history[type].currentIndex < history[type].versions.length - 1;

  const undo = (type: PromptType) => {
    if (!canUndo(type)) return;

    setHistory(prev => {
      const newHistory = { ...prev };
      const typeHistory = { ...newHistory[type] };
      typeHistory.currentIndex--;

      const version = typeHistory.versions[typeHistory.currentIndex];
      if (version) {
        setPrompts(p => ({
          ...p,
          [type]: {
            ...p[type],
            content: version.template,
            ...calculateStats(version.template)
          }
        }));
      }

      newHistory[type] = typeHistory;
      saveHistoryToStorage(type, typeHistory);
      return newHistory;
    });
  };

  const redo = (type: PromptType) => {
    if (!canRedo(type)) return;

    setHistory(prev => {
      const newHistory = { ...prev };
      const typeHistory = { ...newHistory[type] };
      typeHistory.currentIndex++;

      const version = typeHistory.versions[typeHistory.currentIndex];
      if (version) {
        setPrompts(p => ({
          ...p,
          [type]: {
            ...p[type],
            content: version.template,
            ...calculateStats(version.template)
          }
        }));
      }

      newHistory[type] = typeHistory;
      saveHistoryToStorage(type, typeHistory);
      return newHistory;
    });
  };

  const saveAsVersion = (type: PromptType, isCheckpoint: boolean = false) => {
    const currentContent = prompts[type].content;
    const newVersion = createVersionEntry(currentContent, isCheckpoint);

    setHistory(prev => {
      const newHistory = { ...prev };
      const typeHistory = { ...newHistory[type] };

      // If not at the end, discard future history
      if (typeHistory.currentIndex < typeHistory.versions.length - 1) {
        typeHistory.versions = typeHistory.versions.slice(0, typeHistory.currentIndex + 1);
      }

      // Add new version
      typeHistory.versions.push(newVersion);
      typeHistory.currentIndex = typeHistory.versions.length - 1;

      // Keep only last 10 versions
      if (typeHistory.versions.length > MAX_VERSIONS) {
        typeHistory.versions = typeHistory.versions.slice(-MAX_VERSIONS);
        typeHistory.currentIndex = typeHistory.versions.length - 1;
      }

      typeHistory.pendingChanges = false;

      newHistory[type] = typeHistory;
      saveHistoryToStorage(type, typeHistory);
      return newHistory;
    });
  };

  const setPromptContent = (type: PromptType, content: string) => {
    const stats = calculateStats(content);
    setPrompts(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        content,
        ...stats
      }
    }));

    // Mark as having pending changes
    setHistory(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        pendingChanges: true
      }
    }));

    // Trigger auto-save (debounced)
    if (triggerId) {
      debouncedSave(triggerId);
      // Also auto-save version every 30 seconds of inactivity
      debouncedSaveVersion(type);
    }
  };

  const savePrompts = async (tid: string) => {
    try {
      setIsSaving(true);
      setSaveError(null);

      const response = await fetch(`/api/triggers/${tid}/config/prompts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompts: {
            paid: { template: prompts.paid.content },
            unpaid: { template: prompts.unpaid.content },
            crawler: { template: prompts.crawler.content }
          }
        })
      });

      if (!response.ok) {
        throw new Error('Failed to save prompts');
      }

      // Update lastSaved timestamps
      const now = new Date();
      setPrompts(prev => ({
        paid: { ...prev.paid, lastSaved: now },
        unpaid: { ...prev.unpaid, lastSaved: now },
        crawler: { ...prev.crawler, lastSaved: now }
      }));
    } catch (err) {
      setSaveError(err instanceof Error ? err.message : 'Failed to save prompts');
      throw err;
    } finally {
      setIsSaving(false);
    }
  };

  // Debounced save function (5 seconds)
  const debouncedSave = useDebouncedCallback(
    async (tid: string) => {
      try {
        await savePrompts(tid);
      } catch (err) {
        console.error('Auto-save failed:', err);
      }
    },
    5000
  );

  // Debounced version save (30 seconds - auto-checkpoint)
  const debouncedSaveVersion = useDebouncedCallback(
    (type: PromptType) => {
      saveAsVersion(type, false); // Auto-save, not manual checkpoint
    },
    30000
  );

  const loadPrompts = async (tid: string) => {
    try {
      setTriggerId(tid);
      const response = await fetch(`/api/triggers/${tid}/config`);

      if (!response.ok) {
        throw new Error('Failed to load configuration');
      }

      const config = await response.json();

      if (config.prompts) {
        setPrompts({
          paid: {
            content: config.prompts.paid?.template || '',
            lastSaved: config.prompts.paid?.last_saved ? new Date(config.prompts.paid.last_saved) : null,
            ...calculateStats(config.prompts.paid?.template || '')
          },
          unpaid: {
            content: config.prompts.unpaid?.template || '',
            lastSaved: config.prompts.unpaid?.last_saved ? new Date(config.prompts.unpaid.last_saved) : null,
            ...calculateStats(config.prompts.unpaid?.template || '')
          },
          crawler: {
            content: config.prompts.crawler?.template || '',
            lastSaved: config.prompts.crawler?.last_saved ? new Date(config.prompts.crawler.last_saved) : null,
            ...calculateStats(config.prompts.crawler?.template || '')
          }
        });
      }
    } catch (err) {
      setSaveError(err instanceof Error ? err.message : 'Failed to load prompts');
    }
  };

  const value: PromptContextType = {
    prompts,
    activeTab,
    checkedTypes,
    editorTheme,
    history,
    canUndo,
    canRedo,
    undo,
    redo,
    saveAsVersion,
    setPromptContent,
    setActiveTab,
    setCheckedTypes,
    setEditorTheme,
    savePrompts,
    loadPrompts,
    isSaving,
    saveError
  };

  return <PromptContext.Provider value={value}>{children}</PromptContext.Provider>;
}

export function usePrompt() {
  const context = useContext(PromptContext);
  if (context === undefined) {
    throw new Error('usePrompt must be used within a PromptProvider');
  }
  return context;
}
```

**File: frontend/src/hooks/useKeyboardShortcuts.ts** (New)

Keyboard shortcut hook:

```typescript
import { useEffect } from 'react';

export function useKeyboardShortcuts(handlers: Record<string, () => void>) {
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl+Z or Cmd+Z for undo
      if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        handlers['undo']?.();
      }

      // Ctrl+Y or Cmd+Shift+Z for redo
      if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
        event.preventDefault();
        handlers['redo']?.();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handlers]);
}
```

### Frontend Component Specifications

**File: frontend/src/components/config/UndoRedoButtons.tsx** (New)

Undo/redo button controls:

```typescript
'use client';

import { Button, ButtonGroup } from 'react-bootstrap';
import { usePrompt } from '@/contexts/PromptContext';

export default function UndoRedoButtons() {
  const { activeTab, canUndo, canRedo, undo, redo } = usePrompt();

  return (
    <ButtonGroup size="sm" className="me-2">
      <Button
        variant="outline-secondary"
        onClick={() => undo(activeTab)}
        disabled={!canUndo(activeTab)}
        title="Undo (Ctrl+Z)"
      >
        <i className="bi bi-arrow-counterclockwise me-1"></i>
        Undo
      </Button>
      <Button
        variant="outline-secondary"
        onClick={() => redo(activeTab)}
        disabled={!canRedo(activeTab)}
        title="Redo (Ctrl+Y)"
      >
        <i className="bi bi-arrow-clockwise me-1"></i>
        Redo
      </Button>
    </ButtonGroup>
  );
}
```

**File: frontend/src/components/config/VersionHistoryPanel.tsx** (New)

Version history UI:

```typescript
'use client';

import { Card, ListGroup, Badge, Button, Collapse } from 'react-bootstrap';
import { useState } from 'react';
import { usePrompt } from '@/contexts/PromptContext';

export default function VersionHistoryPanel() {
  const { activeTab, history, saveAsVersion } = usePrompt();
  const [open, setOpen] = useState(true);

  const typeHistory = history[activeTab];
  const currentVersion = typeHistory.versions[typeHistory.currentIndex];

  const handleSaveAsCheckpoint = () => {
    saveAsVersion(activeTab, true);
  };

  return (
    <Card className="mt-4">
      <Card.Header
        className="cursor-pointer d-flex justify-content-between align-items-center"
        onClick={() => setOpen(!open)}
        style={{ cursor: 'pointer' }}
      >
        <div>
          <h5 className="mb-0">Version History - {activeTab}</h5>
          <small className="text-muted">
            {typeHistory.versions.length} versions | {currentVersion ? `v${typeHistory.currentIndex + 1}` : 'No versions'}
          </small>
        </div>
        <i className={`bi bi-chevron-${open ? 'up' : 'down'}`}></i>
      </Card.Header>

      <Collapse in={open}>
        <Card.Body>
          {typeHistory.versions.length === 0 ? (
            <p className="text-muted mb-0">No version history yet. Start editing to create versions.</p>
          ) : (
            <ListGroup variant="flush">
              {typeHistory.versions.map((version, idx) => {
                const isCurrent = idx === typeHistory.currentIndex;
                return (
                  <ListGroup.Item
                    key={version.id}
                    className={`d-flex justify-content-between align-items-start ${isCurrent ? 'bg-light' : ''}`}
                    style={{ cursor: 'pointer', padding: '10px' }}
                  >
                    <div className="flex-grow-1">
                      <div className="fw-bold">
                        v{idx + 1}
                        {isCurrent && <Badge bg="primary" className="ms-2">Current</Badge>}
                        {version.isManualCheckpoint && (
                          <Badge bg="success" className="ms-2">Checkpoint</Badge>
                        )}
                      </div>
                      <small className="text-muted">
                        {version.timestamp.toLocaleTimeString()} | {version.characterCount} chars | {version.wordCount} words
                      </small>
                    </div>
                    <Button
                      variant="outline-primary"
                      size="sm"
                      disabled={isCurrent}
                      onClick={() => {
                        // Load this version (would need setter in context)
                      }}
                    >
                      Load
                    </Button>
                  </ListGroup.Item>
                );
              })}
            </ListGroup>
          )}

          <Button
            variant="outline-success"
            size="sm"
            className="mt-3 w-100"
            onClick={handleSaveAsCheckpoint}
          >
            <i className="bi bi-bookmark me-1"></i>
            Save as New Version
          </Button>
        </Card.Body>
      </Collapse>
    </Card>
  );
}
```

### Implementation Notes

[Source: PRD - Epic 3: Prompt Engineering Workspace]

**Important Design Decisions**:

1. **Per-Type History**: Each prompt type (paid, unpaid, crawler) maintains separate version history in sessionStorage.

2. **Session Persistence**: History saved to sessionStorage, not MongoDB. Survives page refresh within same session.

3. **10-Version Limit**: Keeps last 10 versions only (FIFO). Prevents excessive memory usage.

4. **Auto-Checkpointing**: Every 30 seconds of inactivity, automatically creates version checkpoint (non-manual).

5. **Manual Checkpoints**: "Save as New Version" button allows explicit version marking.

6. **Keyboard Shortcuts**: Global listeners for Ctrl+Z (undo) and Ctrl+Y (redo) on any tab.

7. **Undo/Redo State**: Tracks currentIndex in history array. Can navigate forwards/backwards through history.

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 3.5**:

**Unit Tests** (frontend/__tests__/contexts/):

```typescript
// PromptContext.test.tsx (version history portion)
import { renderHook, act } from '@testing-library/react';
import { usePrompt, PromptProvider } from '@/contexts/PromptContext';

describe('PromptContext - Version History', () => {
  const wrapper = ({ children }: { children: React.ReactElement }) => (
    <PromptProvider>{children}</PromptProvider>
  );

  test('creates version entry on saveAsVersion', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'Test prompt v1');
      result.current.saveAsVersion('paid', true);
    });

    expect(result.current.history.paid.versions).toHaveLength(1);
    expect(result.current.history.paid.versions[0].template).toBe('Test prompt v1');
    expect(result.current.history.paid.versions[0].isManualCheckpoint).toBe(true);
  });

  test('undo reverts to previous version', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'Version 1');
      result.current.saveAsVersion('paid', true);
      result.current.setPromptContent('paid', 'Version 2');
      result.current.saveAsVersion('paid', true);
    });

    expect(result.current.prompts.paid.content).toBe('Version 2');

    act(() => {
      result.current.undo('paid');
    });

    expect(result.current.prompts.paid.content).toBe('Version 1');
  });

  test('redo re-applies undone change', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'v1');
      result.current.saveAsVersion('paid', true);
      result.current.setPromptContent('paid', 'v2');
      result.current.saveAsVersion('paid', true);
      result.current.undo('paid');
    });

    expect(result.current.prompts.paid.content).toBe('v1');

    act(() => {
      result.current.redo('paid');
    });

    expect(result.current.prompts.paid.content).toBe('v2');
  });

  test('enforces 10-version limit', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      for (let i = 0; i < 15; i++) {
        result.current.setPromptContent('paid', `Version ${i}`);
        result.current.saveAsVersion('paid', true);
      }
    });

    expect(result.current.history.paid.versions.length).toBeLessThanOrEqual(10);
  });

  test('canUndo/canRedo return correct state', () => {
    const { result } = renderHook(() => usePrompt(), { wrapper });

    act(() => {
      result.current.setPromptContent('paid', 'v1');
      result.current.saveAsVersion('paid', true);
      result.current.setPromptContent('paid', 'v2');
      result.current.saveAsVersion('paid', true);
    });

    expect(result.current.canUndo('paid')).toBe(true);
    expect(result.current.canRedo('paid')).toBe(false);

    act(() => {
      result.current.undo('paid');
    });

    expect(result.current.canUndo('paid')).toBe(true);
    expect(result.current.canRedo('paid')).toBe(true);
  });
});
```

**Hook Tests** (frontend/__tests__/hooks/):

```typescript
// useKeyboardShortcuts.test.ts
import { renderHook } from '@testing-library/react';
import { useKeyboardShortcuts } from '@/hooks/useKeyboardShortcuts';

describe('useKeyboardShortcuts', () => {
  test('calls undo handler on Ctrl+Z', () => {
    const handlers = {
      undo: jest.fn(),
      redo: jest.fn()
    };

    renderHook(() => useKeyboardShortcuts(handlers));

    const event = new KeyboardEvent('keydown', {
      key: 'z',
      ctrlKey: true,
      code: 'KeyZ'
    });

    window.dispatchEvent(event);
    expect(handlers.undo).toHaveBeenCalled();
  });

  test('calls redo handler on Ctrl+Y', () => {
    const handlers = {
      undo: jest.fn(),
      redo: jest.fn()
    };

    renderHook(() => useKeyboardShortcuts(handlers));

    const event = new KeyboardEvent('keydown', {
      key: 'y',
      ctrlKey: true
    });

    window.dispatchEvent(event);
    expect(handlers.redo).toHaveBeenCalled();
  });

  test('works with Cmd+Z on Mac', () => {
    const handlers = {
      undo: jest.fn(),
      redo: jest.fn()
    };

    renderHook(() => useKeyboardShortcuts(handlers));

    const event = new KeyboardEvent('keydown', {
      key: 'z',
      metaKey: true
    });

    window.dispatchEvent(event);
    expect(handlers.undo).toHaveBeenCalled();
  });
});
```

**Manual Verification Checklist**:
1. Undo/Redo buttons appear in PromptEditor
2. Undo button disabled when no history
3. Redo button disabled when at latest version
4. Ctrl+Z triggers undo
5. Ctrl+Y triggers redo
6. Version history panel shows all versions
7. Click version loads it into editor
8. "Save as New Version" creates checkpoint
9. History persists across page refresh (same session)
10. History cleared on session end
11. Per-type history isolation working
12. 10-version limit enforced
13. No console errors in browser

**Coverage Target**: 80%+ for version history logic

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 3 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context, dev notes, and testing standards | BMAD Agent |
| 2025-11-04 | 2.0 | Simplified implementation - removed visible version history to avoid redundancy with Story 3.4b | Claude Agent |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Implementation Summary

**Simplified Design**: Story 3.5 was simplified during implementation to avoid redundancy with Story 3.4b (Backend Version History). The final implementation provides undo/redo functionality without visible version history UI.

**Key Changes**:
- Removed auto-save version timer (30-second debounce)
- Removed VersionHistoryPanel component entirely
- Removed `saveAsVersion` and `loadVersion` from public API
- Kept internal version tracking for undo/redo operations
- Maintained sessionStorage persistence

**User Feedback**: "no auto saves and is there a need for versions" - led to design simplification

### File List

**Created**:
- [frontend/src/hooks/useKeyboardShortcuts.ts](frontend/src/hooks/useKeyboardShortcuts.ts) - Keyboard shortcut hook for Ctrl+Z/Ctrl+Y
- [frontend/src/components/config/UndoRedoButtons.tsx](frontend/src/components/config/UndoRedoButtons.tsx) - Undo/Redo button controls
- [frontend/src/components/config/VersionHistoryPanel.tsx](frontend/src/components/config/VersionHistoryPanel.tsx) - Created then removed (not used)

**Modified**:
- [frontend/src/contexts/PromptContext.tsx](frontend/src/contexts/PromptContext.tsx) - Extended with undo/redo version history tracking
- [frontend/src/components/config/PromptEditor.tsx](frontend/src/components/config/PromptEditor.tsx) - Added UndoRedoButtons and keyboard shortcuts

### Completion Notes

1. ✅ Undo/Redo functionality working with keyboard shortcuts
2. ✅ Per-prompt-type history isolation maintained
3. ✅ sessionStorage persistence for undo/redo stack
4. ✅ 10-version FIFO limit enforced
5. ✅ Clean UX with single version system (backend versions in PreviewModal)
6. ✅ No duplicate version displays
7. ✅ Documentation updated to reflect simplified design

## QA Results

*To be filled by QA agent*
