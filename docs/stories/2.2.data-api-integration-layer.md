# Story 2.2: Data API Integration Layer

## Status

Draft

## Story

**As a** developer,
**I want** a flexible adapter layer for integrating external data APIs,
**so that** the system can fetch financial data from multiple sources reliably.

## Acceptance Criteria

1. Python module `data_adapters/` created with base `DataAPIAdapter` abstract class defining interface (fetch_data method)
2. At least two concrete adapter implementations (e.g., `EarningsAPIAdapter`, `PriceDataAPIAdapter`)
3. Each adapter handles API authentication (API keys from environment variables or Secrets Manager)
4. Adapters implement retry logic with exponential backoff for transient failures (503, timeout)
5. Adapters implement rate limiting to respect API quotas (using Python ratelimit library)
6. All API calls logged with request URL, response status, and latency
7. Adapter registry pattern allows dynamic lookup of adapters by API identifier
8. Unit tests for adapter logic with mocked HTTP responses (using httpx Mock or responses library)
9. Integration tests against sandbox/test endpoints or mocked APIs validate error handling (404, 500, timeout)

## Tasks / Subtasks

- [ ] Task 1: Create data_adapters module structure (AC: 1, 7)
  - [ ] Create backend/app/data_adapters/__init__.py
  - [ ] Create backend/app/data_adapters/base.py - Abstract base class
  - [ ] Create backend/app/data_adapters/registry.py - Adapter registry
  - [ ] Define DataAPIAdapter interface with fetch_data method
- [ ] Task 2: Implement base adapter functionality (AC: 3, 4, 5, 6)
  - [ ] Add API authentication handling
  - [ ] Implement retry logic with exponential backoff
  - [ ] Implement rate limiting
  - [ ] Add request/response logging
  - [ ] Add latency tracking
- [ ] Task 3: Create concrete adapter implementations (AC: 2)
  - [ ] Create EarningsAPIAdapter
  - [ ] Create PriceDataAPIAdapter
  - [ ] Implement fetch_data for each adapter
  - [ ] Handle adapter-specific data formatting
- [ ] Task 4: Implement adapter registry (AC: 7)
  - [ ] Create registry dictionary mapping API IDs to adapter classes
  - [ ] Implement get_adapter method
  - [ ] Add adapter registration decorator
- [ ] Task 5: Add environment configuration (AC: 3)
  - [ ] Define environment variables for API keys
  - [ ] Implement AWS Secrets Manager integration
  - [ ] Add fallback to local environment variables for development
- [ ] Task 6: Write unit and integration tests (AC: 8, 9)
  - [ ] Test base adapter retry logic
  - [ ] Test rate limiting functionality
  - [ ] Test concrete adapters with mocked responses
  - [ ] Test error handling (404, 500, timeout)
  - [ ] Test adapter registry lookup

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 2.1 - Completion]

Before starting this story, ensure Story 2.1 is complete:
- Configuration Workspace page exists
- POST /api/triggers/:id/config/sections endpoint works
- Configuration model in MongoDB
- Section selection UI functional

### Project Structure & File Locations

[Source: architecture.md - Source Tree and Module Organization - Backend Module Structure]

**Backend files to create** in `backend/app/`:
```
backend/app/
├── data_adapters/
│   ├── __init__.py                     # Module initialization, exports
│   ├── base.py                         # DataAPIAdapter abstract base class (NEW)
│   ├── registry.py                     # Adapter registry for dynamic lookup (NEW)
│   ├── earnings_api.py                 # Earnings data adapter (NEW)
│   ├── price_api.py                    # Price data adapter (NEW)
│   └── utils.py                        # Helper functions (retry, rate limiting) (NEW)
└── config.py                           # Update: Add API key configuration
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Backend Stack for Data Adapters**:
- **Python**: 3.11+ - Async/await support
- **httpx**: Async HTTP client for API calls
- **tenacity**: Python library for retry logic with exponential backoff
- **aiohttp**: Alternative async HTTP client
- **AWS SDK (boto3)**: For Secrets Manager integration
- **python-dotenv**: Environment variable management

### Base Adapter Class Specification

[Source: architecture.md - Epic 2 - Data Pipeline - Data API Integration Layer]

**File: backend/app/data_adapters/base.py**

Abstract base class for all data API adapters:

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
import httpx
import logging
import time
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from datetime import datetime

logger = logging.getLogger(__name__)

class DataAPIAdapter(ABC):
    """
    Abstract base class for data API adapters
    All concrete adapters must implement fetch_data method
    """

    def __init__(self, api_key: Optional[str] = None, config: Optional[Dict] = None):
        """
        Initialize adapter with API credentials

        Args:
            api_key: API key for authentication (from env or Secrets Manager)
            config: Additional configuration (rate limits, timeouts, etc.)
        """
        self.api_key = api_key
        self.config = config or {}
        self.timeout = self.config.get('timeout', 10.0)
        self.max_retries = self.config.get('max_retries', 3)

    @abstractmethod
    async def fetch_data(self, stock_id: str, section_id: str, **kwargs) -> Dict[str, Any]:
        """
        Fetch data from external API for given stock and section

        Args:
            stock_id: Stock ticker symbol (e.g., "AAPL")
            section_id: Data section identifier (e.g., "1", "2", "3")
            **kwargs: Additional parameters specific to the API

        Returns:
            Dict containing:
                - status: "success" | "error"
                - data: Raw JSON data from API
                - metadata: Request metadata (latency, timestamp, etc.)

        Raises:
            HTTPError: If API call fails after retries
            TimeoutError: If API call times out
        """
        pass

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((httpx.HTTPStatusError, httpx.TimeoutException)),
        reraise=True
    )
    async def _make_request(
        self,
        url: str,
        method: str = "GET",
        headers: Optional[Dict] = None,
        params: Optional[Dict] = None,
        json_data: Optional[Dict] = None
    ) -> httpx.Response:
        """
        Make HTTP request with retry logic and logging

        Args:
            url: API endpoint URL
            method: HTTP method (GET, POST, etc.)
            headers: Request headers
            params: Query parameters
            json_data: JSON request body

        Returns:
            httpx.Response object

        Raises:
            httpx.HTTPStatusError: If response status indicates error
            httpx.TimeoutException: If request times out
        """
        start_time = time.time()

        async with httpx.AsyncClient(timeout=self.timeout) as client:
            try:
                logger.info(f"Making {method} request to {url}")

                response = await client.request(
                    method=method,
                    url=url,
                    headers=headers,
                    params=params,
                    json=json_data
                )

                latency = time.time() - start_time

                logger.info(
                    f"API request completed: {method} {url} - "
                    f"Status: {response.status_code}, Latency: {latency:.2f}s"
                )

                # Raise exception for 4xx/5xx status codes
                response.raise_for_status()

                return response

            except httpx.HTTPStatusError as e:
                latency = time.time() - start_time
                logger.error(
                    f"API request failed: {method} {url} - "
                    f"Status: {e.response.status_code}, Latency: {latency:.2f}s, "
                    f"Error: {str(e)}"
                )
                raise

            except httpx.TimeoutException as e:
                latency = time.time() - start_time
                logger.error(
                    f"API request timeout: {method} {url} - "
                    f"Timeout: {self.timeout}s, Latency: {latency:.2f}s"
                )
                raise

            except Exception as e:
                latency = time.time() - start_time
                logger.error(
                    f"Unexpected error during API request: {method} {url} - "
                    f"Latency: {latency:.2f}s, Error: {str(e)}"
                )
                raise

    def _get_auth_headers(self) -> Dict[str, str]:
        """
        Get authentication headers for API requests

        Returns:
            Dict of headers including API key authorization
        """
        if not self.api_key:
            raise ValueError("API key not configured")

        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
```

### Concrete Adapter Implementations

[Source: architecture.md - Epic 2 - Data Pipeline APIs]

**File: backend/app/data_adapters/earnings_api.py**

Example concrete adapter for earnings data:

```python
from typing import Dict, Any
from .base import DataAPIAdapter
import logging

logger = logging.getLogger(__name__)

class EarningsAPIAdapter(DataAPIAdapter):
    """
    Adapter for fetching earnings data from external API
    """

    def __init__(self, api_key: str, config: Dict = None):
        super().__init__(api_key, config)
        self.base_url = "https://api.example.com/v1/earnings"

    async def fetch_data(self, stock_id: str, section_id: str, **kwargs) -> Dict[str, Any]:
        """
        Fetch earnings data for given stock

        Args:
            stock_id: Stock ticker (e.g., "AAPL")
            section_id: Data section ID
            **kwargs: Optional parameters (quarter, year, etc.)

        Returns:
            Dict with status, data, and metadata
        """
        try:
            url = f"{self.base_url}/{stock_id}"
            headers = self._get_auth_headers()
            params = {
                "section": section_id,
                **kwargs
            }

            response = await self._make_request(
                url=url,
                method="GET",
                headers=headers,
                params=params
            )

            data = response.json()

            return {
                "status": "success",
                "data": data,
                "metadata": {
                    "timestamp": response.headers.get("Date"),
                    "latency": response.elapsed.total_seconds() if hasattr(response, 'elapsed') else None,
                    "stock_id": stock_id,
                    "section_id": section_id
                }
            }

        except Exception as e:
            logger.error(f"Failed to fetch earnings data for {stock_id}: {str(e)}")
            return {
                "status": "error",
                "error": str(e),
                "data": None,
                "metadata": {
                    "stock_id": stock_id,
                    "section_id": section_id
                }
            }
```

**File: backend/app/data_adapters/price_api.py**

Example adapter for price data:

```python
from typing import Dict, Any
from .base import DataAPIAdapter
import logging

logger = logging.getLogger(__name__)

class PriceDataAPIAdapter(DataAPIAdapter):
    """
    Adapter for fetching price/market data from external API
    """

    def __init__(self, api_key: str, config: Dict = None):
        super().__init__(api_key, config)
        self.base_url = "https://api.example.com/v1/prices"

    async def fetch_data(self, stock_id: str, section_id: str, **kwargs) -> Dict[str, Any]:
        """
        Fetch price data for given stock

        Args:
            stock_id: Stock ticker (e.g., "AAPL")
            section_id: Data section ID
            **kwargs: Optional parameters (period, interval, etc.)

        Returns:
            Dict with status, data, and metadata
        """
        try:
            url = f"{self.base_url}/{stock_id}"
            headers = self._get_auth_headers()
            params = {
                "section": section_id,
                **kwargs
            }

            response = await self._make_request(
                url=url,
                method="GET",
                headers=headers,
                params=params
            )

            data = response.json()

            return {
                "status": "success",
                "data": data,
                "metadata": {
                    "timestamp": response.headers.get("Date"),
                    "latency": response.elapsed.total_seconds() if hasattr(response, 'elapsed') else None,
                    "stock_id": stock_id,
                    "section_id": section_id
                }
            }

        except Exception as e:
            logger.error(f"Failed to fetch price data for {stock_id}: {str(e)}")
            return {
                "status": "error",
                "error": str(e),
                "data": None,
                "metadata": {
                    "stock_id": stock_id,
                    "section_id": section_id
                }
            }
```

### Adapter Registry Implementation

[Source: architecture.md - Source Tree and Module Organization]

**File: backend/app/data_adapters/registry.py**

```python
from typing import Dict, Type, Optional
from .base import DataAPIAdapter
from .earnings_api import EarningsAPIAdapter
from .price_api import PriceDataAPIAdapter
import logging

logger = logging.getLogger(__name__)

class AdapterRegistry:
    """
    Registry for data API adapters
    Allows dynamic lookup of adapters by API identifier
    """

    _adapters: Dict[str, Type[DataAPIAdapter]] = {}

    @classmethod
    def register(cls, api_id: str, adapter_class: Type[DataAPIAdapter]):
        """
        Register an adapter class with an API identifier

        Args:
            api_id: Unique identifier for the API (e.g., "earnings_api")
            adapter_class: Adapter class to register
        """
        cls._adapters[api_id] = adapter_class
        logger.info(f"Registered adapter: {api_id} -> {adapter_class.__name__}")

    @classmethod
    def get_adapter(cls, api_id: str, api_key: str, config: Dict = None) -> Optional[DataAPIAdapter]:
        """
        Get an adapter instance by API identifier

        Args:
            api_id: API identifier
            api_key: API key for authentication
            config: Optional configuration for adapter

        Returns:
            Instantiated adapter or None if not found
        """
        adapter_class = cls._adapters.get(api_id)

        if not adapter_class:
            logger.error(f"Adapter not found for API ID: {api_id}")
            return None

        return adapter_class(api_key=api_key, config=config)

    @classmethod
    def list_adapters(cls) -> list:
        """
        Get list of registered adapter IDs

        Returns:
            List of API identifiers
        """
        return list(cls._adapters.keys())

# Register adapters
AdapterRegistry.register("earnings_api", EarningsAPIAdapter)
AdapterRegistry.register("price_api", PriceDataAPIAdapter)
```

### Environment Variables

[Source: architecture.md - Development and Deployment - Environment Variables]

Update `.env.example`:
```
# Data API Keys (Story 2.2)
EARNINGS_API_KEY=<from Secrets Manager or local for dev>
PRICE_API_KEY=<from Secrets Manager or local for dev>

# Data API Configuration
DATA_API_TIMEOUT=10.0
DATA_API_MAX_RETRIES=3
DATA_API_RATE_LIMIT=100  # requests per minute
```

### AWS Secrets Manager Integration

[Source: architecture.md - AWS Infrastructure Requirements]

**File: backend/app/config.py** (update):

```python
import os
import boto3
from botocore.exceptions import ClientError
import logging

logger = logging.getLogger(__name__)

def get_api_key(secret_name: str, fallback_env_var: str) -> str:
    """
    Get API key from AWS Secrets Manager or fall back to environment variable

    Args:
        secret_name: Name of secret in AWS Secrets Manager
        fallback_env_var: Environment variable name as fallback

    Returns:
        API key string
    """
    # Try AWS Secrets Manager first (production)
    if os.getenv("USE_AWS_SECRETS", "false").lower() == "true":
        try:
            client = boto3.client('secretsmanager', region_name=os.getenv("AWS_REGION", "us-east-1"))
            response = client.get_secret_value(SecretId=secret_name)
            logger.info(f"Retrieved API key from Secrets Manager: {secret_name}")
            return response['SecretString']
        except ClientError as e:
            logger.error(f"Failed to retrieve secret from AWS: {e}")

    # Fall back to environment variable (development)
    api_key = os.getenv(fallback_env_var)
    if api_key:
        logger.info(f"Using API key from environment variable: {fallback_env_var}")
        return api_key

    raise ValueError(f"API key not found: {secret_name} or {fallback_env_var}")

# API key configuration
EARNINGS_API_KEY = get_api_key("news-cms/data/earnings-api-key", "EARNINGS_API_KEY")
PRICE_API_KEY = get_api_key("news-cms/data/price-api-key", "PRICE_API_KEY")
```

### Implementation Notes

**Important Design Decisions**:

1. **Retry Logic**: Uses `tenacity` library for exponential backoff on transient failures (503, timeout)
2. **Rate Limiting**: Implement at adapter level to respect API quotas
3. **Logging**: All requests logged with URL, status, latency for debugging
4. **Error Handling**: Adapters return structured error responses, never raise exceptions to frontend
5. **AWS Secrets Manager**: Production uses Secrets Manager; development falls back to environment variables

**Financial Data API Providers** (BLOCKER):
- Specific providers not yet identified (flagged in architecture.md)
- Story 2.2 creates infrastructure; actual API endpoints TBD
- Mock implementations sufficient for Story 2.2 completion

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 2.2**:

**Unit Tests** (backend/tests/test_data_adapters.py):

```python
import pytest
from unittest.mock import AsyncMock, patch
from app.data_adapters.base import DataAPIAdapter
from app.data_adapters.earnings_api import EarningsAPIAdapter
from app.data_adapters.registry import AdapterRegistry
import httpx

@pytest.mark.asyncio
async def test_base_adapter_retry_logic():
    """Test retry logic with exponential backoff"""
    adapter = EarningsAPIAdapter(api_key="test_key")

    # Mock failed request that succeeds on retry
    with patch.object(adapter, '_make_request') as mock_request:
        mock_request.side_effect = [
            httpx.HTTPStatusError("503 error", request=None, response=None),
            AsyncMock(json=lambda: {"data": "success"}, status_code=200)
        ]

        result = await adapter.fetch_data("AAPL", "1")
        assert result["status"] == "success"
        assert mock_request.call_count >= 2  # At least one retry

@pytest.mark.asyncio
async def test_earnings_adapter_fetch_data():
    """Test earnings adapter with mocked HTTP response"""
    adapter = EarningsAPIAdapter(api_key="test_key")

    mock_response = AsyncMock()
    mock_response.json.return_value = {"earnings": {"eps": 1.50}}
    mock_response.status_code = 200
    mock_response.headers = {"Date": "2025-10-29"}

    with patch.object(adapter, '_make_request', return_value=mock_response):
        result = await adapter.fetch_data("AAPL", "1")

        assert result["status"] == "success"
        assert result["data"]["earnings"]["eps"] == 1.50
        assert result["metadata"]["stock_id"] == "AAPL"

@pytest.mark.asyncio
async def test_adapter_error_handling():
    """Test adapter handles API errors gracefully"""
    adapter = EarningsAPIAdapter(api_key="test_key")

    with patch.object(adapter, '_make_request', side_effect=httpx.TimeoutException("Timeout")):
        result = await adapter.fetch_data("AAPL", "1")

        assert result["status"] == "error"
        assert "Timeout" in result["error"]

def test_adapter_registry_lookup():
    """Test adapter registry registration and lookup"""
    adapter = AdapterRegistry.get_adapter("earnings_api", api_key="test_key")
    assert adapter is not None
    assert isinstance(adapter, EarningsAPIAdapter)

def test_adapter_registry_list():
    """Test listing registered adapters"""
    adapters = AdapterRegistry.list_adapters()
    assert "earnings_api" in adapters
    assert "price_api" in adapters

@pytest.mark.asyncio
async def test_adapter_authentication():
    """Test API authentication headers"""
    adapter = EarningsAPIAdapter(api_key="test_key_12345")
    headers = adapter._get_auth_headers()

    assert "Authorization" in headers
    assert headers["Authorization"] == "Bearer test_key_12345"

@pytest.mark.asyncio
async def test_adapter_timeout_configuration():
    """Test custom timeout configuration"""
    adapter = EarningsAPIAdapter(api_key="test_key", config={"timeout": 5.0})
    assert adapter.timeout == 5.0

@pytest.mark.asyncio
async def test_adapter_logging(caplog):
    """Test that API calls are logged correctly"""
    adapter = EarningsAPIAdapter(api_key="test_key")

    mock_response = AsyncMock()
    mock_response.json.return_value = {"data": "success"}
    mock_response.status_code = 200

    with patch.object(adapter, '_make_request', return_value=mock_response):
        await adapter.fetch_data("AAPL", "1")

        # Check logs contain request information
        assert any("Making GET request" in record.message for record in caplog.records)
        assert any("API request completed" in record.message for record in caplog.records)
```

**Integration Tests**:

```python
import pytest
from app.data_adapters.earnings_api import EarningsAPIAdapter

@pytest.mark.integration
@pytest.mark.asyncio
async def test_earnings_api_integration():
    """
    Integration test against sandbox/mock API endpoint
    Requires EARNINGS_API_KEY environment variable
    """
    import os
    api_key = os.getenv("EARNINGS_API_KEY_TEST", "mock_key")

    adapter = EarningsAPIAdapter(api_key=api_key)

    # Use mock/sandbox endpoint if available
    result = await adapter.fetch_data("AAPL", "1")

    # Should handle response or error gracefully
    assert "status" in result
    assert "data" in result or "error" in result
```

**Manual Verification**:
1. Adapter registry lists registered adapters correctly
2. API calls with valid credentials return data successfully
3. API calls with invalid credentials fail gracefully with error messages
4. Retry logic activates on transient failures (503, timeout)
5. Requests logged with URL, status, and latency
6. AWS Secrets Manager integration works in staging environment
7. Environment variable fallback works in local development
8. Rate limiting prevents excessive API calls

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 2 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
