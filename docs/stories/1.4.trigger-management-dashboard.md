# Story 1.4: Trigger Management Dashboard

## Status

Draft

## Story

**As a** content manager,
**I want** to view a list of available news triggers with status information,
**so that** I can select a trigger to configure.

## Acceptance Criteria

1. FastAPI endpoint `GET /api/triggers` returns list of all triggers from MongoDB (name, description, status, last_updated)
2. Frontend Dashboard page fetches and displays triggers in Bootstrap Table or Card grid
3. Each trigger shows: name, description, configuration status (Configured/Unconfigured), last updated timestamp
4. Visual status indicator (badge or icon) distinguishes configured vs. unconfigured triggers
5. Clicking a trigger navigates to Configuration Workspace with trigger ID in URL (`/config/:triggerId`)
6. Empty state displayed if no triggers exist (with message suggesting database seeding)
7. Loading state displayed while fetching triggers from API
8. Error handling displays user-friendly message if API call fails
9. Meets NFR1: Page loads in under 2 seconds with 10+ triggers

## Tasks / Subtasks

- [ ] Task 1: Create FastAPI endpoint for trigger list (AC: 1, 8)
  - [ ] Create backend/app/routers/triggers.py
  - [ ] Implement GET /api/triggers endpoint
  - [ ] Query MongoDB triggers collection
  - [ ] Return trigger list with proper error handling
  - [ ] Add endpoint to main.py router
- [ ] Task 2: Create Dashboard page with trigger display (AC: 2, 3, 4)
  - [ ] Create frontend/src/app/page.tsx (Dashboard)
  - [ ] Fetch triggers from API on page load
  - [ ] Display triggers in Bootstrap Card grid layout
  - [ ] Show name, description, status badge, last updated
  - [ ] Add visual indicators for configured/unconfigured status
- [ ] Task 3: Implement trigger navigation (AC: 5)
  - [ ] Add click handler to each trigger card
  - [ ] Navigate to /config/:triggerId using Next.js router
  - [ ] Pass trigger ID in URL parameter
- [ ] Task 4: Implement empty and loading states (AC: 6, 7)
  - [ ] Create loading state with LoadingSpinner component
  - [ ] Create empty state component with seed data message
  - [ ] Display appropriate state based on data fetch status
- [ ] Task 5: Implement error handling (AC: 8)
  - [ ] Catch API errors
  - [ ] Display user-friendly error message
  - [ ] Provide retry button
- [ ] Task 6: Optimize for performance (AC: 9)
  - [ ] Implement efficient MongoDB query
  - [ ] Test page load time with 10+ triggers
  - [ ] Ensure sub-2-second load time (NFR1)
- [ ] Task 7: Write unit and integration tests (Testing Requirements)
  - [ ] Test GET /api/triggers endpoint
  - [ ] Test Dashboard component rendering
  - [ ] Test trigger navigation
  - [ ] Test empty and loading states
  - [ ] Test error handling

## Dev Notes

### Prerequisites from Previous Stories

[Source: Story 1.1, 1.2, 1.3 - Completion]

Before starting this story, ensure the following stories are complete:
- **Story 1.1**: Monorepo structure, FastAPI and Next.js initialized
- **Story 1.2**: MongoDB connected, Trigger model created, seed data available
- **Story 1.3**: UI shell with Navbar, Footer, LoadingSpinner component

### Project Structure and File Locations

[Source: architecture.md - Source Tree and Module Organization]

**Backend files to create**:
```
backend/app/
├── routers/
│   └── triggers.py              # Trigger management endpoints (THIS STORY)
```

**Frontend files to create/modify**:
```
frontend/src/
├── app/
│   └── page.tsx                 # Dashboard page (THIS STORY)
├── components/
│   └── dashboard/               # Dashboard-specific components (THIS STORY)
│       ├── TriggerSelector.tsx  # Trigger card/list component
│       ├── QuickStats.tsx       # Stats cards (optional for MVP)
│       └── RecentActivity.tsx   # Activity list (optional for MVP)
```

### Technology Stack Details

[Source: architecture.md - High Level Architecture - Planned Tech Stack]

**Backend**:
- FastAPI with async endpoints
- Motor (async MongoDB driver)
- Pydantic models for validation

**Frontend**:
- Next.js 14+ with App Router
- React-Bootstrap for UI components
- TypeScript for type safety

### Backend API Specification

[Source: architecture.md - Data Models and APIs - Epic 1 Foundation APIs]

**File: backend/app/routers/triggers.py**

```python
from fastapi import APIRouter, HTTPException
from typing import List
from datetime import datetime
from ..database import get_database
from ..models.trigger import Trigger
import logging

router = APIRouter(prefix="/api/triggers", tags=["triggers"])
logger = logging.getLogger(__name__)

@router.get("/", response_model=List[Trigger])
async def get_triggers():
    """
    Get all triggers from MongoDB
    Returns: List of triggers with name, description, status, last_updated
    """
    try:
        db = get_database()

        if db is None:
            raise HTTPException(status_code=503, detail="Database not connected")

        # Query all triggers from MongoDB
        triggers_cursor = db.triggers.find({})
        triggers_list = await triggers_cursor.to_list(length=100)

        # Convert MongoDB documents to Pydantic models
        triggers = []
        for trigger_doc in triggers_list:
            try:
                trigger = Trigger(**trigger_doc)
                triggers.append(trigger)
            except Exception as e:
                logger.warning(f"Failed to parse trigger {trigger_doc.get('_id')}: {e}")
                continue

        logger.info(f"Retrieved {len(triggers)} triggers")
        return triggers

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to retrieve triggers: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve triggers")

@router.get("/{trigger_id}/config")
async def get_trigger_config(trigger_id: str):
    """
    Get configuration for a specific trigger
    Will be fully implemented in Epic 2-3
    """
    try:
        db = get_database()

        if db is None:
            raise HTTPException(status_code=503, detail="Database not connected")

        # Find trigger
        trigger = await db.triggers.find_one({"_id": trigger_id})

        if not trigger:
            raise HTTPException(status_code=404, detail="Trigger not found")

        # Find active configuration (will be implemented in Epic 2)
        config = await db.configurations.find_one({"trigger_id": trigger_id, "is_active": True})

        return {
            "trigger_id": trigger_id,
            "trigger": trigger,
            "configuration": config if config else None
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to retrieve trigger config: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve trigger configuration")
```

**Register router in backend/app/main.py**:
```python
from .routers import health, triggers

app.include_router(health.router)
app.include_router(triggers.router)
```

### Trigger Model Reference

[Source: architecture.md - Data Models and APIs - Trigger Model]

**Trigger Model** (already created in Story 1.2):
```python
class Trigger(BaseModel):
    id: str = Field(alias="_id")
    name: str                           # e.g., "Earnings Alert"
    description: str
    trigger_type: str                   # e.g., "earnings", "price_movement"
    status: str                         # "configured" | "unconfigured" | "in_progress"
    last_updated: datetime
    created_at: datetime
    created_by: str                     # User ID
```

### Frontend Dashboard Page

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/app/page.tsx**

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Container, Row, Col, Card, Badge, Alert } from 'react-bootstrap';
import { useRouter } from 'next/navigation';
import LoadingSpinner from '@/components/common/LoadingSpinner';

interface Trigger {
  id: string;
  name: string;
  description: string;
  trigger_type: string;
  status: 'configured' | 'unconfigured' | 'in_progress';
  last_updated: string;
  created_at: string;
  created_by: string;
}

export default function DashboardPage() {
  const [triggers, setTriggers] = useState<Trigger[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    fetchTriggers();
  }, []);

  const fetchTriggers = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('http://localhost:8000/api/triggers');

      if (!response.ok) {
        throw new Error(`Failed to fetch triggers: ${response.statusText}`);
      }

      const data = await response.json();
      setTriggers(data);
    } catch (err) {
      console.error('Error fetching triggers:', err);
      setError(err instanceof Error ? err.message : 'Failed to load triggers');
    } finally {
      setLoading(false);
    }
  };

  const handleTriggerClick = (triggerId: string) => {
    router.push(`/config/${triggerId}`);
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'configured':
        return <Badge bg="success">Configured</Badge>;
      case 'unconfigured':
        return <Badge bg="secondary">Unconfigured</Badge>;
      case 'in_progress':
        return <Badge bg="warning">In Progress</Badge>;
      default:
        return <Badge bg="secondary">{status}</Badge>;
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
  };

  // Loading state
  if (loading) {
    return (
      <Container className="py-5">
        <LoadingSpinner size="lg" message="Loading triggers..." />
      </Container>
    );
  }

  // Error state
  if (error) {
    return (
      <Container className="py-5">
        <Alert variant="danger">
          <Alert.Heading>Error Loading Triggers</Alert.Heading>
          <p>{error}</p>
          <button className="btn btn-primary" onClick={fetchTriggers}>
            Retry
          </button>
        </Alert>
      </Container>
    );
  }

  // Empty state
  if (triggers.length === 0) {
    return (
      <Container className="py-5">
        <Alert variant="info">
          <Alert.Heading>No Triggers Found</Alert.Heading>
          <p>No triggers are currently available. Run the seed data script to populate sample triggers:</p>
          <code className="d-block bg-light p-3 mt-2">
            python scripts/seed_data.py
          </code>
        </Alert>
      </Container>
    );
  }

  // Main content
  return (
    <Container className="py-4">
      <h1 className="mb-4">Trigger Management Dashboard</h1>

      <Row>
        {triggers.map((trigger) => (
          <Col key={trigger.id} xs={12} md={6} lg={4} className="mb-4">
            <Card
              className="h-100 cursor-pointer hover-shadow"
              onClick={() => handleTriggerClick(trigger.id)}
              style={{ cursor: 'pointer' }}
            >
              <Card.Body>
                <div className="d-flex justify-content-between align-items-start mb-2">
                  <Card.Title className="mb-0">{trigger.name}</Card.Title>
                  {getStatusBadge(trigger.status)}
                </div>

                <Card.Text className="text-muted small mb-3">
                  {trigger.description}
                </Card.Text>

                <div className="small text-muted">
                  <div><strong>Type:</strong> {trigger.trigger_type}</div>
                  <div><strong>Last Updated:</strong> {formatDate(trigger.last_updated)}</div>
                </div>
              </Card.Body>

              <Card.Footer className="bg-transparent border-top-0">
                <small className="text-primary">Click to configure →</small>
              </Card.Footer>
            </Card>
          </Col>
        ))}
      </Row>
    </Container>
  );
}
```

**Add hover effect to frontend/src/app/globals.css**:
```css
.cursor-pointer:hover {
  transform: translateY(-2px);
  transition: transform 0.2s ease-in-out;
}

.hover-shadow:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}
```

### Configuration Workspace Placeholder

[Source: architecture.md - Source Tree and Module Organization - Frontend Module Structure]

**File: frontend/src/app/config/[triggerId]/page.tsx**

Create placeholder page for Configuration Workspace (will be populated in Epic 2):

```typescript
'use client';

import { useParams } from 'next/navigation';
import { Container, Alert } from 'react-bootstrap';

export default function ConfigurationWorkspacePage() {
  const params = useParams();
  const triggerId = params.triggerId as string;

  return (
    <Container className="py-5">
      <Alert variant="info">
        <Alert.Heading>Configuration Workspace</Alert.Heading>
        <p>Trigger ID: <strong>{triggerId}</strong></p>
        <p>Configuration workspace will be implemented in Epic 2.</p>
      </Alert>
    </Container>
  );
}
```

### API Client Configuration

[Source: architecture.md - Technical Assumptions - Frontend Technology Stack]

**File: frontend/src/lib/api.ts** (create if not exists):

```typescript
// API configuration
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

export const apiClient = {
  get: async (endpoint: string) => {
    const response = await fetch(`${API_BASE_URL}${endpoint}`);
    if (!response.ok) {
      throw new Error(`API error: ${response.statusText}`);
    }
    return response.json();
  },

  post: async (endpoint: string, data: any) => {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new Error(`API error: ${response.statusText}`);
    }
    return response.json();
  },
};
```

### Performance Optimization

[Source: PRD - Non-Functional Requirements]

**NFR1**: Page loads in under 2 seconds

**Optimization strategies**:
1. **MongoDB Query**: Index on `status` field for faster filtering
2. **Pagination**: Limit to 100 triggers initially (sufficient for MVP)
3. **Caching**: Consider React Query or SWR for client-side caching (post-MVP)
4. **Lazy Loading**: Load trigger details on click, not upfront

### Important Implementation Notes

1. **CORS Configuration**: Ensure FastAPI allows requests from Next.js dev server (localhost:3000)
2. **Error Handling**: Always catch and display user-friendly error messages
3. **Loading States**: Show loading spinner during API calls for better UX
4. **Empty States**: Provide clear guidance when no triggers exist
5. **Status Colors**: Use Bootstrap badge variants for visual clarity
6. **Responsive Design**: Ensure card grid works on desktop, tablet, mobile
7. **Navigation**: Use Next.js `useRouter` for client-side navigation

### Testing

[Source: PRD - Technical Assumptions - Testing Requirements]

**Testing Strategy for Story 1.4**:

**Backend Unit Tests** (backend/tests/test_triggers.py):

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

@pytest.mark.asyncio
async def test_get_triggers_success():
    """Test GET /api/triggers returns trigger list"""
    response = client.get("/api/triggers")
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)

    if len(data) > 0:
        trigger = data[0]
        assert "id" in trigger
        assert "name" in trigger
        assert "status" in trigger

@pytest.mark.asyncio
async def test_get_triggers_empty():
    """Test GET /api/triggers with no triggers in database"""
    # Clear database first
    response = client.get("/api/triggers")
    assert response.status_code == 200
    assert isinstance(response.json(), list)

@pytest.mark.asyncio
async def test_get_trigger_config_success():
    """Test GET /api/triggers/:id/config returns configuration"""
    # Assume trigger_001 exists from seed data
    response = client.get("/api/triggers/trigger_001/config")
    assert response.status_code == 200
    data = response.json()
    assert "trigger_id" in data
    assert "trigger" in data

@pytest.mark.asyncio
async def test_get_trigger_config_not_found():
    """Test GET /api/triggers/:id/config with invalid ID"""
    response = client.get("/api/triggers/invalid_id/config")
    assert response.status_code == 404
```

**Frontend Unit Tests** (frontend/__tests__/app/page.test.tsx):

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import DashboardPage from '@/app/page';

// Mock fetch
global.fetch = jest.fn();

describe('Dashboard Page', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('displays loading state initially', () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => [],
    });

    render(<DashboardPage />);
    expect(screen.getByText('Loading triggers...')).toBeInTheDocument();
  });

  test('displays triggers after successful fetch', async () => {
    const mockTriggers = [
      {
        id: 'trigger_001',
        name: 'Earnings Alert',
        description: 'Test description',
        trigger_type: 'earnings',
        status: 'configured',
        last_updated: new Date().toISOString(),
        created_at: new Date().toISOString(),
        created_by: 'test_user',
      },
    ];

    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => mockTriggers,
    });

    render(<DashboardPage />);

    await waitFor(() => {
      expect(screen.getByText('Earnings Alert')).toBeInTheDocument();
      expect(screen.getByText('Test description')).toBeInTheDocument();
      expect(screen.getByText('Configured')).toBeInTheDocument();
    });
  });

  test('displays empty state when no triggers', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => [],
    });

    render(<DashboardPage />);

    await waitFor(() => {
      expect(screen.getByText('No Triggers Found')).toBeInTheDocument();
      expect(screen.getByText(/python scripts\/seed_data.py/)).toBeInTheDocument();
    });
  });

  test('displays error state on fetch failure', async () => {
    (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

    render(<DashboardPage />);

    await waitFor(() => {
      expect(screen.getByText('Error Loading Triggers')).toBeInTheDocument();
      expect(screen.getByText('Retry')).toBeInTheDocument();
    });
  });

  test('navigates to config page on trigger click', async () => {
    const mockTriggers = [
      {
        id: 'trigger_001',
        name: 'Earnings Alert',
        description: 'Test',
        trigger_type: 'earnings',
        status: 'configured',
        last_updated: new Date().toISOString(),
        created_at: new Date().toISOString(),
        created_by: 'test',
      },
    ];

    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => mockTriggers,
    });

    const mockPush = jest.fn();
    jest.mock('next/navigation', () => ({
      useRouter: () => ({ push: mockPush }),
    }));

    render(<DashboardPage />);

    await waitFor(() => {
      const card = screen.getByText('Earnings Alert').closest('.card');
      card?.click();
      expect(mockPush).toHaveBeenCalledWith('/config/trigger_001');
    });
  });
});
```

**Integration Tests**:

```python
# backend/tests/integration/test_triggers_integration.py
import pytest
from motor.motor_asyncio import AsyncIOMotorClient
from app.main import app
from fastapi.testclient import TestClient

@pytest.mark.asyncio
async def test_full_trigger_workflow():
    """Test complete workflow: seed data → fetch triggers → get config"""
    client = TestClient(app)

    # 1. Seed test data
    mongodb_client = AsyncIOMotorClient("mongodb://localhost:27017")
    db = mongodb_client.news_cms_test
    await db.triggers.insert_one({
        "_id": "test_trigger",
        "name": "Test Trigger",
        "description": "Test",
        "trigger_type": "test",
        "status": "unconfigured",
        "last_updated": datetime.utcnow(),
        "created_at": datetime.utcnow(),
        "created_by": "test"
    })

    # 2. Fetch triggers
    response = client.get("/api/triggers")
    assert response.status_code == 200
    triggers = response.json()
    assert len(triggers) > 0

    # 3. Get config
    response = client.get(f"/api/triggers/{triggers[0]['id']}/config")
    assert response.status_code == 200

    # Cleanup
    await db.triggers.delete_many({})
    mongodb_client.close()
```

**Manual Verification Checklist**:
1. Backend API accessible at http://localhost:8000/api/triggers
2. FastAPI docs show triggers endpoints at http://localhost:8000/docs
3. Dashboard page loads successfully at http://localhost:3000
4. Triggers display in card grid with correct data
5. Status badges show correct colors (green=configured, gray=unconfigured)
6. Loading spinner appears during data fetch
7. Empty state appears with no triggers (clear database to test)
8. Error state appears on API failure (stop backend to test)
9. Clicking trigger navigates to /config/:triggerId
10. Page loads in under 2 seconds with 10+ triggers (NFR1)
11. Responsive layout works on desktop, tablet, mobile
12. No console errors in browser

**Coverage Target**: 70%+ for critical paths

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-29 | 1.0 | Initial story created from Epic 1 | Sarah (PO) |
| 2025-10-29 | 1.1 | Enriched with full architectural context and testing standards | Bob (SM) |

## Dev Agent Record

*To be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*To be filled by QA agent*
